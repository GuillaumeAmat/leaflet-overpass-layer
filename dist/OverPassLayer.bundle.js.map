{"version":3,"sources":["webpack:///OverPassLayer.bundle.js","webpack:///webpack/bootstrap b1b0e3b7e8441ec283a5","webpack:///./OverPassLayer.js","webpack:///external \"L\"","webpack:///../~/js-clipper/clipper.js","webpack:///./MinZoomIndicator.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_options","L","ClipperLib","OverPassLayer","FeatureGroup","extend","options","debug","minZoom","endPoint","query","loadedBounds","markerIcon","timeout","retryOnTimeout","noInitialRequest","data","i","elements","length","pos","popupContent","popup","marker","e","this","_ids","type","LatLng","lat","lon","center","icon","circle","stroke","fillColor","fillOpacity","_getPoiPopupHTML","tags","setContent","bindPopup","_markers","addLayer","minZoomMessageNoLayer","minZoomMessage","initialize","Util","setOptions","_loadedBounds","_requestInProgress","row","link","document","createElement","table","div","href","appendChild","createTextNode","style","borderSpacing","borderCollapse","insertRow","insertCell","_buildRequestBox","bounds","rectangle","color","clickable","_addRequestBox","box","_requestBoxes","_getRequestBoxes","getLayers","_removeRequestBox","removeLayer","_removeRequestBoxes","clearLayers","_addResponseBox","_responseBoxes","_addResponseBoxes","requestBoxes","self","forEach","setStyle","weight","_isFullyLoadedBounds","solutionExPolygons","subjectClips","_buildClipsFromBounds","knownClips","clipper","Clipper","solutionPolyTree","PolyTree","AddPaths","PolyType","ptSubject","ptClip","Execute","ClipType","ctDifference","PolyFillType","pftNonZero","JS","PolyTreeToExPolygons","_getLoadedBounds","_addLoadedBounds","push","clips","bound","X","_southWest","lng","Y","_northEast","_buildBoundsFromClips","clip","LatLngBounds","_buildOverpassQueryFromQueryAndBounds","sw","ne","coordinates","join","replace","_buildOverpassUrlFromEndPointAndQuery","_buildLargerBounds","width","Math","abs","height","biggestDimension","latLngBounds","latLng","_setRequestInProgress","isInProgress","_isRequestInProgress","_hasNextRequest","_nextRequest","_getNextRequest","nextRequest","_setNextRequest","_removeNextRequest","_prepareRequest","_map","getZoom","getBounds","_sendRequest","bind","requestBounds","url","request","XMLHttpRequest","beforeRequestResult","beforeRequest","afterRequest","open","ontimeout","_onRequestTimeout","onload","_onRequestLoad","send","xhr","status","onSuccess","JSON","parse","response","_onRequestLoadCallback","_onRequestErrorCallback","onError","_onRequestCompleteCallback","onTimeout","onAdd","map","zoomIndicator","_zoomControl","_addLayer","Control","MinZoomIndicator","minZoomIndicatorOptions","addControl","featureGroup","addTo","on","onRemove","LayerGroup","prototype","off","setQuery","_resetData","getData","_data","overpassLayer","BigInteger","a","b","biginteger_used","fromInt","fromNumber","fromString","nbi","am1","x","w","j","n","v","floor","am2","xl","xh","l","h","am3","int2char","BI_RM","charAt","intAt","s","BI_RC","charCodeAt","bnpCopyTo","r","t","bnpFromInt","DV","nbv","bnpFromString","k","fromRadix","mi","sh","DB","clamp","ZERO","subTo","bnpClamp","DM","bnToString","negate","toString","toRadix","d","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","max","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","min","bnpMultiplyTo","y","am","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","mod","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","log","bnSigNum","bnpToRadix","signum","cs","chunkSize","pow","intValue","substr","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","Array","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","op","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","u","subtract","add","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","modPowInt","use_int32","use_xyz","use_lines","use_deprecated","isNode","window","navigator_appName","nav","navigator","userAgent","toLowerCase","appName","browser","indexOf","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","dbits","canary","j_lm","BI_FP","rr","vv","byteValue","shortValue","toByteArray","equals","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","parseFloat","Inherit","ce","ce2","$baseCtor","props","getOwnPropertyNames","getOwnPropertyDescriptor","Path","Paths","DoublePoint","arguments","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","result","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","m_AllPolys","Clear","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","Number","toInteger","parseInt","PI","PI2","IntPoint","alen","Z","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ctIntersection","ctUnion","ctXor","pftEvenOdd","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EndType_","etSquare","etRound","etButt","etClosed","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","val","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","Error","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","IsClockwise","Horz","StartX","EStart","Result","ReverseHorizontal","locMin","InsertLocalMinima","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","RemoveEdge","Pt2IsBetweenPt1AndPt3","clockwise","EMin","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","index","DisposeOutPts","tmpPp","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","next","prev","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","Pt1a","Pt1b","Pt2a","Pt2b","InsertPolyPtBetween","p1","p2","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","idx","outrec","holeStateRec","side","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","protect","e1stops","e2stops","e1Contributing","e2Contributing","DeleteFromAEL","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","PrepareHorzJoins","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","round","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","paths","GetBounds2","ops","opStart","PointInPolygon","path","ipNext","startOp","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","FixupFirstLefts2","$i2","$t2","$l2","ParseFirstLeft","UpdateOutPtIdxs","oRec","op3","op4","outrec2","OffsetPaths","delta","jointype","endtype","MiterLimit","co","ClipperOffset","SimplifyPolygon","fillType","SimplifyPolygons","DistanceSqrd","dx","dy","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","polyCnt","pathCnt","quads","quad","MinkowskiSum","pathIsClosed","pathFillType","MinkowskiDiff","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","match","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","ArcTolerance","two_pi","joinType","endType","FixOrientations","GetUnitNormal","sqrt","DoOffset","steps","acos","sin","cos","OffsetPoint","DoSquare","DoRound","X2","clpr","outer","outerNode","splice","DoMiter","tan","atan2","message","err","alert","AreaOfPolygon","scale","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","poly2","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","pop","PerimeterOfPath","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","holes","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths","_layers","layer","_leaflet_id","_updateBox","_removeLayer","_getMinZoomLevel","minZoomLevel","event","DomEvent","preventDefault","_container","innerHTML","display","DomUtil","create","moveend"],"mappings":"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","file":"OverPassLayer.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _options;\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar L = __webpack_require__(1);\n\tvar ClipperLib = __webpack_require__(2);\n\tvar css = __webpack_require__(3);\n\tvar MinZoomIndicator = __webpack_require__(5);\n\t\n\tvar OverPassLayer = L.FeatureGroup.extend({\n\t\n\t    options: (_options = {\n\t\n\t        'debug': false,\n\t        'minZoom': 15,\n\t        'endPoint': 'https://overpass-api.de/api/',\n\t        'query': '(node({{bbox}})[organic];node({{bbox}})[second_hand];);out qt;',\n\t        'loadedBounds': [],\n\t        'markerIcon': null,\n\t        'timeout': 30 * 1000, // Milliseconds\n\t        'retryOnTimeout': false,\n\t        'noInitialRequest': false\n\t    }, _defineProperty(_options, 'noInitialRequest', false), _defineProperty(_options, 'beforeRequest', function beforeRequest() {}), _defineProperty(_options, 'afterRequest', function afterRequest() {}), _defineProperty(_options, 'onSuccess', function onSuccess(data) {\n\t\n\t        for (var i = 0; i < data.elements.length; i++) {\n\t\n\t            var pos,\n\t                popupContent,\n\t                popup,\n\t                marker,\n\t                e = data.elements[i];\n\t\n\t            if (e.id in this._ids) {\n\t\n\t                continue;\n\t            }\n\t\n\t            this._ids[e.id] = true;\n\t\n\t            if (e.type === 'node') {\n\t\n\t                pos = new L.LatLng(e.lat, e.lon);\n\t            } else {\n\t\n\t                pos = new L.LatLng(e.center.lat, e.center.lon);\n\t            }\n\t\n\t            if (this.options.markerIcon) {\n\t                marker = L.marker(pos, { icon: this.options.markerIcon });\n\t            } else {\n\t                marker = L.circle(pos, 20, {\n\t                    'stroke': false,\n\t                    'fillColor': '#E54041',\n\t                    'fillOpacity': 0.9\n\t                });\n\t            }\n\t\n\t            popupContent = this._getPoiPopupHTML(e.tags, e.id);\n\t            popup = L.popup().setContent(popupContent);\n\t            marker.bindPopup(popup);\n\t\n\t            this._markers.addLayer(marker);\n\t        }\n\t    }), _defineProperty(_options, 'onError', function onError() {}), _defineProperty(_options, 'onTimeout', function onTimeout() {}), _defineProperty(_options, 'minZoomIndicatorOptions', {\n\t\n\t        'minZoomMessageNoLayer': 'No layer assigned',\n\t        'minZoomMessage': 'Current zoom Level: CURRENTZOOM. Data are visible at Level: MINZOOMLEVEL.'\n\t    }), _options),\n\t\n\t    initialize: function initialize(options) {\n\t\n\t        L.Util.setOptions(this, options);\n\t\n\t        this._ids = {};\n\t        this._loadedBounds = options.loadedBounds || [];\n\t        this._requestInProgress = false;\n\t    },\n\t\n\t    _getPoiPopupHTML: function _getPoiPopupHTML(tags, id) {\n\t\n\t        var row,\n\t            link = document.createElement('a'),\n\t            table = document.createElement('table'),\n\t            div = document.createElement('div');\n\t\n\t        link.href = 'http://www.openstreetmap.org/edit?editor=id&node=' + id;\n\t        link.appendChild(document.createTextNode('Edit this entry in iD'));\n\t\n\t        table.style.borderSpacing = '10px';\n\t        table.style.borderCollapse = 'separate';\n\t\n\t        for (var key in tags) {\n\t\n\t            row = table.insertRow(0);\n\t            row.insertCell(0).appendChild(document.createTextNode(key));\n\t            row.insertCell(1).appendChild(document.createTextNode(tags[key]));\n\t        }\n\t\n\t        div.appendChild(link);\n\t        div.appendChild(table);\n\t\n\t        return div;\n\t    },\n\t\n\t    _buildRequestBox: function _buildRequestBox(bounds) {\n\t\n\t        return L.rectangle(bounds, {\n\t            'bounds': bounds,\n\t            'color': '#204a87',\n\t            'stroke': false,\n\t            'fillOpacity': 0.1,\n\t            'clickable': false\n\t        });\n\t    },\n\t\n\t    _addRequestBox: function _addRequestBox(box) {\n\t\n\t        return this._requestBoxes.addLayer(box);\n\t    },\n\t\n\t    _getRequestBoxes: function _getRequestBoxes() {\n\t\n\t        return this._requestBoxes.getLayers();\n\t    },\n\t\n\t    _removeRequestBox: function _removeRequestBox(box) {\n\t\n\t        this._requestBoxes.removeLayer(box);\n\t    },\n\t\n\t    _removeRequestBoxes: function _removeRequestBoxes() {\n\t\n\t        return this._requestBoxes.clearLayers();\n\t    },\n\t\n\t    _addResponseBox: function _addResponseBox(box) {\n\t\n\t        return this._responseBoxes.addLayer(box);\n\t    },\n\t\n\t    _addResponseBoxes: function _addResponseBoxes(requestBoxes) {\n\t        var self = this,\n\t            count = requestBoxes.length;\n\t\n\t        this._removeRequestBoxes();\n\t\n\t        requestBoxes.forEach(function (box) {\n\t\n\t            box.setStyle({\n\t                'color': 'black',\n\t                'weight': 2\n\t            });\n\t            self._addResponseBox(box);\n\t        });\n\t    },\n\t\n\t    _isFullyLoadedBounds: function _isFullyLoadedBounds(bounds, loadedBounds) {\n\t\n\t        if (loadedBounds.length === 0) {\n\t            return false;\n\t        }\n\t\n\t        var solutionExPolygons,\n\t            subjectClips = this._buildClipsFromBounds([bounds]),\n\t            knownClips = this._buildClipsFromBounds(loadedBounds),\n\t            clipper = new ClipperLib.Clipper(),\n\t            solutionPolyTree = new ClipperLib.PolyTree();\n\t\n\t        clipper.AddPaths(subjectClips, ClipperLib.PolyType.ptSubject, true);\n\t        clipper.AddPaths(knownClips, ClipperLib.PolyType.ptClip, true);\n\t\n\t        clipper.Execute(ClipperLib.ClipType.ctDifference, solutionPolyTree, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\n\t        solutionExPolygons = ClipperLib.JS.PolyTreeToExPolygons(solutionPolyTree);\n\t\n\t        if (solutionExPolygons.length === 0) {\n\t            return true;\n\t        } else {\n\t            return false;\n\t        }\n\t    },\n\t\n\t    _getLoadedBounds: function _getLoadedBounds() {\n\t\n\t        return this._loadedBounds;\n\t    },\n\t\n\t    _addLoadedBounds: function _addLoadedBounds(bounds) {\n\t\n\t        this._loadedBounds.push(bounds);\n\t    },\n\t\n\t    _buildClipsFromBounds: function _buildClipsFromBounds(bounds) {\n\t\n\t        var clips = [];\n\t\n\t        bounds.forEach(function (bound) {\n\t            clips.push([{\n\t                'X': bound._southWest.lng * 1000000,\n\t                'Y': bound._southWest.lat * 1000000\n\t            }, {\n\t                'X': bound._southWest.lng * 1000000,\n\t                'Y': bound._northEast.lat * 1000000\n\t            }, {\n\t                'X': bound._northEast.lng * 1000000,\n\t                'Y': bound._northEast.lat * 1000000\n\t            }, {\n\t                'X': bound._northEast.lng * 1000000,\n\t                'Y': bound._southWest.lat * 1000000\n\t            }]);\n\t        });\n\t\n\t        return clips;\n\t    },\n\t\n\t    _buildBoundsFromClips: function _buildBoundsFromClips(clips) {\n\t\n\t        var bounds = [];\n\t\n\t        clips.forEach(function (clip) {\n\t            bounds.push(new L.LatLngBounds(new L.LatLng(clip[0].Y / 1000000, clip[0].X / 1000000), new L.LatLng(clip[2].Y / 1000000, clip[2].X / 1000000)));\n\t        });\n\t\n\t        return bounds;\n\t    },\n\t\n\t    _buildOverpassQueryFromQueryAndBounds: function _buildOverpassQueryFromQueryAndBounds(query, bounds) {\n\t\n\t        var sw = bounds._southWest,\n\t            ne = bounds._northEast,\n\t            coordinates = [sw.lat, sw.lng, ne.lat, ne.lng].join(',');\n\t\n\t        query = query.replace(/(\\/\\/.*)/g, '');\n\t        query = query.replace(/(\\{\\{bbox\\}\\})/g, coordinates);\n\t\n\t        return query;\n\t    },\n\t\n\t    _buildOverpassUrlFromEndPointAndQuery: function _buildOverpassUrlFromEndPointAndQuery(endPoint, query) {\n\t\n\t        return endPoint + 'interpreter?data=[out:json];' + query;\n\t    },\n\t\n\t    _buildLargerBounds: function _buildLargerBounds(bounds) {\n\t\n\t        var width = Math.abs(bounds._northEast.lng - bounds._southWest.lng),\n\t            height = Math.abs(bounds._northEast.lat - bounds._southWest.lat),\n\t            biggestDimension = width > height ? width : height;\n\t\n\t        bounds._southWest.lat -= biggestDimension / 2;\n\t        bounds._southWest.lng -= biggestDimension / 2;\n\t        bounds._northEast.lat += biggestDimension / 2;\n\t        bounds._northEast.lng += biggestDimension / 2;\n\t\n\t        return L.latLngBounds(L.latLng(bounds._southWest.lat, bounds._southWest.lng), L.latLng(bounds._northEast.lat, bounds._northEast.lng));\n\t    },\n\t\n\t    _setRequestInProgress: function _setRequestInProgress(isInProgress) {\n\t\n\t        this._requestInProgress = isInProgress;\n\t    },\n\t\n\t    _isRequestInProgress: function _isRequestInProgress() {\n\t\n\t        return this._requestInProgress;\n\t    },\n\t\n\t    _hasNextRequest: function _hasNextRequest() {\n\t\n\t        if (this._nextRequest) {\n\t\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    },\n\t\n\t    _getNextRequest: function _getNextRequest(nextRequest) {\n\t\n\t        return this._nextRequest;\n\t    },\n\t\n\t    _setNextRequest: function _setNextRequest(nextRequest) {\n\t\n\t        this._nextRequest = nextRequest;\n\t    },\n\t\n\t    _removeNextRequest: function _removeNextRequest() {\n\t\n\t        this._nextRequest = null;\n\t    },\n\t\n\t    _prepareRequest: function _prepareRequest() {\n\t\n\t        if (this._map.getZoom() < this.options.minZoom) {\n\t\n\t            return false;\n\t        }\n\t\n\t        var bounds = this._buildLargerBounds(this._map.getBounds()),\n\t            nextRequest = this._sendRequest.bind(this, bounds);\n\t\n\t        if (this._isRequestInProgress()) {\n\t\n\t            this._setNextRequest(nextRequest);\n\t        } else {\n\t\n\t            this._removeNextRequest();\n\t            nextRequest();\n\t        }\n\t    },\n\t\n\t    _sendRequest: function _sendRequest(bounds) {\n\t\n\t        var loadedBounds = this._getLoadedBounds();\n\t\n\t        if (this._isFullyLoadedBounds(bounds, loadedBounds)) {\n\t            this._setRequestInProgress(false);\n\t            return;\n\t        }\n\t\n\t        var self = this,\n\t            requestBounds = this._buildLargerBounds(bounds),\n\t            url = this._buildOverpassUrlFromEndPointAndQuery(this.options.endPoint, this._buildOverpassQueryFromQueryAndBounds(this.options.query, requestBounds)),\n\t            request = new XMLHttpRequest(),\n\t            beforeRequestResult = this.options.beforeRequest.call(this);\n\t\n\t        if (beforeRequestResult === false) {\n\t\n\t            this.options.afterRequest.call(this);\n\t\n\t            return;\n\t        }\n\t\n\t        this._setRequestInProgress(true);\n\t\n\t        if (this.options.debug) {\n\t\n\t            this._addRequestBox(this._buildRequestBox(requestBounds));\n\t        }\n\t\n\t        request.open('GET', url, true);\n\t        request.timeout = this.options.timeout;\n\t\n\t        request.ontimeout = function () {\n\t\n\t            self._onRequestTimeout(this, url, requestBounds);\n\t        };\n\t\n\t        request.onload = function () {\n\t\n\t            self._onRequestLoad(this, requestBounds);\n\t        };\n\t\n\t        request.send();\n\t    },\n\t\n\t    _onRequestLoad: function _onRequestLoad(xhr, bounds) {\n\t\n\t        if (xhr.status >= 200 && xhr.status < 400) {\n\t\n\t            this.options.onSuccess.call(this, JSON.parse(xhr.response));\n\t\n\t            this._onRequestLoadCallback(bounds);\n\t        } else {\n\t\n\t            this._onRequestErrorCallback(bounds);\n\t\n\t            this.options.onError.call(this, xhr);\n\t        }\n\t\n\t        this._onRequestCompleteCallback(bounds);\n\t    },\n\t\n\t    _onRequestTimeout: function _onRequestTimeout(xhr, url, bounds) {\n\t\n\t        this.options.onTimeout.call(this, xhr);\n\t\n\t        if (this.options.retryOnTimeout) {\n\t\n\t            this._sendRequest(url);\n\t        } else {\n\t\n\t            this._onRequestErrorCallback(bounds);\n\t            this._onRequestCompleteCallback(bounds);\n\t        }\n\t    },\n\t\n\t    _onRequestLoadCallback: function _onRequestLoadCallback(bounds) {\n\t\n\t        this._addLoadedBounds(bounds);\n\t\n\t        if (this.options.debug) {\n\t\n\t            this._addResponseBoxes(this._getRequestBoxes());\n\t        }\n\t    },\n\t\n\t    _onRequestErrorCallback: function _onRequestErrorCallback(bounds) {\n\t\n\t        if (this.options.debug) {\n\t\n\t            this._removeRequestBox(this._buildRequestBox(bounds));\n\t        }\n\t    },\n\t\n\t    _onRequestCompleteCallback: function _onRequestCompleteCallback(bounds) {\n\t\n\t        this.options.afterRequest.call(this);\n\t\n\t        if (this._hasNextRequest()) {\n\t\n\t            var nextRequest = this._getNextRequest();\n\t\n\t            this._removeNextRequest();\n\t\n\t            nextRequest();\n\t        } else {\n\t\n\t            this._setRequestInProgress(false);\n\t        }\n\t    },\n\t\n\t    onAdd: function onAdd(map) {\n\t\n\t        this._map = map;\n\t\n\t        if (this._map.zoomIndicator) {\n\t\n\t            this._zoomControl = this._map.zoomIndicator;\n\t            this._zoomControl._addLayer(this);\n\t        } else {\n\t\n\t            this._zoomControl = new L.Control.MinZoomIndicator(this.options.minZoomIndicatorOptions);\n\t\n\t            this._map.addControl(this._zoomControl);\n\t\n\t            this._zoomControl._addLayer(this);\n\t        }\n\t\n\t        if (this.options.debug) {\n\t\n\t            this._requestBoxes = L.featureGroup().addTo(this._map);\n\t            this._responseBoxes = L.featureGroup().addTo(this._map);\n\t        }\n\t\n\t        this._markers = L.featureGroup().addTo(this._map);\n\t\n\t        if (!this.options.noInitialRequest) {\n\t            this._prepareRequest();\n\t        }\n\t\n\t        this._map.on('moveend', this._prepareRequest, this);\n\t    },\n\t\n\t    onRemove: function onRemove(map) {\n\t\n\t        L.LayerGroup.prototype.onRemove.call(this, map);\n\t\n\t        map.removeLayer(this._markers);\n\t        map.removeLayer(this._requestBoxes);\n\t        map.removeLayer(this._responseBoxes);\n\t\n\t        map.off('moveend', this._prepareRequest, this);\n\t\n\t        this._map = null;\n\t    },\n\t\n\t    setQuery: function setQuery(query) {\n\t        this.options.query = query;\n\t        this._resetData();\n\t        this._prepareRequest();\n\t    },\n\t\n\t    _resetData: function _resetData(map) {\n\t        this._ids = {};\n\t        this._loadedBounds = [];\n\t        this._requestInProgress = false;\n\t\n\t        if (this.options.debug) {\n\t            this._markers.clearLayers();\n\t            this._requestBoxes.clearLayers();\n\t            this._responseBoxes.clearLayers();\n\t        }\n\t    },\n\t\n\t    getData: function getData() {\n\t\n\t        return this._data;\n\t    }\n\t});\n\t\n\tL.OverPassLayer = OverPassLayer;\n\tL.overpassLayer = function (options) {\n\t    return new L.OverPassLayer(options);\n\t};\n\tmodule.exports = OverPassLayer;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = L;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// rev 452\n\t/********************************************************************************\n\t*                                                                              *\n\t* Author    :  Angus Johnson                                                   *\n\t* Version   :  6.1.3a                                                          *\n\t* Date      :  22 January 2014                                                 *\n\t* Website   :  http://www.angusj.com                                           *\n\t* Copyright :  Angus Johnson 2010-2014                                         *\n\t*                                                                              *\n\t* License:                                                                     *\n\t* Use, modification & distribution is subject to Boost Software License Ver 1. *\n\t* http://www.boost.org/LICENSE_1_0.txt                                         *\n\t*                                                                              *\n\t* Attributions:                                                                *\n\t* The code in this library is an extension of Bala Vatti's clipping algorithm: *\n\t* \"A generic solution to polygon clipping\"                                     *\n\t* Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n\t* http://portal.acm.org/citation.cfm?id=129906                                 *\n\t*                                                                              *\n\t* Computer graphics and geometric modeling: implementation and algorithms      *\n\t* By Max K. Agoston                                                            *\n\t* Springer; 1 edition (January 4, 2005)                                        *\n\t* http://books.google.com/books?q=vatti+clipping+agoston                       *\n\t*                                                                              *\n\t* See also:                                                                    *\n\t* \"Polygon Offsetting by Computing Winding Numbers\"                            *\n\t* Paper no. DETC2005-85513 pp. 565-575                                         *\n\t* ASME 2005 International Design Engineering Technical Conferences             *\n\t* and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n\t* September 24-28, 2005 , Long Beach, California, USA                          *\n\t* http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n\t*                                                                              *\n\t*******************************************************************************/\n\t/*******************************************************************************\n\t*                                                                              *\n\t* Author    :  Timo                                                            *\n\t* Version   :  6.1.3.2                                                         *\n\t* Date      :  1 February 2014                                                 *\n\t*                                                                              *\n\t* This is a translation of the C# Clipper library to Javascript.               *\n\t* Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n\t* Because Javascript lacks support for 64-bit integers, the space              *\n\t* is a little more restricted than in C# version.                              *\n\t*                                                                              *\n\t* C# version has support for coordinate space:                                 *\n\t* +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n\t* while Javascript version has support for space:                              *\n\t* +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n\t*                                                                              *\n\t* Tom Wu's JSBN proved to be the fastest big integer library:                  *\n\t* http://jsperf.com/big-integer-library-test                                   *\n\t*                                                                              *\n\t* This class can be made simpler when (if ever) 64-bit integer support comes.  *\n\t*                                                                              *\n\t*******************************************************************************/\n\t/*******************************************************************************\n\t*                                                                              *\n\t* Basic JavaScript BN library - subset useful for RSA encryption.              *\n\t* http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n\t* Copyright (c) 2005  Tom Wu                                                   *\n\t* All Rights Reserved.                                                         *\n\t* See \"LICENSE\" for details:                                                   *\n\t* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n\t*                                                                              *\n\t*******************************************************************************/\n\t\n\t\"use strict\";\n\t//use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n\t//improve performance but coordinate values are limited to the range +/- 46340\n\tvar use_int32 = false;\n\t//use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\tvar use_xyz = false;\n\t//UseLines: Enables line clipping. Adds a very minor cost to performance.\n\tvar use_lines = true;\n\t//use_deprecated: Enables support for the obsolete OffsetPaths() function\n\t//which has been replace with the ClipperOffset class.\n\tvar use_deprecated = false;\n\t\n\tvar ClipperLib = {};\n\tvar isNode = false;\n\tif (typeof module !== 'undefined' && module.exports)\n\t{\n\t  module.exports = ClipperLib;\n\t  isNode = true;\n\t}\n\telse\n\t{\n\t  if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t  else self['ClipperLib'] = ClipperLib;\n\t}\n\tvar navigator_appName;\n\tif (!isNode)\n\t{\n\t  var nav = navigator.userAgent.toString().toLowerCase();\n\t  navigator_appName = navigator.appName;\n\t}\n\telse\n\t{\n\t  var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t  navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t}\n\t// Browser test to speedup performance critical functions\n\tvar browser = {};\n\tif (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\telse browser.chrome = 0;\n\tif (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\telse browser.chromium = 0;\n\tif (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\telse browser.safari = 0;\n\tif (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\telse browser.firefox = 0;\n\tif (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\telse browser.firefox17 = 0;\n\tif (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\telse browser.firefox15 = 0;\n\tif (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\telse browser.firefox3 = 0;\n\tif (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\telse browser.opera = 0;\n\tif (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\telse browser.msie10 = 0;\n\tif (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\telse browser.msie9 = 0;\n\tif (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\telse browser.msie8 = 0;\n\tif (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\telse browser.msie7 = 0;\n\tif (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\telse browser.msie = 0;\n\tClipperLib.biginteger_used = null;\n\t// Copyright (c) 2005  Tom Wu\n\t// All Rights Reserved.\n\t// See \"LICENSE\" for details.\n\t// Basic JavaScript BN library - subset useful for RSA encryption.\n\t// Bits per digit\n\tvar dbits;\n\t// JavaScript engine analysis\n\tvar canary = 0xdeadbeefcafe;\n\tvar j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t// (public) Constructor\n\tfunction BigInteger(a, b, c)\n\t{\n\t  // This test variable can be removed,\n\t  // but at least for performance tests it is useful piece of knowledge\n\t  // This is the only ClipperLib related variable in BigInteger library\n\t  ClipperLib.biginteger_used = 1;\n\t  if (a != null)\n\t    if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t    else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t  else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t  else this.fromString(a, b);\n\t}\n\t// return new, unset BigInteger\n\tfunction nbi()\n\t{\n\t  return new BigInteger(null);\n\t}\n\t// am: Compute w_j += (x*this_i), propagate carries,\n\t// c is initial carry, returns final carry.\n\t// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t// We need to select the fastest one that works in this environment.\n\t// am1: use a single mult and divide to get the high bits,\n\t// max digit bits should be 26 because\n\t// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\tfunction am1(i, x, w, j, c, n)\n\t{\n\t  while (--n >= 0)\n\t  {\n\t    var v = x * this[i++] + w[j] + c;\n\t    c = Math.floor(v / 0x4000000);\n\t    w[j++] = v & 0x3ffffff;\n\t  }\n\t  return c;\n\t}\n\t// am2 avoids a big mult-and-extract completely.\n\t// Max digit bits should be <= 30 because we do bitwise ops\n\t// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\tfunction am2(i, x, w, j, c, n)\n\t{\n\t  var xl = x & 0x7fff,\n\t    xh = x >> 15;\n\t  while (--n >= 0)\n\t  {\n\t    var l = this[i] & 0x7fff;\n\t    var h = this[i++] >> 15;\n\t    var m = xh * l + h * xl;\n\t    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t    w[j++] = l & 0x3fffffff;\n\t  }\n\t  return c;\n\t}\n\t// Alternately, set max digit bits to 28 since some\n\t// browsers slow down when dealing with 32-bit numbers.\n\tfunction am3(i, x, w, j, c, n)\n\t{\n\t  var xl = x & 0x3fff,\n\t    xh = x >> 14;\n\t  while (--n >= 0)\n\t  {\n\t    var l = this[i] & 0x3fff;\n\t    var h = this[i++] >> 14;\n\t    var m = xh * l + h * xl;\n\t    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t    c = (l >> 28) + (m >> 14) + xh * h;\n\t    w[j++] = l & 0xfffffff;\n\t  }\n\t  return c;\n\t}\n\tif (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t{\n\t  BigInteger.prototype.am = am2;\n\t  dbits = 30;\n\t}\n\telse if (j_lm && (navigator_appName != \"Netscape\"))\n\t{\n\t  BigInteger.prototype.am = am1;\n\t  dbits = 26;\n\t}\n\telse\n\t{ // Mozilla/Netscape seems to prefer am3\n\t  BigInteger.prototype.am = am3;\n\t  dbits = 28;\n\t}\n\tBigInteger.prototype.DB = dbits;\n\tBigInteger.prototype.DM = ((1 << dbits) - 1);\n\tBigInteger.prototype.DV = (1 << dbits);\n\tvar BI_FP = 52;\n\tBigInteger.prototype.FV = Math.pow(2, BI_FP);\n\tBigInteger.prototype.F1 = BI_FP - dbits;\n\tBigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t// Digit conversions\n\tvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\tvar BI_RC = new Array();\n\tvar rr, vv;\n\trr = \"0\".charCodeAt(0);\n\tfor (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\trr = \"a\".charCodeAt(0);\n\tfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\trr = \"A\".charCodeAt(0);\n\tfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\tfunction int2char(n)\n\t{\n\t  return BI_RM.charAt(n);\n\t}\n\t\n\tfunction intAt(s, i)\n\t{\n\t  var c = BI_RC[s.charCodeAt(i)];\n\t  return (c == null) ? -1 : c;\n\t}\n\t// (protected) copy this to r\n\tfunction bnpCopyTo(r)\n\t{\n\t  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t  r.t = this.t;\n\t  r.s = this.s;\n\t}\n\t// (protected) set from integer value x, -DV <= x < DV\n\tfunction bnpFromInt(x)\n\t{\n\t  this.t = 1;\n\t  this.s = (x < 0) ? -1 : 0;\n\t  if (x > 0) this[0] = x;\n\t  else if (x < -1) this[0] = x + this.DV;\n\t  else this.t = 0;\n\t}\n\t// return bigint initialized to value\n\tfunction nbv(i)\n\t{\n\t  var r = nbi();\n\t  r.fromInt(i);\n\t  return r;\n\t}\n\t// (protected) set from string and radix\n\tfunction bnpFromString(s, b)\n\t{\n\t  var k;\n\t  if (b == 16) k = 4;\n\t  else if (b == 8) k = 3;\n\t  else if (b == 256) k = 8; // byte array\n\t  else if (b == 2) k = 1;\n\t  else if (b == 32) k = 5;\n\t  else if (b == 4) k = 2;\n\t  else\n\t  {\n\t    this.fromRadix(s, b);\n\t    return;\n\t  }\n\t  this.t = 0;\n\t  this.s = 0;\n\t  var i = s.length,\n\t    mi = false,\n\t    sh = 0;\n\t  while (--i >= 0)\n\t  {\n\t    var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t    if (x < 0)\n\t    {\n\t      if (s.charAt(i) == \"-\") mi = true;\n\t      continue;\n\t    }\n\t    mi = false;\n\t    if (sh == 0)\n\t      this[this.t++] = x;\n\t    else if (sh + k > this.DB)\n\t    {\n\t      this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t      this[this.t++] = (x >> (this.DB - sh));\n\t    }\n\t    else\n\t      this[this.t - 1] |= x << sh;\n\t    sh += k;\n\t    if (sh >= this.DB) sh -= this.DB;\n\t  }\n\t  if (k == 8 && (s[0] & 0x80) != 0)\n\t  {\n\t    this.s = -1;\n\t    if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t  }\n\t  this.clamp();\n\t  if (mi) BigInteger.ZERO.subTo(this, this);\n\t}\n\t// (protected) clamp off excess high words\n\tfunction bnpClamp()\n\t{\n\t  var c = this.s & this.DM;\n\t  while (this.t > 0 && this[this.t - 1] == c)--this.t;\n\t}\n\t// (public) return string representation in given radix\n\tfunction bnToString(b)\n\t{\n\t  if (this.s < 0) return \"-\" + this.negate().toString(b);\n\t  var k;\n\t  if (b == 16) k = 4;\n\t  else if (b == 8) k = 3;\n\t  else if (b == 2) k = 1;\n\t  else if (b == 32) k = 5;\n\t  else if (b == 4) k = 2;\n\t  else return this.toRadix(b);\n\t  var km = (1 << k) - 1,\n\t    d, m = false,\n\t    r = \"\",\n\t    i = this.t;\n\t  var p = this.DB - (i * this.DB) % k;\n\t  if (i-- > 0)\n\t  {\n\t    if (p < this.DB && (d = this[i] >> p) > 0)\n\t    {\n\t      m = true;\n\t      r = int2char(d);\n\t    }\n\t    while (i >= 0)\n\t    {\n\t      if (p < k)\n\t      {\n\t        d = (this[i] & ((1 << p) - 1)) << (k - p);\n\t        d |= this[--i] >> (p += this.DB - k);\n\t      }\n\t      else\n\t      {\n\t        d = (this[i] >> (p -= k)) & km;\n\t        if (p <= 0)\n\t        {\n\t          p += this.DB;\n\t          --i;\n\t        }\n\t      }\n\t      if (d > 0) m = true;\n\t      if (m) r += int2char(d);\n\t    }\n\t  }\n\t  return m ? r : \"0\";\n\t}\n\t// (public) -this\n\tfunction bnNegate()\n\t{\n\t  var r = nbi();\n\t  BigInteger.ZERO.subTo(this, r);\n\t  return r;\n\t}\n\t// (public) |this|\n\tfunction bnAbs()\n\t{\n\t  return (this.s < 0) ? this.negate() : this;\n\t}\n\t// (public) return + if this > a, - if this < a, 0 if equal\n\tfunction bnCompareTo(a)\n\t{\n\t  var r = this.s - a.s;\n\t  if (r != 0) return r;\n\t  var i = this.t;\n\t  r = i - a.t;\n\t  if (r != 0) return (this.s < 0) ? -r : r;\n\t  while (--i >= 0)\n\t    if ((r = this[i] - a[i]) != 0) return r;\n\t  return 0;\n\t}\n\t// returns bit length of the integer x\n\tfunction nbits(x)\n\t{\n\t  var r = 1,\n\t    t;\n\t  if ((t = x >>> 16) != 0)\n\t  {\n\t    x = t;\n\t    r += 16;\n\t  }\n\t  if ((t = x >> 8) != 0)\n\t  {\n\t    x = t;\n\t    r += 8;\n\t  }\n\t  if ((t = x >> 4) != 0)\n\t  {\n\t    x = t;\n\t    r += 4;\n\t  }\n\t  if ((t = x >> 2) != 0)\n\t  {\n\t    x = t;\n\t    r += 2;\n\t  }\n\t  if ((t = x >> 1) != 0)\n\t  {\n\t    x = t;\n\t    r += 1;\n\t  }\n\t  return r;\n\t}\n\t// (public) return the number of bits in \"this\"\n\tfunction bnBitLength()\n\t{\n\t  if (this.t <= 0) return 0;\n\t  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t}\n\t// (protected) r = this << n*DB\n\tfunction bnpDLShiftTo(n, r)\n\t{\n\t  var i;\n\t  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t  for (i = n - 1; i >= 0; --i) r[i] = 0;\n\t  r.t = this.t + n;\n\t  r.s = this.s;\n\t}\n\t// (protected) r = this >> n*DB\n\tfunction bnpDRShiftTo(n, r)\n\t{\n\t  for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t  r.t = Math.max(this.t - n, 0);\n\t  r.s = this.s;\n\t}\n\t// (protected) r = this << n\n\tfunction bnpLShiftTo(n, r)\n\t{\n\t  var bs = n % this.DB;\n\t  var cbs = this.DB - bs;\n\t  var bm = (1 << cbs) - 1;\n\t  var ds = Math.floor(n / this.DB),\n\t    c = (this.s << bs) & this.DM,\n\t    i;\n\t  for (i = this.t - 1; i >= 0; --i)\n\t  {\n\t    r[i + ds + 1] = (this[i] >> cbs) | c;\n\t    c = (this[i] & bm) << bs;\n\t  }\n\t  for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t  r[ds] = c;\n\t  r.t = this.t + ds + 1;\n\t  r.s = this.s;\n\t  r.clamp();\n\t}\n\t// (protected) r = this >> n\n\tfunction bnpRShiftTo(n, r)\n\t{\n\t  r.s = this.s;\n\t  var ds = Math.floor(n / this.DB);\n\t  if (ds >= this.t)\n\t  {\n\t    r.t = 0;\n\t    return;\n\t  }\n\t  var bs = n % this.DB;\n\t  var cbs = this.DB - bs;\n\t  var bm = (1 << bs) - 1;\n\t  r[0] = this[ds] >> bs;\n\t  for (var i = ds + 1; i < this.t; ++i)\n\t  {\n\t    r[i - ds - 1] |= (this[i] & bm) << cbs;\n\t    r[i - ds] = this[i] >> bs;\n\t  }\n\t  if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t  r.t = this.t - ds;\n\t  r.clamp();\n\t}\n\t// (protected) r = this - a\n\tfunction bnpSubTo(a, r)\n\t{\n\t  var i = 0,\n\t    c = 0,\n\t    m = Math.min(a.t, this.t);\n\t  while (i < m)\n\t  {\n\t    c += this[i] - a[i];\n\t    r[i++] = c & this.DM;\n\t    c >>= this.DB;\n\t  }\n\t  if (a.t < this.t)\n\t  {\n\t    c -= a.s;\n\t    while (i < this.t)\n\t    {\n\t      c += this[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    c += this.s;\n\t  }\n\t  else\n\t  {\n\t    c += this.s;\n\t    while (i < a.t)\n\t    {\n\t      c -= a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    c -= a.s;\n\t  }\n\t  r.s = (c < 0) ? -1 : 0;\n\t  if (c < -1) r[i++] = this.DV + c;\n\t  else if (c > 0) r[i++] = c;\n\t  r.t = i;\n\t  r.clamp();\n\t}\n\t// (protected) r = this * a, r != this,a (HAC 14.12)\n\t// \"this\" should be the larger one if appropriate.\n\tfunction bnpMultiplyTo(a, r)\n\t{\n\t  var x = this.abs(),\n\t    y = a.abs();\n\t  var i = x.t;\n\t  r.t = i + y.t;\n\t  while (--i >= 0) r[i] = 0;\n\t  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t  r.s = 0;\n\t  r.clamp();\n\t  if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t}\n\t// (protected) r = this^2, r != this (HAC 14.16)\n\tfunction bnpSquareTo(r)\n\t{\n\t  var x = this.abs();\n\t  var i = r.t = 2 * x.t;\n\t  while (--i >= 0) r[i] = 0;\n\t  for (i = 0; i < x.t - 1; ++i)\n\t  {\n\t    var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t    {\n\t      r[i + x.t] -= x.DV;\n\t      r[i + x.t + 1] = 1;\n\t    }\n\t  }\n\t  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t  r.s = 0;\n\t  r.clamp();\n\t}\n\t// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t// r != q, this != m.  q or r may be null.\n\tfunction bnpDivRemTo(m, q, r)\n\t{\n\t  var pm = m.abs();\n\t  if (pm.t <= 0) return;\n\t  var pt = this.abs();\n\t  if (pt.t < pm.t)\n\t  {\n\t    if (q != null) q.fromInt(0);\n\t    if (r != null) this.copyTo(r);\n\t    return;\n\t  }\n\t  if (r == null) r = nbi();\n\t  var y = nbi(),\n\t    ts = this.s,\n\t    ms = m.s;\n\t  var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t  if (nsh > 0)\n\t  {\n\t    pm.lShiftTo(nsh, y);\n\t    pt.lShiftTo(nsh, r);\n\t  }\n\t  else\n\t  {\n\t    pm.copyTo(y);\n\t    pt.copyTo(r);\n\t  }\n\t  var ys = y.t;\n\t  var y0 = y[ys - 1];\n\t  if (y0 == 0) return;\n\t  var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t  var d1 = this.FV / yt,\n\t    d2 = (1 << this.F1) / yt,\n\t    e = 1 << this.F2;\n\t  var i = r.t,\n\t    j = i - ys,\n\t    t = (q == null) ? nbi() : q;\n\t  y.dlShiftTo(j, t);\n\t  if (r.compareTo(t) >= 0)\n\t  {\n\t    r[r.t++] = 1;\n\t    r.subTo(t, r);\n\t  }\n\t  BigInteger.ONE.dlShiftTo(ys, t);\n\t  t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t  while (y.t < ys) y[y.t++] = 0;\n\t  while (--j >= 0)\n\t  {\n\t    // Estimate quotient digit\n\t    var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t    { // Try it out\n\t      y.dlShiftTo(j, t);\n\t      r.subTo(t, r);\n\t      while (r[i] < --qd) r.subTo(t, r);\n\t    }\n\t  }\n\t  if (q != null)\n\t  {\n\t    r.drShiftTo(ys, q);\n\t    if (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t  }\n\t  r.t = ys;\n\t  r.clamp();\n\t  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t  if (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t}\n\t// (public) this mod a\n\tfunction bnMod(a)\n\t{\n\t  var r = nbi();\n\t  this.abs().divRemTo(a, null, r);\n\t  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t  return r;\n\t}\n\t// Modular reduction using \"classic\" algorithm\n\tfunction Classic(m)\n\t{\n\t  this.m = m;\n\t}\n\t\n\tfunction cConvert(x)\n\t{\n\t  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t  else return x;\n\t}\n\t\n\tfunction cRevert(x)\n\t{\n\t  return x;\n\t}\n\t\n\tfunction cReduce(x)\n\t{\n\t  x.divRemTo(this.m, null, x);\n\t}\n\t\n\tfunction cMulTo(x, y, r)\n\t{\n\t  x.multiplyTo(y, r);\n\t  this.reduce(r);\n\t}\n\t\n\tfunction cSqrTo(x, r)\n\t{\n\t  x.squareTo(r);\n\t  this.reduce(r);\n\t}\n\tClassic.prototype.convert = cConvert;\n\tClassic.prototype.revert = cRevert;\n\tClassic.prototype.reduce = cReduce;\n\tClassic.prototype.mulTo = cMulTo;\n\tClassic.prototype.sqrTo = cSqrTo;\n\t// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t// justification:\n\t//         xy == 1 (mod m)\n\t//         xy =  1+km\n\t//   xy(2-xy) = (1+km)(1-km)\n\t// x[y(2-xy)] = 1-k^2m^2\n\t// x[y(2-xy)] == 1 (mod m^2)\n\t// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t// JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\tfunction bnpInvDigit()\n\t{\n\t  if (this.t < 1) return 0;\n\t  var x = this[0];\n\t  if ((x & 1) == 0) return 0;\n\t  var y = x & 3; // y == 1/x mod 2^2\n\t  y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t  y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t  // last step - calculate inverse mod DV directly;\n\t  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t  y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t  // we really want the negative inverse, and -DV < y < DV\n\t  return (y > 0) ? this.DV - y : -y;\n\t}\n\t// Montgomery reduction\n\tfunction Montgomery(m)\n\t{\n\t  this.m = m;\n\t  this.mp = m.invDigit();\n\t  this.mpl = this.mp & 0x7fff;\n\t  this.mph = this.mp >> 15;\n\t  this.um = (1 << (m.DB - 15)) - 1;\n\t  this.mt2 = 2 * m.t;\n\t}\n\t// xR mod m\n\tfunction montConvert(x)\n\t{\n\t  var r = nbi();\n\t  x.abs().dlShiftTo(this.m.t, r);\n\t  r.divRemTo(this.m, null, r);\n\t  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t  return r;\n\t}\n\t// x/R mod m\n\tfunction montRevert(x)\n\t{\n\t  var r = nbi();\n\t  x.copyTo(r);\n\t  this.reduce(r);\n\t  return r;\n\t}\n\t// x = x/R mod m (HAC 14.32)\n\tfunction montReduce(x)\n\t{\n\t  while (x.t <= this.mt2) // pad x so am has enough room later\n\t    x[x.t++] = 0;\n\t  for (var i = 0; i < this.m.t; ++i)\n\t  {\n\t    // faster way of calculating u0 = x[i]*mp mod DV\n\t    var j = x[i] & 0x7fff;\n\t    var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t    // use am to combine the multiply-shift-add into one call\n\t    j = i + this.m.t;\n\t    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t    // propagate carry\n\t    while (x[j] >= x.DV)\n\t    {\n\t      x[j] -= x.DV;\n\t      x[++j]++;\n\t    }\n\t  }\n\t  x.clamp();\n\t  x.drShiftTo(this.m.t, x);\n\t  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t}\n\t// r = \"x^2/R mod m\"; x != r\n\tfunction montSqrTo(x, r)\n\t{\n\t  x.squareTo(r);\n\t  this.reduce(r);\n\t}\n\t// r = \"xy/R mod m\"; x,y != r\n\tfunction montMulTo(x, y, r)\n\t{\n\t  x.multiplyTo(y, r);\n\t  this.reduce(r);\n\t}\n\tMontgomery.prototype.convert = montConvert;\n\tMontgomery.prototype.revert = montRevert;\n\tMontgomery.prototype.reduce = montReduce;\n\tMontgomery.prototype.mulTo = montMulTo;\n\tMontgomery.prototype.sqrTo = montSqrTo;\n\t// (protected) true iff this is even\n\tfunction bnpIsEven()\n\t{\n\t  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t}\n\t// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\tfunction bnpExp(e, z)\n\t{\n\t  if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t  var r = nbi(),\n\t    r2 = nbi(),\n\t    g = z.convert(this),\n\t    i = nbits(e) - 1;\n\t  g.copyTo(r);\n\t  while (--i >= 0)\n\t  {\n\t    z.sqrTo(r, r2);\n\t    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t    else\n\t    {\n\t      var t = r;\n\t      r = r2;\n\t      r2 = t;\n\t    }\n\t  }\n\t  return z.revert(r);\n\t}\n\t// (public) this^e % m, 0 <= e < 2^32\n\tfunction bnModPowInt(e, m)\n\t{\n\t  var z;\n\t  if (e < 256 || m.isEven()) z = new Classic(m);\n\t  else z = new Montgomery(m);\n\t  return this.exp(e, z);\n\t}\n\t// protected\n\tBigInteger.prototype.copyTo = bnpCopyTo;\n\tBigInteger.prototype.fromInt = bnpFromInt;\n\tBigInteger.prototype.fromString = bnpFromString;\n\tBigInteger.prototype.clamp = bnpClamp;\n\tBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\tBigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\tBigInteger.prototype.lShiftTo = bnpLShiftTo;\n\tBigInteger.prototype.rShiftTo = bnpRShiftTo;\n\tBigInteger.prototype.subTo = bnpSubTo;\n\tBigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\tBigInteger.prototype.squareTo = bnpSquareTo;\n\tBigInteger.prototype.divRemTo = bnpDivRemTo;\n\tBigInteger.prototype.invDigit = bnpInvDigit;\n\tBigInteger.prototype.isEven = bnpIsEven;\n\tBigInteger.prototype.exp = bnpExp;\n\t// public\n\tBigInteger.prototype.toString = bnToString;\n\tBigInteger.prototype.negate = bnNegate;\n\tBigInteger.prototype.abs = bnAbs;\n\tBigInteger.prototype.compareTo = bnCompareTo;\n\tBigInteger.prototype.bitLength = bnBitLength;\n\tBigInteger.prototype.mod = bnMod;\n\tBigInteger.prototype.modPowInt = bnModPowInt;\n\t// \"constants\"\n\tBigInteger.ZERO = nbv(0);\n\tBigInteger.ONE = nbv(1);\n\t// Copyright (c) 2005-2009  Tom Wu\n\t// All Rights Reserved.\n\t// See \"LICENSE\" for details.\n\t// Extended JavaScript BN functions, required for RSA private ops.\n\t// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t// Version 1.2: square() API, isProbablePrime fix\n\t// (public)\n\tfunction bnClone()\n\t{\n\t  var r = nbi();\n\t  this.copyTo(r);\n\t  return r;\n\t}\n\t// (public) return value as integer\n\tfunction bnIntValue()\n\t{\n\t  if (this.s < 0)\n\t  {\n\t    if (this.t == 1) return this[0] - this.DV;\n\t    else if (this.t == 0) return -1;\n\t  }\n\t  else if (this.t == 1) return this[0];\n\t  else if (this.t == 0) return 0;\n\t  // assumes 16 < DB < 32\n\t  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t}\n\t// (public) return value as byte\n\tfunction bnByteValue()\n\t{\n\t  return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t}\n\t// (public) return value as short (assumes DB>=16)\n\tfunction bnShortValue()\n\t{\n\t  return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t}\n\t// (protected) return x s.t. r^x < DV\n\tfunction bnpChunkSize(r)\n\t{\n\t  return Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t}\n\t// (public) 0 if this == 0, 1 if this > 0\n\tfunction bnSigNum()\n\t{\n\t  if (this.s < 0) return -1;\n\t  else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t  else return 1;\n\t}\n\t// (protected) convert to radix string\n\tfunction bnpToRadix(b)\n\t{\n\t  if (b == null) b = 10;\n\t  if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t  var cs = this.chunkSize(b);\n\t  var a = Math.pow(b, cs);\n\t  var d = nbv(a),\n\t    y = nbi(),\n\t    z = nbi(),\n\t    r = \"\";\n\t  this.divRemTo(d, y, z);\n\t  while (y.signum() > 0)\n\t  {\n\t    r = (a + z.intValue()).toString(b).substr(1) + r;\n\t    y.divRemTo(d, y, z);\n\t  }\n\t  return z.intValue().toString(b) + r;\n\t}\n\t// (protected) convert from radix string\n\tfunction bnpFromRadix(s, b)\n\t{\n\t  this.fromInt(0);\n\t  if (b == null) b = 10;\n\t  var cs = this.chunkSize(b);\n\t  var d = Math.pow(b, cs),\n\t    mi = false,\n\t    j = 0,\n\t    w = 0;\n\t  for (var i = 0; i < s.length; ++i)\n\t  {\n\t    var x = intAt(s, i);\n\t    if (x < 0)\n\t    {\n\t      if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t      continue;\n\t    }\n\t    w = b * w + x;\n\t    if (++j >= cs)\n\t    {\n\t      this.dMultiply(d);\n\t      this.dAddOffset(w, 0);\n\t      j = 0;\n\t      w = 0;\n\t    }\n\t  }\n\t  if (j > 0)\n\t  {\n\t    this.dMultiply(Math.pow(b, j));\n\t    this.dAddOffset(w, 0);\n\t  }\n\t  if (mi) BigInteger.ZERO.subTo(this, this);\n\t}\n\t// (protected) alternate constructor\n\tfunction bnpFromNumber(a, b, c)\n\t{\n\t  if (\"number\" == typeof b)\n\t  {\n\t    // new BigInteger(int,int,RNG)\n\t    if (a < 2) this.fromInt(1);\n\t    else\n\t    {\n\t      this.fromNumber(a, c);\n\t      if (!this.testBit(a - 1)) // force MSB set\n\t        this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t      if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t      while (!this.isProbablePrime(b))\n\t      {\n\t        this.dAddOffset(2, 0);\n\t        if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t      }\n\t    }\n\t  }\n\t  else\n\t  {\n\t    // new BigInteger(int,RNG)\n\t    var x = new Array(),\n\t      t = a & 7;\n\t    x.length = (a >> 3) + 1;\n\t    b.nextBytes(x);\n\t    if (t > 0) x[0] &= ((1 << t) - 1);\n\t    else x[0] = 0;\n\t    this.fromString(x, 256);\n\t  }\n\t}\n\t// (public) convert to bigendian byte array\n\tfunction bnToByteArray()\n\t{\n\t  var i = this.t,\n\t    r = new Array();\n\t  r[0] = this.s;\n\t  var p = this.DB - (i * this.DB) % 8,\n\t    d, k = 0;\n\t  if (i-- > 0)\n\t  {\n\t    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t      r[k++] = d | (this.s << (this.DB - p));\n\t    while (i >= 0)\n\t    {\n\t      if (p < 8)\n\t      {\n\t        d = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t        d |= this[--i] >> (p += this.DB - 8);\n\t      }\n\t      else\n\t      {\n\t        d = (this[i] >> (p -= 8)) & 0xff;\n\t        if (p <= 0)\n\t        {\n\t          p += this.DB;\n\t          --i;\n\t        }\n\t      }\n\t      if ((d & 0x80) != 0) d |= -256;\n\t      if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n\t      if (k > 0 || d != this.s) r[k++] = d;\n\t    }\n\t  }\n\t  return r;\n\t}\n\t\n\tfunction bnEquals(a)\n\t{\n\t  return (this.compareTo(a) == 0);\n\t}\n\t\n\tfunction bnMin(a)\n\t{\n\t  return (this.compareTo(a) < 0) ? this : a;\n\t}\n\t\n\tfunction bnMax(a)\n\t{\n\t  return (this.compareTo(a) > 0) ? this : a;\n\t}\n\t// (protected) r = this op a (bitwise)\n\tfunction bnpBitwiseTo(a, op, r)\n\t{\n\t  var i, f, m = Math.min(a.t, this.t);\n\t  for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t  if (a.t < this.t)\n\t  {\n\t    f = a.s & this.DM;\n\t    for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t    r.t = this.t;\n\t  }\n\t  else\n\t  {\n\t    f = this.s & this.DM;\n\t    for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t    r.t = a.t;\n\t  }\n\t  r.s = op(this.s, a.s);\n\t  r.clamp();\n\t}\n\t// (public) this & a\n\tfunction op_and(x, y)\n\t{\n\t  return x & y;\n\t}\n\t\n\tfunction bnAnd(a)\n\t{\n\t  var r = nbi();\n\t  this.bitwiseTo(a, op_and, r);\n\t  return r;\n\t}\n\t// (public) this | a\n\tfunction op_or(x, y)\n\t{\n\t  return x | y;\n\t}\n\t\n\tfunction bnOr(a)\n\t{\n\t  var r = nbi();\n\t  this.bitwiseTo(a, op_or, r);\n\t  return r;\n\t}\n\t// (public) this ^ a\n\tfunction op_xor(x, y)\n\t{\n\t  return x ^ y;\n\t}\n\t\n\tfunction bnXor(a)\n\t{\n\t  var r = nbi();\n\t  this.bitwiseTo(a, op_xor, r);\n\t  return r;\n\t}\n\t// (public) this & ~a\n\tfunction op_andnot(x, y)\n\t{\n\t  return x & ~y;\n\t}\n\t\n\tfunction bnAndNot(a)\n\t{\n\t  var r = nbi();\n\t  this.bitwiseTo(a, op_andnot, r);\n\t  return r;\n\t}\n\t// (public) ~this\n\tfunction bnNot()\n\t{\n\t  var r = nbi();\n\t  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t  r.t = this.t;\n\t  r.s = ~this.s;\n\t  return r;\n\t}\n\t// (public) this << n\n\tfunction bnShiftLeft(n)\n\t{\n\t  var r = nbi();\n\t  if (n < 0) this.rShiftTo(-n, r);\n\t  else this.lShiftTo(n, r);\n\t  return r;\n\t}\n\t// (public) this >> n\n\tfunction bnShiftRight(n)\n\t{\n\t  var r = nbi();\n\t  if (n < 0) this.lShiftTo(-n, r);\n\t  else this.rShiftTo(n, r);\n\t  return r;\n\t}\n\t// return index of lowest 1-bit in x, x < 2^31\n\tfunction lbit(x)\n\t{\n\t  if (x == 0) return -1;\n\t  var r = 0;\n\t  if ((x & 0xffff) == 0)\n\t  {\n\t    x >>= 16;\n\t    r += 16;\n\t  }\n\t  if ((x & 0xff) == 0)\n\t  {\n\t    x >>= 8;\n\t    r += 8;\n\t  }\n\t  if ((x & 0xf) == 0)\n\t  {\n\t    x >>= 4;\n\t    r += 4;\n\t  }\n\t  if ((x & 3) == 0)\n\t  {\n\t    x >>= 2;\n\t    r += 2;\n\t  }\n\t  if ((x & 1) == 0)++r;\n\t  return r;\n\t}\n\t// (public) returns index of lowest 1-bit (or -1 if none)\n\tfunction bnGetLowestSetBit()\n\t{\n\t  for (var i = 0; i < this.t; ++i)\n\t    if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t  if (this.s < 0) return this.t * this.DB;\n\t  return -1;\n\t}\n\t// return number of 1 bits in x\n\tfunction cbit(x)\n\t{\n\t  var r = 0;\n\t  while (x != 0)\n\t  {\n\t    x &= x - 1;\n\t    ++r;\n\t  }\n\t  return r;\n\t}\n\t// (public) return number of set bits\n\tfunction bnBitCount()\n\t{\n\t  var r = 0,\n\t    x = this.s & this.DM;\n\t  for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t  return r;\n\t}\n\t// (public) true iff nth bit is set\n\tfunction bnTestBit(n)\n\t{\n\t  var j = Math.floor(n / this.DB);\n\t  if (j >= this.t) return (this.s != 0);\n\t  return ((this[j] & (1 << (n % this.DB))) != 0);\n\t}\n\t// (protected) this op (1<<n)\n\tfunction bnpChangeBit(n, op)\n\t{\n\t  var r = BigInteger.ONE.shiftLeft(n);\n\t  this.bitwiseTo(r, op, r);\n\t  return r;\n\t}\n\t// (public) this | (1<<n)\n\tfunction bnSetBit(n)\n\t{\n\t  return this.changeBit(n, op_or);\n\t}\n\t// (public) this & ~(1<<n)\n\tfunction bnClearBit(n)\n\t{\n\t  return this.changeBit(n, op_andnot);\n\t}\n\t// (public) this ^ (1<<n)\n\tfunction bnFlipBit(n)\n\t{\n\t  return this.changeBit(n, op_xor);\n\t}\n\t// (protected) r = this + a\n\tfunction bnpAddTo(a, r)\n\t{\n\t  var i = 0,\n\t    c = 0,\n\t    m = Math.min(a.t, this.t);\n\t  while (i < m)\n\t  {\n\t    c += this[i] + a[i];\n\t    r[i++] = c & this.DM;\n\t    c >>= this.DB;\n\t  }\n\t  if (a.t < this.t)\n\t  {\n\t    c += a.s;\n\t    while (i < this.t)\n\t    {\n\t      c += this[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    c += this.s;\n\t  }\n\t  else\n\t  {\n\t    c += this.s;\n\t    while (i < a.t)\n\t    {\n\t      c += a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    c += a.s;\n\t  }\n\t  r.s = (c < 0) ? -1 : 0;\n\t  if (c > 0) r[i++] = c;\n\t  else if (c < -1) r[i++] = this.DV + c;\n\t  r.t = i;\n\t  r.clamp();\n\t}\n\t// (public) this + a\n\tfunction bnAdd(a)\n\t{\n\t  var r = nbi();\n\t  this.addTo(a, r);\n\t  return r;\n\t}\n\t// (public) this - a\n\tfunction bnSubtract(a)\n\t{\n\t  var r = nbi();\n\t  this.subTo(a, r);\n\t  return r;\n\t}\n\t// (public) this * a\n\tfunction bnMultiply(a)\n\t{\n\t  var r = nbi();\n\t  this.multiplyTo(a, r);\n\t  return r;\n\t}\n\t// (public) this^2\n\tfunction bnSquare()\n\t{\n\t  var r = nbi();\n\t  this.squareTo(r);\n\t  return r;\n\t}\n\t// (public) this / a\n\tfunction bnDivide(a)\n\t{\n\t  var r = nbi();\n\t  this.divRemTo(a, r, null);\n\t  return r;\n\t}\n\t// (public) this % a\n\tfunction bnRemainder(a)\n\t{\n\t  var r = nbi();\n\t  this.divRemTo(a, null, r);\n\t  return r;\n\t}\n\t// (public) [this/a,this%a]\n\tfunction bnDivideAndRemainder(a)\n\t{\n\t  var q = nbi(),\n\t    r = nbi();\n\t  this.divRemTo(a, q, r);\n\t  return new Array(q, r);\n\t}\n\t// (protected) this *= n, this >= 0, 1 < n < DV\n\tfunction bnpDMultiply(n)\n\t{\n\t  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t  ++this.t;\n\t  this.clamp();\n\t}\n\t// (protected) this += n << w words, this >= 0\n\tfunction bnpDAddOffset(n, w)\n\t{\n\t  if (n == 0) return;\n\t  while (this.t <= w) this[this.t++] = 0;\n\t  this[w] += n;\n\t  while (this[w] >= this.DV)\n\t  {\n\t    this[w] -= this.DV;\n\t    if (++w >= this.t) this[this.t++] = 0;\n\t    ++this[w];\n\t  }\n\t}\n\t// A \"null\" reducer\n\tfunction NullExp()\n\t{}\n\t\n\tfunction nNop(x)\n\t{\n\t  return x;\n\t}\n\t\n\tfunction nMulTo(x, y, r)\n\t{\n\t  x.multiplyTo(y, r);\n\t}\n\t\n\tfunction nSqrTo(x, r)\n\t{\n\t  x.squareTo(r);\n\t}\n\tNullExp.prototype.convert = nNop;\n\tNullExp.prototype.revert = nNop;\n\tNullExp.prototype.mulTo = nMulTo;\n\tNullExp.prototype.sqrTo = nSqrTo;\n\t// (public) this^e\n\tfunction bnPow(e)\n\t{\n\t  return this.exp(e, new NullExp());\n\t}\n\t// (protected) r = lower n words of \"this * a\", a.t <= n\n\t// \"this\" should be the larger one if appropriate.\n\tfunction bnpMultiplyLowerTo(a, n, r)\n\t{\n\t  var i = Math.min(this.t + a.t, n);\n\t  r.s = 0; // assumes a,this >= 0\n\t  r.t = i;\n\t  while (i > 0) r[--i] = 0;\n\t  var j;\n\t  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t  r.clamp();\n\t}\n\t// (protected) r = \"this * a\" without lower n words, n > 0\n\t// \"this\" should be the larger one if appropriate.\n\tfunction bnpMultiplyUpperTo(a, n, r)\n\t{\n\t  --n;\n\t  var i = r.t = this.t + a.t - n;\n\t  r.s = 0; // assumes a,this >= 0\n\t  while (--i >= 0) r[i] = 0;\n\t  for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t  r.clamp();\n\t  r.drShiftTo(1, r);\n\t}\n\t// Barrett modular reduction\n\tfunction Barrett(m)\n\t{\n\t  // setup Barrett\n\t  this.r2 = nbi();\n\t  this.q3 = nbi();\n\t  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t  this.mu = this.r2.divide(m);\n\t  this.m = m;\n\t}\n\t\n\tfunction barrettConvert(x)\n\t{\n\t  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t  else if (x.compareTo(this.m) < 0) return x;\n\t  else\n\t  {\n\t    var r = nbi();\n\t    x.copyTo(r);\n\t    this.reduce(r);\n\t    return r;\n\t  }\n\t}\n\t\n\tfunction barrettRevert(x)\n\t{\n\t  return x;\n\t}\n\t// x = x mod m (HAC 14.42)\n\tfunction barrettReduce(x)\n\t{\n\t  x.drShiftTo(this.m.t - 1, this.r2);\n\t  if (x.t > this.m.t + 1)\n\t  {\n\t    x.t = this.m.t + 1;\n\t    x.clamp();\n\t  }\n\t  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t  while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t  x.subTo(this.r2, x);\n\t  while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t}\n\t// r = x^2 mod m; x != r\n\tfunction barrettSqrTo(x, r)\n\t{\n\t  x.squareTo(r);\n\t  this.reduce(r);\n\t}\n\t// r = x*y mod m; x,y != r\n\tfunction barrettMulTo(x, y, r)\n\t{\n\t  x.multiplyTo(y, r);\n\t  this.reduce(r);\n\t}\n\tBarrett.prototype.convert = barrettConvert;\n\tBarrett.prototype.revert = barrettRevert;\n\tBarrett.prototype.reduce = barrettReduce;\n\tBarrett.prototype.mulTo = barrettMulTo;\n\tBarrett.prototype.sqrTo = barrettSqrTo;\n\t// (public) this^e % m (HAC 14.85)\n\tfunction bnModPow(e, m)\n\t{\n\t  var i = e.bitLength(),\n\t    k, r = nbv(1),\n\t    z;\n\t  if (i <= 0) return r;\n\t  else if (i < 18) k = 1;\n\t  else if (i < 48) k = 3;\n\t  else if (i < 144) k = 4;\n\t  else if (i < 768) k = 5;\n\t  else k = 6;\n\t  if (i < 8)\n\t    z = new Classic(m);\n\t  else if (m.isEven())\n\t    z = new Barrett(m);\n\t  else\n\t    z = new Montgomery(m);\n\t  // precomputation\n\t  var g = new Array(),\n\t    n = 3,\n\t    k1 = k - 1,\n\t    km = (1 << k) - 1;\n\t  g[1] = z.convert(this);\n\t  if (k > 1)\n\t  {\n\t    var g2 = nbi();\n\t    z.sqrTo(g[1], g2);\n\t    while (n <= km)\n\t    {\n\t      g[n] = nbi();\n\t      z.mulTo(g2, g[n - 2], g[n]);\n\t      n += 2;\n\t    }\n\t  }\n\t  var j = e.t - 1,\n\t    w, is1 = true,\n\t    r2 = nbi(),\n\t    t;\n\t  i = nbits(e[j]) - 1;\n\t  while (j >= 0)\n\t  {\n\t    if (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t    else\n\t    {\n\t      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t    }\n\t    n = k;\n\t    while ((w & 1) == 0)\n\t    {\n\t      w >>= 1;\n\t      --n;\n\t    }\n\t    if ((i -= n) < 0)\n\t    {\n\t      i += this.DB;\n\t      --j;\n\t    }\n\t    if (is1)\n\t    { // ret == 1, don't bother squaring or multiplying it\n\t      g[w].copyTo(r);\n\t      is1 = false;\n\t    }\n\t    else\n\t    {\n\t      while (n > 1)\n\t      {\n\t        z.sqrTo(r, r2);\n\t        z.sqrTo(r2, r);\n\t        n -= 2;\n\t      }\n\t      if (n > 0) z.sqrTo(r, r2);\n\t      else\n\t      {\n\t        t = r;\n\t        r = r2;\n\t        r2 = t;\n\t      }\n\t      z.mulTo(r2, g[w], r);\n\t    }\n\t    while (j >= 0 && (e[j] & (1 << i)) == 0)\n\t    {\n\t      z.sqrTo(r, r2);\n\t      t = r;\n\t      r = r2;\n\t      r2 = t;\n\t      if (--i < 0)\n\t      {\n\t        i = this.DB - 1;\n\t        --j;\n\t      }\n\t    }\n\t  }\n\t  return z.revert(r);\n\t}\n\t// (public) gcd(this,a) (HAC 14.54)\n\tfunction bnGCD(a)\n\t{\n\t  var x = (this.s < 0) ? this.negate() : this.clone();\n\t  var y = (a.s < 0) ? a.negate() : a.clone();\n\t  if (x.compareTo(y) < 0)\n\t  {\n\t    var t = x;\n\t    x = y;\n\t    y = t;\n\t  }\n\t  var i = x.getLowestSetBit(),\n\t    g = y.getLowestSetBit();\n\t  if (g < 0) return x;\n\t  if (i < g) g = i;\n\t  if (g > 0)\n\t  {\n\t    x.rShiftTo(g, x);\n\t    y.rShiftTo(g, y);\n\t  }\n\t  while (x.signum() > 0)\n\t  {\n\t    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t    if (x.compareTo(y) >= 0)\n\t    {\n\t      x.subTo(y, x);\n\t      x.rShiftTo(1, x);\n\t    }\n\t    else\n\t    {\n\t      y.subTo(x, y);\n\t      y.rShiftTo(1, y);\n\t    }\n\t  }\n\t  if (g > 0) y.lShiftTo(g, y);\n\t  return y;\n\t}\n\t// (protected) this % n, n < 2^26\n\tfunction bnpModInt(n)\n\t{\n\t  if (n <= 0) return 0;\n\t  var d = this.DV % n,\n\t    r = (this.s < 0) ? n - 1 : 0;\n\t  if (this.t > 0)\n\t    if (d == 0) r = this[0] % n;\n\t    else\n\t      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t  return r;\n\t}\n\t// (public) 1/this % m (HAC 14.61)\n\tfunction bnModInverse(m)\n\t{\n\t  var ac = m.isEven();\n\t  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t  var u = m.clone(),\n\t    v = this.clone();\n\t  var a = nbv(1),\n\t    b = nbv(0),\n\t    c = nbv(0),\n\t    d = nbv(1);\n\t  while (u.signum() != 0)\n\t  {\n\t    while (u.isEven())\n\t    {\n\t      u.rShiftTo(1, u);\n\t      if (ac)\n\t      {\n\t        if (!a.isEven() || !b.isEven())\n\t        {\n\t          a.addTo(this, a);\n\t          b.subTo(m, b);\n\t        }\n\t        a.rShiftTo(1, a);\n\t      }\n\t      else if (!b.isEven()) b.subTo(m, b);\n\t      b.rShiftTo(1, b);\n\t    }\n\t    while (v.isEven())\n\t    {\n\t      v.rShiftTo(1, v);\n\t      if (ac)\n\t      {\n\t        if (!c.isEven() || !d.isEven())\n\t        {\n\t          c.addTo(this, c);\n\t          d.subTo(m, d);\n\t        }\n\t        c.rShiftTo(1, c);\n\t      }\n\t      else if (!d.isEven()) d.subTo(m, d);\n\t      d.rShiftTo(1, d);\n\t    }\n\t    if (u.compareTo(v) >= 0)\n\t    {\n\t      u.subTo(v, u);\n\t      if (ac) a.subTo(c, a);\n\t      b.subTo(d, b);\n\t    }\n\t    else\n\t    {\n\t      v.subTo(u, v);\n\t      if (ac) c.subTo(a, c);\n\t      d.subTo(b, d);\n\t    }\n\t  }\n\t  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t  if (d.compareTo(m) >= 0) return d.subtract(m);\n\t  if (d.signum() < 0) d.addTo(m, d);\n\t  else return d;\n\t  if (d.signum() < 0) return d.add(m);\n\t  else return d;\n\t}\n\tvar lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\tvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t// (public) test primality with certainty >= 1-.5^t\n\tfunction bnIsProbablePrime(t)\n\t{\n\t  var i, x = this.abs();\n\t  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t  {\n\t    for (i = 0; i < lowprimes.length; ++i)\n\t      if (x[0] == lowprimes[i]) return true;\n\t    return false;\n\t  }\n\t  if (x.isEven()) return false;\n\t  i = 1;\n\t  while (i < lowprimes.length)\n\t  {\n\t    var m = lowprimes[i],\n\t      j = i + 1;\n\t    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t    m = x.modInt(m);\n\t    while (i < j)\n\t      if (m % lowprimes[i++] == 0) return false;\n\t  }\n\t  return x.millerRabin(t);\n\t}\n\t// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\tfunction bnpMillerRabin(t)\n\t{\n\t  var n1 = this.subtract(BigInteger.ONE);\n\t  var k = n1.getLowestSetBit();\n\t  if (k <= 0) return false;\n\t  var r = n1.shiftRight(k);\n\t  t = (t + 1) >> 1;\n\t  if (t > lowprimes.length) t = lowprimes.length;\n\t  var a = nbi();\n\t  for (var i = 0; i < t; ++i)\n\t  {\n\t    //Pick bases at random, instead of starting at 2\n\t    a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t    var y = a.modPow(r, this);\n\t    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t    {\n\t      var j = 1;\n\t      while (j++ < k && y.compareTo(n1) != 0)\n\t      {\n\t        y = y.modPowInt(2, this);\n\t        if (y.compareTo(BigInteger.ONE) == 0) return false;\n\t      }\n\t      if (y.compareTo(n1) != 0) return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t// protected\n\tBigInteger.prototype.chunkSize = bnpChunkSize;\n\tBigInteger.prototype.toRadix = bnpToRadix;\n\tBigInteger.prototype.fromRadix = bnpFromRadix;\n\tBigInteger.prototype.fromNumber = bnpFromNumber;\n\tBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\tBigInteger.prototype.changeBit = bnpChangeBit;\n\tBigInteger.prototype.addTo = bnpAddTo;\n\tBigInteger.prototype.dMultiply = bnpDMultiply;\n\tBigInteger.prototype.dAddOffset = bnpDAddOffset;\n\tBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\tBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\tBigInteger.prototype.modInt = bnpModInt;\n\tBigInteger.prototype.millerRabin = bnpMillerRabin;\n\t// public\n\tBigInteger.prototype.clone = bnClone;\n\tBigInteger.prototype.intValue = bnIntValue;\n\tBigInteger.prototype.byteValue = bnByteValue;\n\tBigInteger.prototype.shortValue = bnShortValue;\n\tBigInteger.prototype.signum = bnSigNum;\n\tBigInteger.prototype.toByteArray = bnToByteArray;\n\tBigInteger.prototype.equals = bnEquals;\n\tBigInteger.prototype.min = bnMin;\n\tBigInteger.prototype.max = bnMax;\n\tBigInteger.prototype.and = bnAnd;\n\tBigInteger.prototype.or = bnOr;\n\tBigInteger.prototype.xor = bnXor;\n\tBigInteger.prototype.andNot = bnAndNot;\n\tBigInteger.prototype.not = bnNot;\n\tBigInteger.prototype.shiftLeft = bnShiftLeft;\n\tBigInteger.prototype.shiftRight = bnShiftRight;\n\tBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\tBigInteger.prototype.bitCount = bnBitCount;\n\tBigInteger.prototype.testBit = bnTestBit;\n\tBigInteger.prototype.setBit = bnSetBit;\n\tBigInteger.prototype.clearBit = bnClearBit;\n\tBigInteger.prototype.flipBit = bnFlipBit;\n\tBigInteger.prototype.add = bnAdd;\n\tBigInteger.prototype.subtract = bnSubtract;\n\tBigInteger.prototype.multiply = bnMultiply;\n\tBigInteger.prototype.divide = bnDivide;\n\tBigInteger.prototype.remainder = bnRemainder;\n\tBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\tBigInteger.prototype.modPow = bnModPow;\n\tBigInteger.prototype.modInverse = bnModInverse;\n\tBigInteger.prototype.pow = bnPow;\n\tBigInteger.prototype.gcd = bnGCD;\n\tBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t// JSBN-specific extension\n\tBigInteger.prototype.square = bnSquare;\n\tvar Int128 = BigInteger;\n\t// BigInteger interfaces not implemented in jsbn:\n\t// BigInteger(int signum, byte[] magnitude)\n\t// double doubleValue()\n\t// float floatValue()\n\t// int hashCode()\n\t// long longValue()\n\t// static BigInteger valueOf(long val)\n\t// Helper functions to make BigInteger functions callable with two parameters\n\t// as in original C# Clipper\n\tInt128.prototype.IsNegative = function ()\n\t{\n\t  if (this.compareTo(Int128.ZERO) == -1) return true;\n\t  else return false;\n\t};\n\tInt128.op_Equality = function (val1, val2)\n\t{\n\t  if (val1.compareTo(val2) == 0) return true;\n\t  else return false;\n\t};\n\tInt128.op_Inequality = function (val1, val2)\n\t{\n\t  if (val1.compareTo(val2) != 0) return true;\n\t  else return false;\n\t};\n\tInt128.op_GreaterThan = function (val1, val2)\n\t{\n\t  if (val1.compareTo(val2) > 0) return true;\n\t  else return false;\n\t};\n\tInt128.op_LessThan = function (val1, val2)\n\t{\n\t  if (val1.compareTo(val2) < 0) return true;\n\t  else return false;\n\t};\n\tInt128.op_Addition = function (lhs, rhs)\n\t{\n\t  return new Int128(lhs).add(new Int128(rhs));\n\t};\n\tInt128.op_Subtraction = function (lhs, rhs)\n\t{\n\t  return new Int128(lhs).subtract(new Int128(rhs));\n\t};\n\tInt128.Int128Mul = function (lhs, rhs)\n\t{\n\t  return new Int128(lhs).multiply(new Int128(rhs));\n\t};\n\tInt128.op_Division = function (lhs, rhs)\n\t{\n\t  return lhs.divide(rhs);\n\t};\n\tInt128.prototype.ToDouble = function ()\n\t{\n\t  return parseFloat(this.toString()); // This could be something faster\n\t};\n\t// end of Int128 section\n\t/*\n\t// Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\tif (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\telse self.Int128 = Int128;\n\t*/\n\t// ---------------------------------------------  \n\t// Here starts the actual Clipper library:\n\t// Helper function to support Inheritance in Javascript\n\tif (typeof (Inherit) == 'undefined')\n\t{\n\t  var Inherit = function (ce, ce2)\n\t  {\n\t    var p;\n\t    if (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t    {\n\t      for (p in ce2.prototype)\n\t        if (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t      for (p in ce2)\n\t        if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t      ce.$baseCtor = ce2;\n\t    }\n\t    else\n\t    {\n\t      var props = Object.getOwnPropertyNames(ce2.prototype);\n\t      for (var i = 0; i < props.length; i++)\n\t        if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t      for (p in ce2)\n\t        if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t      ce.$baseCtor = ce2;\n\t    }\n\t  };\n\t}\n\tClipperLib.Path = function ()\n\t{\n\t  return [];\n\t};\n\tClipperLib.Paths = function ()\n\t{\n\t  return []; // Was previously [[]], but caused problems when pushed\n\t};\n\t// Preserves the calling way of original C# Clipper\n\t// Is essential due to compatibility, because DoublePoint is public class in original C# version\n\tClipperLib.DoublePoint = function ()\n\t{\n\t  var a = arguments;\n\t  this.X = 0;\n\t  this.Y = 0;\n\t  // public DoublePoint(DoublePoint dp)\n\t  // public DoublePoint(IntPoint ip)\n\t  if (a.length == 1)\n\t  {\n\t    this.X = a[0].X;\n\t    this.Y = a[0].Y;\n\t  }\n\t  else if (a.length == 2)\n\t  {\n\t    this.X = a[0];\n\t    this.Y = a[1];\n\t  }\n\t}; // This is internal faster function when called without arguments\n\tClipperLib.DoublePoint0 = function ()\n\t{\n\t  this.X = 0;\n\t  this.Y = 0;\n\t};\n\t// This is internal faster function when called with 1 argument (dp or ip)\n\tClipperLib.DoublePoint1 = function (dp)\n\t{\n\t  this.X = dp.X;\n\t  this.Y = dp.Y;\n\t};\n\t// This is internal faster function when called with 2 arguments (x and y)\n\tClipperLib.DoublePoint2 = function (x, y)\n\t{\n\t  this.X = x;\n\t  this.Y = y;\n\t};\n\t// PolyTree & PolyNode start\n\t// -------------------------------\n\tClipperLib.PolyNode = function ()\n\t{\n\t  this.m_Parent = null;\n\t  this.m_polygon = new ClipperLib.Path();\n\t  this.m_Index = 0;\n\t  this.m_jointype = 0;\n\t  this.m_endtype = 0;\n\t  this.m_Childs = [];\n\t  this.IsOpen = false;\n\t};\n\tClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t{\n\t  var result = true;\n\t  var node = this.m_Parent;\n\t  while (node !== null)\n\t  {\n\t    result = !result;\n\t    node = node.m_Parent;\n\t  }\n\t  return result;\n\t};\n\tClipperLib.PolyNode.prototype.ChildCount = function ()\n\t{\n\t  return this.m_Childs.length;\n\t};\n\tClipperLib.PolyNode.prototype.Contour = function ()\n\t{\n\t  return this.m_polygon;\n\t};\n\tClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t{\n\t  var cnt = this.m_Childs.length;\n\t  this.m_Childs.push(Child);\n\t  Child.m_Parent = this;\n\t  Child.m_Index = cnt;\n\t};\n\tClipperLib.PolyNode.prototype.GetNext = function ()\n\t{\n\t  if (this.m_Childs.length > 0)\n\t    return this.m_Childs[0];\n\t  else\n\t    return this.GetNextSiblingUp();\n\t};\n\tClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t{\n\t  if (this.m_Parent === null)\n\t    return null;\n\t  else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n\t    return this.m_Parent.GetNextSiblingUp();\n\t  else\n\t    return this.m_Parent.m_Childs[this.m_Index + 1];\n\t};\n\tClipperLib.PolyNode.prototype.Childs = function ()\n\t{\n\t  return this.m_Childs;\n\t};\n\tClipperLib.PolyNode.prototype.Parent = function ()\n\t{\n\t  return this.m_Parent;\n\t};\n\tClipperLib.PolyNode.prototype.IsHole = function ()\n\t{\n\t  return this.IsHoleNode();\n\t};\n\t// PolyTree : PolyNode\n\tClipperLib.PolyTree = function ()\n\t{\n\t  this.m_AllPolys = [];\n\t  ClipperLib.PolyNode.call(this);\n\t};\n\tClipperLib.PolyTree.prototype.Clear = function ()\n\t{\n\t  for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t    this.m_AllPolys[i] = null;\n\t  this.m_AllPolys.length = 0;\n\t  this.m_Childs.length = 0;\n\t};\n\tClipperLib.PolyTree.prototype.GetFirst = function ()\n\t{\n\t  if (this.m_Childs.length > 0)\n\t    return this.m_Childs[0];\n\t  else\n\t    return null;\n\t};\n\tClipperLib.PolyTree.prototype.Total = function ()\n\t{\n\t  return this.m_AllPolys.length;\n\t};\n\tInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\t// -------------------------------\n\t// PolyTree & PolyNode end\n\tClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t{\n\t  return Math.abs(a);\n\t};\n\tClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t{\n\t  return Math.max(a, b);\n\t};\n\t/*\n\t-----------------------------------\n\tcast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t-----------------------------------\n\t*/\n\tif (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t{\n\t  return a | 0;\n\t};\n\telse ClipperLib.Cast_Int32 = function (a)\n\t{ // eg. browser.chrome || browser.chromium || browser.firefox\n\t  return~~ a;\n\t};\n\t/*\n\t--------------------------\n\tcast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\tChrome: bitwise_not_floor\n\tFirefox17: toInteger (typeof test)\n\tIE9: bitwise_or_floor\n\tIE7 and IE8: to_parseint\n\tChromium: to_floor_or_ceil\n\tFirefox3: to_floor_or_ceil\n\tFirefox15: to_floor_or_ceil\n\tOpera: to_floor_or_ceil\n\tSafari: to_floor_or_ceil\n\t--------------------------\n\t*/\n\tif (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t{\n\t  if (a < -2147483648 || a > 2147483647)\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  else return~~ a;\n\t};\n\telse if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n\t{\n\t  return Number.toInteger(a);\n\t};\n\telse if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t{\n\t  return parseInt(a, 10);\n\t};\n\telse if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t{\n\t  if (a < -2147483648 || a > 2147483647)\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  return a | 0;\n\t};\n\t// eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\telse ClipperLib.Cast_Int64 = function (a)\n\t{\n\t  return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t};\n\tClipperLib.Clear = function (a)\n\t{\n\t  a.length = 0;\n\t};\n\t//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\tClipperLib.PI = 3.141592653589793;\n\tClipperLib.PI2 = 2 * 3.141592653589793;\n\tClipperLib.IntPoint = function ()\n\t{\n\t  var a = arguments,\n\t    alen = a.length;\n\t  this.X = 0;\n\t  this.Y = 0;\n\t  if (use_xyz)\n\t  {\n\t    this.Z = 0;\n\t    if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t      this.Z = a[2];\n\t    }\n\t    else if (alen == 2) // public IntPoint(cInt x, cInt y)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t      this.Z = 0;\n\t    }\n\t    else if (alen == 1)\n\t    {\n\t      if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t      {\n\t        var dp = a[0];\n\t        this.X = ClipperLib.Clipper.Round(dp.X);\n\t        this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t        this.Z = 0;\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        var pt = a[0];\n\t        if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n\t        this.X = pt.X;\n\t        this.Y = pt.Y;\n\t        this.Z = pt.Z;\n\t      }\n\t    }\n\t    else // public IntPoint()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t      this.Z = 0;\n\t    }\n\t  }\n\t  else // if (!use_xyz)\n\t  {\n\t    if (alen == 2) // public IntPoint(cInt X, cInt Y)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t    }\n\t    else if (alen == 1)\n\t    {\n\t      if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t      {\n\t        var dp = a[0];\n\t        this.X = ClipperLib.Clipper.Round(dp.X);\n\t        this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        var pt = a[0];\n\t        this.X = pt.X;\n\t        this.Y = pt.Y;\n\t      }\n\t    }\n\t    else // public IntPoint(IntPoint pt)\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t    }\n\t  }\n\t};\n\tClipperLib.IntPoint.op_Equality = function (a, b)\n\t{\n\t  //return a == b;\n\t  return a.X == b.X && a.Y == b.Y;\n\t};\n\tClipperLib.IntPoint.op_Inequality = function (a, b)\n\t{\n\t  //return a != b;\n\t  return a.X != b.X || a.Y != b.Y;\n\t};\n\t/*\n\tClipperLib.IntPoint.prototype.Equals = function (obj)\n\t{\n\t  if (obj === null)\n\t      return false;\n\t  if (obj instanceof ClipperLib.IntPoint)\n\t  {\n\t      var a = Cast(obj, ClipperLib.IntPoint);\n\t      return (this.X == a.X) && (this.Y == a.Y);\n\t  }\n\t  else\n\t      return false;\n\t};\n\t*/\n\tif (use_xyz)\n\t{\n\t  ClipperLib.IntPoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    this.Z = 0;\n\t  };\n\t  ClipperLib.IntPoint1 = function (pt)\n\t  {\n\t    this.X = pt.X;\n\t    this.Y = pt.Y;\n\t    this.Z = pt.Z;\n\t  };\n\t  ClipperLib.IntPoint1dp = function (dp)\n\t  {\n\t    this.X = ClipperLib.Clipper.Round(dp.X);\n\t    this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t    this.Z = 0;\n\t  };\n\t  ClipperLib.IntPoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t    this.Z = 0;\n\t  };\n\t  ClipperLib.IntPoint3 = function (x, y, z)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t    this.Z = z;\n\t  };\n\t}\n\telse // if (!use_xyz)\n\t{\n\t  ClipperLib.IntPoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t  };\n\t  ClipperLib.IntPoint1 = function (pt)\n\t  {\n\t    this.X = pt.X;\n\t    this.Y = pt.Y;\n\t  };\n\t  ClipperLib.IntPoint1dp = function (dp)\n\t  {\n\t    this.X = ClipperLib.Clipper.Round(dp.X);\n\t    this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t  };\n\t  ClipperLib.IntPoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t  };\n\t}\n\tClipperLib.IntRect = function ()\n\t{\n\t  var a = arguments,\n\t    alen = a.length;\n\t  if (alen == 4) // function (l, t, r, b)\n\t  {\n\t    this.left = a[0];\n\t    this.top = a[1];\n\t    this.right = a[2];\n\t    this.bottom = a[3];\n\t  }\n\t  else if (alen == 1) // function (ir)\n\t  {\n\t    this.left = ir.left;\n\t    this.top = ir.top;\n\t    this.right = ir.right;\n\t    this.bottom = ir.bottom;\n\t  }\n\t  else // function ()\n\t  {\n\t    this.left = 0;\n\t    this.top = 0;\n\t    this.right = 0;\n\t    this.bottom = 0;\n\t  }\n\t};\n\tClipperLib.IntRect0 = function ()\n\t{\n\t  this.left = 0;\n\t  this.top = 0;\n\t  this.right = 0;\n\t  this.bottom = 0;\n\t};\n\tClipperLib.IntRect1 = function (ir)\n\t{\n\t  this.left = ir.left;\n\t  this.top = ir.top;\n\t  this.right = ir.right;\n\t  this.bottom = ir.bottom;\n\t};\n\tClipperLib.IntRect4 = function (l, t, r, b)\n\t{\n\t  this.left = l;\n\t  this.top = t;\n\t  this.right = r;\n\t  this.bottom = b;\n\t};\n\tClipperLib.ClipType = {\n\t  ctIntersection: 0,\n\t  ctUnion: 1,\n\t  ctDifference: 2,\n\t  ctXor: 3\n\t};\n\tClipperLib.PolyType = {\n\t  ptSubject: 0,\n\t  ptClip: 1\n\t};\n\tClipperLib.PolyFillType = {\n\t  pftEvenOdd: 0,\n\t  pftNonZero: 1,\n\t  pftPositive: 2,\n\t  pftNegative: 3\n\t};\n\tClipperLib.JoinType = {\n\t  jtSquare: 0,\n\t  jtRound: 1,\n\t  jtMiter: 2\n\t};\n\tClipperLib.EndType = {\n\t  etOpenSquare: 0,\n\t  etOpenRound: 1,\n\t  etOpenButt: 2,\n\t  etClosedLine: 3,\n\t  etClosedPolygon: 4\n\t};\n\tif (use_deprecated)\n\t  ClipperLib.EndType_ = {\n\t    etSquare: 0,\n\t    etRound: 1,\n\t    etButt: 2,\n\t    etClosed: 3\n\t  };\n\tClipperLib.EdgeSide = {\n\t  esLeft: 0,\n\t  esRight: 1\n\t};\n\tClipperLib.Direction = {\n\t  dRightToLeft: 0,\n\t  dLeftToRight: 1\n\t};\n\tClipperLib.TEdge = function ()\n\t{\n\t  this.Bot = new ClipperLib.IntPoint();\n\t  this.Curr = new ClipperLib.IntPoint();\n\t  this.Top = new ClipperLib.IntPoint();\n\t  this.Delta = new ClipperLib.IntPoint();\n\t  this.Dx = 0;\n\t  this.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t  this.Side = ClipperLib.EdgeSide.esLeft;\n\t  this.WindDelta = 0;\n\t  this.WindCnt = 0;\n\t  this.WindCnt2 = 0;\n\t  this.OutIdx = 0;\n\t  this.Next = null;\n\t  this.Prev = null;\n\t  this.NextInLML = null;\n\t  this.NextInAEL = null;\n\t  this.PrevInAEL = null;\n\t  this.NextInSEL = null;\n\t  this.PrevInSEL = null;\n\t};\n\tClipperLib.IntersectNode = function ()\n\t{\n\t  this.Edge1 = null;\n\t  this.Edge2 = null;\n\t  this.Pt = new ClipperLib.IntPoint();\n\t};\n\tClipperLib.MyIntersectNodeSort = function () {};\n\tClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t{\n\t  return (node2.Pt.Y - node1.Pt.Y);\n\t};\n\tClipperLib.LocalMinima = function ()\n\t{\n\t  this.Y = 0;\n\t  this.LeftBound = null;\n\t  this.RightBound = null;\n\t  this.Next = null;\n\t};\n\tClipperLib.Scanbeam = function ()\n\t{\n\t  this.Y = 0;\n\t  this.Next = null;\n\t};\n\tClipperLib.OutRec = function ()\n\t{\n\t  this.Idx = 0;\n\t  this.IsHole = false;\n\t  this.IsOpen = false;\n\t  this.FirstLeft = null;\n\t  this.Pts = null;\n\t  this.BottomPt = null;\n\t  this.PolyNode = null;\n\t};\n\tClipperLib.OutPt = function ()\n\t{\n\t  this.Idx = 0;\n\t  this.Pt = new ClipperLib.IntPoint();\n\t  this.Next = null;\n\t  this.Prev = null;\n\t};\n\tClipperLib.Join = function ()\n\t{\n\t  this.OutPt1 = null;\n\t  this.OutPt2 = null;\n\t  this.OffPt = new ClipperLib.IntPoint();\n\t};\n\tClipperLib.ClipperBase = function ()\n\t{\n\t  this.m_MinimaList = null;\n\t  this.m_CurrentLM = null;\n\t  this.m_edges = new Array();\n\t  this.m_UseFullRange = false;\n\t  this.m_HasOpenPaths = false;\n\t  this.PreserveCollinear = false;\n\t  this.m_MinimaList = null;\n\t  this.m_CurrentLM = null;\n\t  this.m_UseFullRange = false;\n\t  this.m_HasOpenPaths = false;\n\t};\n\t// Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t// protected const double horizontal = -3.4E+38;\n\t// internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t// internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t// So had to adjust them to more suitable for Javascript.\n\t// If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t// and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\tClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\tClipperLib.ClipperBase.Skip = -2;\n\tClipperLib.ClipperBase.Unassigned = -1;\n\tClipperLib.ClipperBase.tolerance = 1E-20;\n\tif (use_int32)\n\t{\n\t  ClipperLib.ClipperBase.loRange = 46340;\n\t  ClipperLib.ClipperBase.hiRange = 46340;\n\t}\n\telse\n\t{\n\t  ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\t  ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\t}\n\tClipperLib.ClipperBase.near_zero = function (val)\n\t{\n\t  return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t};\n\tClipperLib.ClipperBase.IsHorizontal = function (e)\n\t{\n\t  return e.Delta.Y === 0;\n\t};\n\tClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t{\n\t  var pp2 = pp;\n\t  do {\n\t    if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t      return true;\n\t    pp2 = pp2.Next;\n\t  }\n\t  while (pp2 != pp)\n\t  return false;\n\t};\n\tClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t{\n\t  if (UseFullRange)\n\t    return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n\t      ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n\t      (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n\t      ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n\t      (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t        Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t  else\n\t    return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t};\n\tClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t{\n\t  var pp2 = pp;\n\t  while (true)\n\t  {\n\t    if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t      return true;\n\t    pp2 = pp2.Next;\n\t    if (pp2 == pp)\n\t      break;\n\t  }\n\t  return false;\n\t};\n\tClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t{\n\t  var a = arguments,\n\t    alen = a.length;\n\t  var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t  if (alen == 3) // function (e1, e2, UseFullRange)\n\t  {\n\t    e1 = a[0];\n\t    e2 = a[1];\n\t    UseFullRange = a[2];\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t  }\n\t  else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n\t  {\n\t    pt1 = a[0];\n\t    pt2 = a[1];\n\t    pt3 = a[2];\n\t    UseFullRange = a[3];\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t  }\n\t  else // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t  {\n\t    pt1 = a[0];\n\t    pt2 = a[1];\n\t    pt3 = a[2];\n\t    pt4 = a[3];\n\t    UseFullRange = a[4];\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t  }\n\t};\n\tClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t{\n\t  if (UseFullRange)\n\t    return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t  else\n\t    return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t};\n\tClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t{\n\t  if (UseFullRange)\n\t    return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t  else\n\t    return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t};\n\tClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t{\n\t  if (UseFullRange)\n\t    return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t  else\n\t    return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t};\n\tClipperLib.ClipperBase.prototype.Clear = function ()\n\t{\n\t  this.DisposeLocalMinimaList();\n\t  for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t  {\n\t    for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t      this.m_edges[i][j] = null;\n\t    ClipperLib.Clear(this.m_edges[i]);\n\t  }\n\t  ClipperLib.Clear(this.m_edges);\n\t  this.m_UseFullRange = false;\n\t  this.m_HasOpenPaths = false;\n\t};\n\tClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t{\n\t  while (this.m_MinimaList !== null)\n\t  {\n\t    var tmpLm = this.m_MinimaList.Next;\n\t    this.m_MinimaList = null;\n\t    this.m_MinimaList = tmpLm;\n\t  }\n\t  this.m_CurrentLM = null;\n\t};\n\tClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t{\n\t  if (useFullRange.Value)\n\t  {\n\t    if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t      ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t  }\n\t  else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t  {\n\t    useFullRange.Value = true;\n\t    this.RangeTest(Pt, useFullRange);\n\t  }\n\t};\n\tClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t{\n\t  e.Next = eNext;\n\t  e.Prev = ePrev;\n\t  //e.Curr = pt;\n\t  e.Curr.X = pt.X;\n\t  e.Curr.Y = pt.Y;\n\t  e.OutIdx = -1;\n\t};\n\tClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t{\n\t  if (e.Curr.Y >= e.Next.Curr.Y)\n\t  {\n\t    //e.Bot = e.Curr;\n\t    e.Bot.X = e.Curr.X;\n\t    e.Bot.Y = e.Curr.Y;\n\t    //e.Top = e.Next.Curr;\n\t    e.Top.X = e.Next.Curr.X;\n\t    e.Top.Y = e.Next.Curr.Y;\n\t  }\n\t  else\n\t  {\n\t    //e.Top = e.Curr;\n\t    e.Top.X = e.Curr.X;\n\t    e.Top.Y = e.Curr.Y;\n\t    //e.Bot = e.Next.Curr;\n\t    e.Bot.X = e.Next.Curr.X;\n\t    e.Bot.Y = e.Next.Curr.Y;\n\t  }\n\t  this.SetDx(e);\n\t  e.PolyTyp = polyType;\n\t};\n\tClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t{\n\t  var E2;\n\t  for (;;)\n\t  {\n\t    while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t      E = E.Next;\n\t    if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n\t      break;\n\t    while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t      E = E.Prev;\n\t    E2 = E;\n\t    while (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t      E = E.Next;\n\t    if (E.Top.Y == E.Prev.Bot.Y)\n\t      continue;\n\t    //ie just an intermediate horz.\n\t    if (E2.Prev.Bot.X < E.Bot.X)\n\t      E = E2;\n\t    break;\n\t  }\n\t  return E;\n\t};\n\tClipperLib.ClipperBase.prototype.ProcessBound = function (E, IsClockwise)\n\t{\n\t  var EStart = E,\n\t    Result = E;\n\t  var Horz;\n\t  var StartX;\n\t  if (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t  {\n\t    //it's possible for adjacent overlapping horz edges to start heading left\n\t    //before finishing right, so ...\n\t    if (IsClockwise)\n\t      StartX = E.Prev.Bot.X;\n\t    else\n\t      StartX = E.Next.Bot.X;\n\t    if (E.Bot.X != StartX)\n\t      this.ReverseHorizontal(E);\n\t  }\n\t  if (Result.OutIdx != ClipperLib.ClipperBase.Skip)\n\t  {\n\t    if (IsClockwise)\n\t    {\n\t      while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        Result = Result.Next;\n\t      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        //nb: at the top of a bound, horizontals are added to the bound\n\t        //only when the preceding edge attaches to the horizontal's left vertex\n\t        //unless a Skip edge is encountered when that becomes the top divide\n\t        Horz = Result;\n\t        while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t          Horz = Horz.Prev;\n\t        if (Horz.Prev.Top.X == Result.Next.Top.X)\n\t        {\n\t          if (!IsClockwise)\n\t            Result = Horz.Prev;\n\t        }\n\t        else if (Horz.Prev.Top.X > Result.Next.Top.X)\n\t          Result = Horz.Prev;\n\t      }\n\t      while (E != Result)\n\t      {\n\t        E.NextInLML = E.Next;\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Next;\n\t      }\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t        this.ReverseHorizontal(E);\n\t      Result = Result.Next;\n\t      //move to the edge just beyond current bound\n\t    }\n\t    else\n\t    {\n\t      while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        Result = Result.Prev;\n\t      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        Horz = Result;\n\t        while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n\t          Horz = Horz.Next;\n\t        if (Horz.Next.Top.X == Result.Prev.Top.X)\n\t        {\n\t          if (!IsClockwise)\n\t            Result = Horz.Next;\n\t        }\n\t        else if (Horz.Next.Top.X > Result.Prev.Top.X)\n\t          Result = Horz.Next;\n\t      }\n\t      while (E != Result)\n\t      {\n\t        E.NextInLML = E.Prev;\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Prev;\n\t      }\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t        this.ReverseHorizontal(E);\n\t      Result = Result.Prev;\n\t      //move to the edge just beyond current bound\n\t    }\n\t  }\n\t  if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n\t  {\n\t    //if edges still remain in the current bound beyond the skip edge then\n\t    //create another LocMin and call ProcessBound once more\n\t    E = Result;\n\t    if (IsClockwise)\n\t    {\n\t      while (E.Top.Y == E.Next.Bot.Y)\n\t        E = E.Next;\n\t      //don't include top horizontals when parsing a bound a second time,\n\t      //they will be contained in the opposite bound ...\n\t      while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Prev;\n\t    }\n\t    else\n\t    {\n\t      while (E.Top.Y == E.Prev.Bot.Y)\n\t        E = E.Prev;\n\t      while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Next;\n\t    }\n\t    if (E == Result)\n\t    {\n\t      if (IsClockwise)\n\t        Result = E.Next;\n\t      else\n\t        Result = E.Prev;\n\t    }\n\t    else\n\t    {\n\t      //there are more edges in the bound beyond result starting with E\n\t      if (IsClockwise)\n\t        E = Result.Next;\n\t      else\n\t        E = Result.Prev;\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      locMin.LeftBound = null;\n\t      locMin.RightBound = E;\n\t      locMin.RightBound.WindDelta = 0;\n\t      Result = this.ProcessBound(locMin.RightBound, IsClockwise);\n\t      this.InsertLocalMinima(locMin);\n\t    }\n\t  }\n\t  return Result;\n\t};\n\tClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t{\n\t  if (use_lines)\n\t  {\n\t    if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n\t      ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t  }\n\t  else\n\t  {\n\t    if (!Closed)\n\t      ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t  }\n\t  var highI = pg.length - 1;\n\t  if (Closed)\n\t    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t  --highI;\n\t  while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t  --highI;\n\t  if ((Closed && highI < 2) || (!Closed && highI < 1))\n\t    return false;\n\t  //create a new edge array ...\n\t  var edges = new Array();\n\t  for (var i = 0; i <= highI; i++)\n\t    edges.push(new ClipperLib.TEdge());\n\t  var IsFlat = true;\n\t  //1. Basic (first) edge initialization ...\n\t\n\t  //edges[1].Curr = pg[1];\n\t  edges[1].Curr.X = pg[1].X;\n\t  edges[1].Curr.Y = pg[1].Y;\n\t\n\t  var $1 = {Value: this.m_UseFullRange};\n\t  this.RangeTest(pg[0], $1);\n\t  this.m_UseFullRange = $1.Value;\n\t\n\t  $1.Value = this.m_UseFullRange;\n\t  this.RangeTest(pg[highI], $1);\n\t  this.m_UseFullRange = $1.Value;\n\t\n\t  this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t  this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t  for (var i = highI - 1; i >= 1; --i)\n\t  {\n\t    $1.Value = this.m_UseFullRange;\n\t    this.RangeTest(pg[i], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t  }\n\t\n\t  var eStart = edges[0];\n\t  //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t  var E = eStart,\n\t    eLoopStop = eStart;\n\t  for (;;)\n\t  {\n\t    if (ClipperLib.IntPoint.op_Equality(E.Curr, E.Next.Curr))\n\t    {\n\t      if (E == E.Next)\n\t        break;\n\t      if (E == eStart)\n\t        eStart = E.Next;\n\t      E = this.RemoveEdge(E);\n\t      eLoopStop = E;\n\t      continue;\n\t    }\n\t    if (E.Prev == E.Next)\n\t      break;\n\t    else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t    {\n\t      //Collinear edges are allowed for open paths but in closed paths\n\t      //the default is to merge adjacent collinear edges into a single edge.\n\t      //However, if the PreserveCollinear property is enabled, only overlapping\n\t      //collinear edges (ie spikes) will be removed from closed paths.\n\t      if (E == eStart)\n\t        eStart = E.Next;\n\t      E = this.RemoveEdge(E);\n\t      E = E.Prev;\n\t      eLoopStop = E;\n\t      continue;\n\t    }\n\t    E = E.Next;\n\t    if (E == eLoopStop)\n\t      break;\n\t  }\n\t  if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n\t    return false;\n\t  if (!Closed)\n\t  {\n\t    this.m_HasOpenPaths = true;\n\t    eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t  }\n\t  //3. Do second stage of edge initialization ...\n\t  var eHighest = eStart;\n\t  E = eStart;\n\t  do {\n\t    this.InitEdge2(E, polyType);\n\t    E = E.Next;\n\t    if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n\t      IsFlat = false;\n\t  }\n\t  while (E != eStart)\n\t  //4. Finally, add edge bounds to LocalMinima list ...\n\t  //Totally flat paths must be handled differently when adding them\n\t  //to LocalMinima list to avoid endless loops etc ...\n\t  if (IsFlat)\n\t  {\n\t    if (Closed)\n\t      return false;\n\t    E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t    if (E.Prev.Bot.X < E.Prev.Top.X)\n\t      this.ReverseHorizontal(E.Prev);\n\t    var locMin = new ClipperLib.LocalMinima();\n\t    locMin.Next = null;\n\t    locMin.Y = E.Bot.Y;\n\t    locMin.LeftBound = null;\n\t    locMin.RightBound = E;\n\t    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t    locMin.RightBound.WindDelta = 0;\n\t    while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t    {\n\t      E.NextInLML = E.Next;\n\t      if (E.Bot.X != E.Prev.Top.X)\n\t        this.ReverseHorizontal(E);\n\t      E = E.Next;\n\t    }\n\t    this.InsertLocalMinima(locMin);\n\t    this.m_edges.push(edges);\n\t    return true;\n\t  }\n\t  this.m_edges.push(edges);\n\t  var clockwise;\n\t  var EMin = null;\n\t  for (;;)\n\t  {\n\t    E = this.FindNextLocMin(E);\n\t    if (E == EMin)\n\t      break;\n\t    else if (EMin == null)\n\t      EMin = E;\n\t    //E and E.Prev now share a local minima (left aligned if horizontal).\n\t    //Compare their slopes to find which starts which bound ...\n\t    var locMin = new ClipperLib.LocalMinima();\n\t    locMin.Next = null;\n\t    locMin.Y = E.Bot.Y;\n\t    if (E.Dx < E.Prev.Dx)\n\t    {\n\t      locMin.LeftBound = E.Prev;\n\t      locMin.RightBound = E;\n\t      clockwise = false;\n\t      //Q.nextInLML = Q.prev\n\t    }\n\t    else\n\t    {\n\t      locMin.LeftBound = E;\n\t      locMin.RightBound = E.Prev;\n\t      clockwise = true;\n\t      //Q.nextInLML = Q.next\n\t    }\n\t    locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t    if (!Closed)\n\t      locMin.LeftBound.WindDelta = 0;\n\t    else if (locMin.LeftBound.Next == locMin.RightBound)\n\t      locMin.LeftBound.WindDelta = -1;\n\t    else\n\t      locMin.LeftBound.WindDelta = 1;\n\t    locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t    E = this.ProcessBound(locMin.LeftBound, clockwise);\n\t    var E2 = this.ProcessBound(locMin.RightBound, !clockwise);\n\t    if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      locMin.LeftBound = null;\n\t    else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      locMin.RightBound = null;\n\t    this.InsertLocalMinima(locMin);\n\t    if (!clockwise)\n\t      E = E2;\n\t  }\n\t  return true;\n\t};\n\tClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t{\n\t  //  console.log(\"-------------------------------------------\");\n\t  //  console.log(JSON.stringify(ppg));\n\t  var result = false;\n\t  for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t    if (this.AddPath(ppg[i], polyType, closed))\n\t      result = true;\n\t  return result;\n\t};\n\t//------------------------------------------------------------------------------\n\tClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t{\n\t  if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||\n\t    (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\t    return false;\n\t  else if (pt1.X != pt3.X)\n\t    return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n\t  else\n\t    return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n\t};\n\tClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t{\n\t  //removes e from double_linked_list (but without removing from memory)\n\t  e.Prev.Next = e.Next;\n\t  e.Next.Prev = e.Prev;\n\t  var result = e.Next;\n\t  e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t  return result;\n\t};\n\tClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t{\n\t  e.Delta.X = (e.Top.X - e.Bot.X);\n\t  e.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t  if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t  else e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t};\n\tClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t{\n\t  if (this.m_MinimaList === null)\n\t  {\n\t    this.m_MinimaList = newLm;\n\t  }\n\t  else if (newLm.Y >= this.m_MinimaList.Y)\n\t  {\n\t    newLm.Next = this.m_MinimaList;\n\t    this.m_MinimaList = newLm;\n\t  }\n\t  else\n\t  {\n\t    var tmpLm = this.m_MinimaList;\n\t    while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t      tmpLm = tmpLm.Next;\n\t    newLm.Next = tmpLm.Next;\n\t    tmpLm.Next = newLm;\n\t  }\n\t};\n\tClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n\t{\n\t  if (this.m_CurrentLM === null)\n\t    return;\n\t  this.m_CurrentLM = this.m_CurrentLM.Next;\n\t};\n\tClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t{\n\t  //swap horizontal edges' top and bottom x's so they follow the natural\n\t  //progression of the bounds - ie so their xbots will align with the\n\t  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t  var tmp = e.Top.X;\n\t  e.Top.X = e.Bot.X;\n\t  e.Bot.X = tmp;\n\t  if (use_xyz)\n\t  {\n\t    tmp = e.Top.Z;\n\t    e.Top.Z = e.Bot.Z;\n\t    e.Bot.Z = tmp;\n\t  }\n\t};\n\tClipperLib.ClipperBase.prototype.Reset = function ()\n\t{\n\t  this.m_CurrentLM = this.m_MinimaList;\n\t  if (this.m_CurrentLM == null)\n\t    return;\n\t  //ie nothing to process\n\t  //reset all edges ...\n\t  var lm = this.m_MinimaList;\n\t  while (lm != null)\n\t  {\n\t    var e = lm.LeftBound;\n\t    if (e != null)\n\t    {\n\t      //e.Curr = e.Bot;\n\t      e.Curr.X = e.Bot.X;\n\t      e.Curr.Y = e.Bot.Y;\n\t      e.Side = ClipperLib.EdgeSide.esLeft;\n\t      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t    }\n\t    e = lm.RightBound;\n\t    if (e != null)\n\t    {\n\t      //e.Curr = e.Bot;\n\t      e.Curr.X = e.Bot.X;\n\t      e.Curr.Y = e.Bot.Y;\n\t      e.Side = ClipperLib.EdgeSide.esRight;\n\t      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t    }\n\t    lm = lm.Next;\n\t  }\n\t};\n\tClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n\t{\n\t  if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n\t  this.m_PolyOuts = null;\n\t  this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t  this.m_Scanbeam = null;\n\t  this.m_ActiveEdges = null;\n\t  this.m_SortedEdges = null;\n\t  this.m_IntersectList = null;\n\t  this.m_IntersectNodeComparer = null;\n\t  this.m_ExecuteLocked = false;\n\t  this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t  this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t  this.m_Joins = null;\n\t  this.m_GhostJoins = null;\n\t  this.m_UsingPolyTree = false;\n\t  this.ReverseSolution = false;\n\t  this.StrictlySimple = false;\n\t  ClipperLib.ClipperBase.call(this);\n\t  this.m_Scanbeam = null;\n\t  this.m_ActiveEdges = null;\n\t  this.m_SortedEdges = null;\n\t  this.m_IntersectList = new Array();\n\t  this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t  this.m_ExecuteLocked = false;\n\t  this.m_UsingPolyTree = false;\n\t  this.m_PolyOuts = new Array();\n\t  this.m_Joins = new Array();\n\t  this.m_GhostJoins = new Array();\n\t  this.ReverseSolution = (1 & InitOptions) !== 0;\n\t  this.StrictlySimple = (2 & InitOptions) !== 0;\n\t  this.PreserveCollinear = (4 & InitOptions) !== 0;\n\t  if (use_xyz)\n\t  {\n\t    this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t  }\n\t};\n\tClipperLib.Clipper.ioReverseSolution = 1;\n\tClipperLib.Clipper.ioStrictlySimple = 2;\n\tClipperLib.Clipper.ioPreserveCollinear = 4;\n\t\n\tClipperLib.Clipper.prototype.Clear = function ()\n\t{\n\t  if (this.m_edges.length === 0)\n\t    return;\n\t  //avoids problems with ClipperBase destructor\n\t  this.DisposeAllPolyPts();\n\t  ClipperLib.ClipperBase.prototype.Clear.call(this);\n\t};\n\t\n\tClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n\t{\n\t  while (this.m_Scanbeam !== null)\n\t  {\n\t    var sb2 = this.m_Scanbeam.Next;\n\t    this.m_Scanbeam = null;\n\t    this.m_Scanbeam = sb2;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.Reset = function ()\n\t{\n\t  ClipperLib.ClipperBase.prototype.Reset.call(this);\n\t  this.m_Scanbeam = null;\n\t  this.m_ActiveEdges = null;\n\t  this.m_SortedEdges = null;\n\t\n\t  var lm = this.m_MinimaList;\n\t  while (lm !== null)\n\t  {\n\t    this.InsertScanbeam(lm.Y);\n\t    lm = lm.Next;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n\t{\n\t  if (this.m_Scanbeam === null)\n\t  {\n\t    this.m_Scanbeam = new ClipperLib.Scanbeam();\n\t    this.m_Scanbeam.Next = null;\n\t    this.m_Scanbeam.Y = Y;\n\t  }\n\t  else if (Y > this.m_Scanbeam.Y)\n\t  {\n\t    var newSb = new ClipperLib.Scanbeam();\n\t    newSb.Y = Y;\n\t    newSb.Next = this.m_Scanbeam;\n\t    this.m_Scanbeam = newSb;\n\t  }\n\t  else\n\t  {\n\t    var sb2 = this.m_Scanbeam;\n\t    while (sb2.Next !== null && (Y <= sb2.Next.Y))\n\t      sb2 = sb2.Next;\n\t    if (Y == sb2.Y)\n\t      return;\n\t    //ie ignores duplicates\n\t    var newSb = new ClipperLib.Scanbeam();\n\t    newSb.Y = Y;\n\t    newSb.Next = sb2.Next;\n\t    sb2.Next = newSb;\n\t  }\n\t};\n\t// ************************************\n\tClipperLib.Clipper.prototype.Execute = function ()\n\t{\n\t  var a = arguments,\n\t    alen = a.length,\n\t    ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t  if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t  {\n\t    var clipType = a[0],\n\t      solution = a[1],\n\t      subjFillType = a[2],\n\t      clipFillType = a[3];\n\t    if (this.m_ExecuteLocked)\n\t      return false;\n\t    if (this.m_HasOpenPaths)\n\t      ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n\t    this.m_ExecuteLocked = true;\n\t    ClipperLib.Clear(solution);\n\t    this.m_SubjFillType = subjFillType;\n\t    this.m_ClipFillType = clipFillType;\n\t    this.m_ClipType = clipType;\n\t    this.m_UsingPolyTree = false;\n\t    try\n\t    {\n\t      var succeeded = this.ExecuteInternal();\n\t      //build the return polygons ...\n\t      if (succeeded) this.BuildResult(solution);\n\t    }\n\t    finally\n\t    {\n\t      this.DisposeAllPolyPts();\n\t      this.m_ExecuteLocked = false;\n\t    }\n\t    return succeeded;\n\t  }\n\t  else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t  {\n\t    var clipType = a[0],\n\t      polytree = a[1],\n\t      subjFillType = a[2],\n\t      clipFillType = a[3];\n\t    if (this.m_ExecuteLocked)\n\t      return false;\n\t    this.m_ExecuteLocked = true;\n\t    this.m_SubjFillType = subjFillType;\n\t    this.m_ClipFillType = clipFillType;\n\t    this.m_ClipType = clipType;\n\t    this.m_UsingPolyTree = true;\n\t    try\n\t    {\n\t      var succeeded = this.ExecuteInternal();\n\t      //build the return polygons ...\n\t      if (succeeded) this.BuildResult2(polytree);\n\t    }\n\t    finally\n\t    {\n\t      this.DisposeAllPolyPts();\n\t      this.m_ExecuteLocked = false;\n\t    }\n\t    return succeeded;\n\t  }\n\t  else if (alen == 2 && !ispolytree) // function (clipType, solution)\n\t  {\n\t    var clipType = a[0],\n\t      solution = a[1];\n\t    return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t  }\n\t  else if (alen == 2 && ispolytree) // function (clipType, polytree)\n\t  {\n\t    var clipType = a[0],\n\t      polytree = a[1];\n\t    return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t{\n\t  //skip if an outermost polygon or\n\t  //already already points to the correct FirstLeft ...\n\t  if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t    return;\n\t  var orfl = outRec.FirstLeft;\n\t  while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n\t    orfl = orfl.FirstLeft;\n\t  outRec.FirstLeft = orfl;\n\t};\n\tClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t{\n\t  try\n\t  {\n\t    this.Reset();\n\t    if (this.m_CurrentLM === null)\n\t      return false;\n\t    var botY = this.PopScanbeam();\n\t    do {\n\t      this.InsertLocalMinimaIntoAEL(botY);\n\t      ClipperLib.Clear(this.m_GhostJoins);\n\t      this.ProcessHorizontals(false);\n\t      if (this.m_Scanbeam === null)\n\t        break;\n\t      var topY = this.PopScanbeam();\n\t      //console.log(\"botY:\" + botY + \", topY:\" + topY);\n\t      if (!this.ProcessIntersections(botY, topY))\n\t        return false;\n\t      this.ProcessEdgesAtTopOfScanbeam(topY);\n\t      botY = topY;\n\t    }\n\t    while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n\t    //fix orientations ...\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts === null || outRec.IsOpen)\n\t        continue;\n\t      if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n\t        this.ReversePolyPtLinks(outRec.Pts);\n\t    }\n\t    this.JoinCommonEdges();\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts !== null && !outRec.IsOpen)\n\t        this.FixupOutPolygon(outRec);\n\t    }\n\t    if (this.StrictlySimple)\n\t      this.DoSimplePolygons();\n\t    return true;\n\t  }\n\t  finally\n\t  {\n\t    ClipperLib.Clear(this.m_Joins);\n\t    ClipperLib.Clear(this.m_GhostJoins);\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.PopScanbeam = function ()\n\t{\n\t  var Y = this.m_Scanbeam.Y;\n\t  var sb2 = this.m_Scanbeam;\n\t  this.m_Scanbeam = this.m_Scanbeam.Next;\n\t  sb2 = null;\n\t  return Y;\n\t};\n\tClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t{\n\t  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t    this.DisposeOutRec(i);\n\t  ClipperLib.Clear(this.m_PolyOuts);\n\t};\n\tClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n\t{\n\t  var outRec = this.m_PolyOuts[index];\n\t  if (outRec.Pts !== null)\n\t    this.DisposeOutPts(outRec.Pts);\n\t  outRec = null;\n\t  this.m_PolyOuts[index] = null;\n\t};\n\tClipperLib.Clipper.prototype.DisposeOutPts = function (pp)\n\t{\n\t  if (pp === null)\n\t    return;\n\t  var tmpPp = null;\n\t  pp.Prev.Next = null;\n\t  while (pp !== null)\n\t  {\n\t    tmpPp = pp;\n\t    pp = pp.Next;\n\t    tmpPp = null;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t{\n\t  var j = new ClipperLib.Join();\n\t  j.OutPt1 = Op1;\n\t  j.OutPt2 = Op2;\n\t  //j.OffPt = OffPt;\n\t  j.OffPt.X = OffPt.X;\n\t  j.OffPt.Y = OffPt.Y;\n\t  this.m_Joins.push(j);\n\t};\n\tClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t{\n\t  var j = new ClipperLib.Join();\n\t  j.OutPt1 = Op;\n\t  //j.OffPt = OffPt;\n\t  j.OffPt.X = OffPt.X;\n\t  j.OffPt.Y = OffPt.Y;\n\t  this.m_GhostJoins.push(j);\n\t};\n\tif (use_xyz)\n\t{\n\t  ClipperLib.Clipper.prototype.SetZ = function (pt, e)\n\t  {\n\t    pt.Z = 0;\n\t    if (this.ZFillFunction !== null)\n\t    {\n\t      //put the 'preferred' point as first parameter ...\n\t      if (e.OutIdx < 0)\n\t        this.ZFillFunction(e.Bot, e.Top, pt); //outside a path so presume entering\n\t      else\n\t        this.ZFillFunction(e.Top, e.Bot, pt); //inside a path so presume exiting\n\t    }\n\t  };\n\t  //------------------------------------------------------------------------------\n\t}\n\tClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t{\n\t  while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n\t  {\n\t    var lb = this.m_CurrentLM.LeftBound;\n\t    var rb = this.m_CurrentLM.RightBound;\n\t    this.PopLocalMinima();\n\t    var Op1 = null;\n\t    if (lb === null)\n\t    {\n\t      this.InsertEdgeIntoAEL(rb, null);\n\t      this.SetWindingCount(rb);\n\t      if (this.IsContributing(rb))\n\t        Op1 = this.AddOutPt(rb, rb.Bot);\n\t    }\n\t    else if (rb == null)\n\t    {\n\t      this.InsertEdgeIntoAEL(lb, null);\n\t      this.SetWindingCount(lb);\n\t      if (this.IsContributing(lb))\n\t        Op1 = this.AddOutPt(lb, lb.Bot);\n\t      this.InsertScanbeam(lb.Top.Y);\n\t    }\n\t    else\n\t    {\n\t      this.InsertEdgeIntoAEL(lb, null);\n\t      this.InsertEdgeIntoAEL(rb, lb);\n\t      this.SetWindingCount(lb);\n\t      rb.WindCnt = lb.WindCnt;\n\t      rb.WindCnt2 = lb.WindCnt2;\n\t      if (this.IsContributing(lb))\n\t        Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t      this.InsertScanbeam(lb.Top.Y);\n\t    }\n\t    if (rb != null)\n\t    {\n\t      if (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t        this.AddEdgeToSEL(rb);\n\t      else\n\t        this.InsertScanbeam(rb.Top.Y);\n\t    }\n\t    if (lb == null || rb == null) continue;\n\t    //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t    if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t    {\n\t      for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t      {\n\t        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t        //the 'ghost' join to a real join ready for later ...\n\t        var j = this.m_GhostJoins[i];\n\t        if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, rb.Bot, rb.Top))\n\t          this.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t      }\n\t    }\n\t    if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t      lb.PrevInAEL.Curr.X == lb.Bot.X &&\n\t      lb.PrevInAEL.OutIdx >= 0 &&\n\t      ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n\t      lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t    {\n\t      var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t      this.AddJoin(Op1, Op2, lb.Top);\n\t    }\n\t    if (lb.NextInAEL != rb)\n\t    {\n\t      if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t        ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n\t        rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t      {\n\t        var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t        this.AddJoin(Op1, Op2, rb.Top);\n\t      }\n\t      var e = lb.NextInAEL;\n\t      if (e !== null)\n\t        while (e != rb)\n\t        {\n\t          //nb: For calculating winding counts etc, IntersectEdges() assumes\n\t          //that param1 will be to the right of param2 ABOVE the intersection ...\n\t          this.IntersectEdges(rb, e, lb.Curr, false);\n\t          //order important here\n\t          e = e.NextInAEL;\n\t        }\n\t    }\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t{\n\t  if (this.m_ActiveEdges === null)\n\t  {\n\t    edge.PrevInAEL = null;\n\t    edge.NextInAEL = null;\n\t    this.m_ActiveEdges = edge;\n\t  }\n\t  else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t  {\n\t    edge.PrevInAEL = null;\n\t    edge.NextInAEL = this.m_ActiveEdges;\n\t    this.m_ActiveEdges.PrevInAEL = edge;\n\t    this.m_ActiveEdges = edge;\n\t  }\n\t  else\n\t  {\n\t    if (startEdge === null)\n\t      startEdge = this.m_ActiveEdges;\n\t    while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t      startEdge = startEdge.NextInAEL;\n\t    edge.NextInAEL = startEdge.NextInAEL;\n\t    if (startEdge.NextInAEL !== null)\n\t      startEdge.NextInAEL.PrevInAEL = edge;\n\t    edge.PrevInAEL = startEdge;\n\t    startEdge.NextInAEL = edge;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t{\n\t  if (e2.Curr.X == e1.Curr.X)\n\t  {\n\t    if (e2.Top.Y > e1.Top.Y)\n\t      return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t    else\n\t      return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t  }\n\t  else\n\t    return e2.Curr.X < e1.Curr.X;\n\t};\n\tClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t{\n\t  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  else\n\t    return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t};\n\tClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t{\n\t  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  else\n\t    return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t};\n\tClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t{\n\t  var pft, pft2;\n\t  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t  {\n\t    pft = this.m_SubjFillType;\n\t    pft2 = this.m_ClipFillType;\n\t  }\n\t  else\n\t  {\n\t    pft = this.m_ClipFillType;\n\t    pft2 = this.m_SubjFillType;\n\t  }\n\t  switch (pft)\n\t  {\n\t  case ClipperLib.PolyFillType.pftEvenOdd:\n\t    if (edge.WindDelta === 0 && edge.WindCnt != 1)\n\t      return false;\n\t    break;\n\t  case ClipperLib.PolyFillType.pftNonZero:\n\t    if (Math.abs(edge.WindCnt) != 1)\n\t      return false;\n\t    break;\n\t  case ClipperLib.PolyFillType.pftPositive:\n\t    if (edge.WindCnt != 1)\n\t      return false;\n\t    break;\n\t  default:\n\t    if (edge.WindCnt != -1)\n\t      return false;\n\t    break;\n\t  }\n\t  switch (this.m_ClipType)\n\t  {\n\t  case ClipperLib.ClipType.ctIntersection:\n\t    switch (pft2)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      return (edge.WindCnt2 !== 0);\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      return (edge.WindCnt2 > 0);\n\t    default:\n\t      return (edge.WindCnt2 < 0);\n\t    }\n\t  case ClipperLib.ClipType.ctUnion:\n\t    switch (pft2)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      return (edge.WindCnt2 === 0);\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      return (edge.WindCnt2 <= 0);\n\t    default:\n\t      return (edge.WindCnt2 >= 0);\n\t    }\n\t  case ClipperLib.ClipType.ctDifference:\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    else\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 !== 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 > 0);\n\t      default:\n\t        return (edge.WindCnt2 < 0);\n\t      }\n\t  case ClipperLib.ClipType.ctXor:\n\t    if (edge.WindDelta === 0)\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    else\n\t      return true;\n\t  }\n\t  return true;\n\t};\n\tClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t{\n\t  var e = edge.PrevInAEL;\n\t  //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t  while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n\t    e = e.PrevInAEL;\n\t  if (e === null)\n\t  {\n\t    edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t    edge.WindCnt2 = 0;\n\t    e = this.m_ActiveEdges;\n\t    //ie get ready to calc WindCnt2\n\t  }\n\t  else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n\t  {\n\t    edge.WindCnt = 1;\n\t    edge.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInAEL;\n\t    //ie get ready to calc WindCnt2\n\t  }\n\t  else if (this.IsEvenOddFillType(edge))\n\t  {\n\t    //EvenOdd filling ...\n\t    if (edge.WindDelta === 0)\n\t    {\n\t      //are we inside a subj polygon ...\n\t      var Inside = true;\n\t      var e2 = e.PrevInAEL;\n\t      while (e2 !== null)\n\t      {\n\t        if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n\t          Inside = !Inside;\n\t        e2 = e2.PrevInAEL;\n\t      }\n\t      edge.WindCnt = (Inside ? 0 : 1);\n\t    }\n\t    else\n\t    {\n\t      edge.WindCnt = edge.WindDelta;\n\t    }\n\t    edge.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInAEL;\n\t    //ie get ready to calc WindCnt2\n\t  }\n\t  else\n\t  {\n\t    //nonZero, Positive or Negative filling ...\n\t    if (e.WindCnt * e.WindDelta < 0)\n\t    {\n\t      //prev edge is 'decreasing' WindCount (WC) toward zero\n\t      //so we're outside the previous polygon ...\n\t      if (Math.abs(e.WindCnt) > 1)\n\t      {\n\t        //outside prev poly but still inside another.\n\t        //when reversing direction of prev poly use the same WC \n\t        if (e.WindDelta * edge.WindDelta < 0)\n\t          edge.WindCnt = e.WindCnt;\n\t        else\n\t          edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t      }\n\t      else\n\t        edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t    }\n\t    else\n\t    {\n\t      //prev edge is 'increasing' WindCount (WC) away from zero\n\t      //so we're inside the previous polygon ...\n\t      if (edge.WindDelta === 0)\n\t        edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t      else if (e.WindDelta * edge.WindDelta < 0)\n\t        edge.WindCnt = e.WindCnt;\n\t      else\n\t        edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t    }\n\t    edge.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInAEL;\n\t    //ie get ready to calc WindCnt2\n\t  }\n\t  //update WindCnt2 ...\n\t  if (this.IsEvenOddAltFillType(edge))\n\t  {\n\t    //EvenOdd filling ...\n\t    while (e != edge)\n\t    {\n\t      if (e.WindDelta !== 0)\n\t        edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t      e = e.NextInAEL;\n\t    }\n\t  }\n\t  else\n\t  {\n\t    //nonZero, Positive or Negative filling ...\n\t    while (e != edge)\n\t    {\n\t      edge.WindCnt2 += e.WindDelta;\n\t      e = e.NextInAEL;\n\t    }\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t{\n\t  //SEL pointers in PEdge are reused to build a list of horizontal edges.\n\t  //However, we don't need to worry about order with horizontal edge processing.\n\t  if (this.m_SortedEdges === null)\n\t  {\n\t    this.m_SortedEdges = edge;\n\t    edge.PrevInSEL = null;\n\t    edge.NextInSEL = null;\n\t  }\n\t  else\n\t  {\n\t    edge.NextInSEL = this.m_SortedEdges;\n\t    edge.PrevInSEL = null;\n\t    this.m_SortedEdges.PrevInSEL = edge;\n\t    this.m_SortedEdges = edge;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t{\n\t  var e = this.m_ActiveEdges;\n\t  this.m_SortedEdges = e;\n\t  while (e !== null)\n\t  {\n\t    e.PrevInSEL = e.PrevInAEL;\n\t    e.NextInSEL = e.NextInAEL;\n\t    e = e.NextInAEL;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t{\n\t  //check that one or other edge hasn't already been removed from AEL ...\n\t  if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n\t    return;\n\t  if (edge1.NextInAEL == edge2)\n\t  {\n\t    var next = edge2.NextInAEL;\n\t    if (next !== null)\n\t      next.PrevInAEL = edge1;\n\t    var prev = edge1.PrevInAEL;\n\t    if (prev !== null)\n\t      prev.NextInAEL = edge2;\n\t    edge2.PrevInAEL = prev;\n\t    edge2.NextInAEL = edge1;\n\t    edge1.PrevInAEL = edge2;\n\t    edge1.NextInAEL = next;\n\t  }\n\t  else if (edge2.NextInAEL == edge1)\n\t  {\n\t    var next = edge1.NextInAEL;\n\t    if (next !== null)\n\t      next.PrevInAEL = edge2;\n\t    var prev = edge2.PrevInAEL;\n\t    if (prev !== null)\n\t      prev.NextInAEL = edge1;\n\t    edge1.PrevInAEL = prev;\n\t    edge1.NextInAEL = edge2;\n\t    edge2.PrevInAEL = edge1;\n\t    edge2.NextInAEL = next;\n\t  }\n\t  else\n\t  {\n\t    var next = edge1.NextInAEL;\n\t    var prev = edge1.PrevInAEL;\n\t    edge1.NextInAEL = edge2.NextInAEL;\n\t    if (edge1.NextInAEL !== null)\n\t      edge1.NextInAEL.PrevInAEL = edge1;\n\t    edge1.PrevInAEL = edge2.PrevInAEL;\n\t    if (edge1.PrevInAEL !== null)\n\t      edge1.PrevInAEL.NextInAEL = edge1;\n\t    edge2.NextInAEL = next;\n\t    if (edge2.NextInAEL !== null)\n\t      edge2.NextInAEL.PrevInAEL = edge2;\n\t    edge2.PrevInAEL = prev;\n\t    if (edge2.PrevInAEL !== null)\n\t      edge2.PrevInAEL.NextInAEL = edge2;\n\t  }\n\t  if (edge1.PrevInAEL === null)\n\t    this.m_ActiveEdges = edge1;\n\t  else if (edge2.PrevInAEL === null)\n\t    this.m_ActiveEdges = edge2;\n\t};\n\tClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t{\n\t  if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t    return;\n\t  if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t    return;\n\t  if (edge1.NextInSEL == edge2)\n\t  {\n\t    var next = edge2.NextInSEL;\n\t    if (next !== null)\n\t      next.PrevInSEL = edge1;\n\t    var prev = edge1.PrevInSEL;\n\t    if (prev !== null)\n\t      prev.NextInSEL = edge2;\n\t    edge2.PrevInSEL = prev;\n\t    edge2.NextInSEL = edge1;\n\t    edge1.PrevInSEL = edge2;\n\t    edge1.NextInSEL = next;\n\t  }\n\t  else if (edge2.NextInSEL == edge1)\n\t  {\n\t    var next = edge1.NextInSEL;\n\t    if (next !== null)\n\t      next.PrevInSEL = edge2;\n\t    var prev = edge2.PrevInSEL;\n\t    if (prev !== null)\n\t      prev.NextInSEL = edge1;\n\t    edge1.PrevInSEL = prev;\n\t    edge1.NextInSEL = edge2;\n\t    edge2.PrevInSEL = edge1;\n\t    edge2.NextInSEL = next;\n\t  }\n\t  else\n\t  {\n\t    var next = edge1.NextInSEL;\n\t    var prev = edge1.PrevInSEL;\n\t    edge1.NextInSEL = edge2.NextInSEL;\n\t    if (edge1.NextInSEL !== null)\n\t      edge1.NextInSEL.PrevInSEL = edge1;\n\t    edge1.PrevInSEL = edge2.PrevInSEL;\n\t    if (edge1.PrevInSEL !== null)\n\t      edge1.PrevInSEL.NextInSEL = edge1;\n\t    edge2.NextInSEL = next;\n\t    if (edge2.NextInSEL !== null)\n\t      edge2.NextInSEL.PrevInSEL = edge2;\n\t    edge2.PrevInSEL = prev;\n\t    if (edge2.PrevInSEL !== null)\n\t      edge2.PrevInSEL.NextInSEL = edge2;\n\t  }\n\t  if (edge1.PrevInSEL === null)\n\t    this.m_SortedEdges = edge1;\n\t  else if (edge2.PrevInSEL === null)\n\t    this.m_SortedEdges = edge2;\n\t};\n\tClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t{\n\t  this.AddOutPt(e1, pt);\n\t  if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\t  if (e1.OutIdx == e2.OutIdx)\n\t  {\n\t    e1.OutIdx = -1;\n\t    e2.OutIdx = -1;\n\t  }\n\t  else if (e1.OutIdx < e2.OutIdx)\n\t    this.AppendPolygon(e1, e2);\n\t  else\n\t    this.AppendPolygon(e2, e1);\n\t};\n\tClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t{\n\t  var result;\n\t  var e, prevE;\n\t  if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t  {\n\t    result = this.AddOutPt(e1, pt);\n\t    e2.OutIdx = e1.OutIdx;\n\t    e1.Side = ClipperLib.EdgeSide.esLeft;\n\t    e2.Side = ClipperLib.EdgeSide.esRight;\n\t    e = e1;\n\t    if (e.PrevInAEL == e2)\n\t      prevE = e2.PrevInAEL;\n\t    else\n\t      prevE = e.PrevInAEL;\n\t  }\n\t  else\n\t  {\n\t    result = this.AddOutPt(e2, pt);\n\t    e1.OutIdx = e2.OutIdx;\n\t    e1.Side = ClipperLib.EdgeSide.esRight;\n\t    e2.Side = ClipperLib.EdgeSide.esLeft;\n\t    e = e2;\n\t    if (e.PrevInAEL == e1)\n\t      prevE = e1.PrevInAEL;\n\t    else\n\t      prevE = e.PrevInAEL;\n\t  }\n\t  if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n\t  {\n\t    var outPt = this.AddOutPt(prevE, pt);\n\t    this.AddJoin(result, outPt, e.Top);\n\t  }\n\t  return result;\n\t};\n\tClipperLib.Clipper.prototype.CreateOutRec = function ()\n\t{\n\t  var result = new ClipperLib.OutRec();\n\t  result.Idx = -1;\n\t  result.IsHole = false;\n\t  result.IsOpen = false;\n\t  result.FirstLeft = null;\n\t  result.Pts = null;\n\t  result.BottomPt = null;\n\t  result.PolyNode = null;\n\t  this.m_PolyOuts.push(result);\n\t  result.Idx = this.m_PolyOuts.length - 1;\n\t  return result;\n\t};\n\tClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t{\n\t  var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n\t  if (e.OutIdx < 0)\n\t  {\n\t    var outRec = this.CreateOutRec();\n\t    outRec.IsOpen = (e.WindDelta === 0);\n\t    var newOp = new ClipperLib.OutPt();\n\t    outRec.Pts = newOp;\n\t    newOp.Idx = outRec.Idx;\n\t    //newOp.Pt = pt;\n\t    newOp.Pt.X = pt.X;\n\t    newOp.Pt.Y = pt.Y;\n\t    newOp.Next = newOp;\n\t    newOp.Prev = newOp;\n\t    if (!outRec.IsOpen)\n\t      this.SetHoleState(e, outRec);\n\t    if (use_xyz)\n\t    {\n\t      if (ClipperLib.IntPoint.op_Equality(pt, e.Bot))\n\t      {\n\t        //newOp.Pt = e.Bot;\n\t        newOp.Pt.X = e.Bot.X;\n\t        newOp.Pt.Y = e.Bot.Y;\n\t        newOp.Pt.Z = e.Bot.Z;\n\t      }\n\t      else if (ClipperLib.IntPoint.op_Equality(pt, e.Top))\n\t      {\n\t        //newOp.Pt = e.Top;\n\t        newOp.Pt.X = e.Top.X;\n\t        newOp.Pt.Y = e.Top.Y;\n\t        newOp.Pt.Z = e.Top.Z;\n\t      }\n\t      else\n\t        this.SetZ(newOp.Pt, e);\n\t    }\n\t    e.OutIdx = outRec.Idx;\n\t    //nb: do this after SetZ !\n\t    return newOp;\n\t  }\n\t  else\n\t  {\n\t    var outRec = this.m_PolyOuts[e.OutIdx];\n\t    //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t    var op = outRec.Pts;\n\t    if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t      return op;\n\t    else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t      return op.Prev;\n\t    var newOp = new ClipperLib.OutPt();\n\t    newOp.Idx = outRec.Idx;\n\t    //newOp.Pt = pt;\n\t    newOp.Pt.X = pt.X;\n\t    newOp.Pt.Y = pt.Y;\n\t    newOp.Next = op;\n\t    newOp.Prev = op.Prev;\n\t    newOp.Prev.Next = newOp;\n\t    op.Prev = newOp;\n\t    if (ToFront)\n\t      outRec.Pts = newOp;\n\t    if (use_xyz)\n\t    {\n\t      if (ClipperLib.IntPoint.op_Equality(pt, e.Bot))\n\t      {\n\t        //newOp.Pt = e.Bot;\n\t        newOp.Pt.X = e.Bot.X;\n\t        newOp.Pt.Y = e.Bot.Y;\n\t        newOp.Pt.Z = e.Bot.Z;\n\t      }\n\t      else if (ClipperLib.IntPoint.op_Equality(pt, e.Top))\n\t      {\n\t        //newOp.Pt = e.Top;\n\t        newOp.Pt.X = e.Top.X;\n\t        newOp.Pt.Y = e.Top.Y;\n\t        newOp.Pt.Z = e.Top.Z;\n\t      }\n\t      else\n\t        this.SetZ(newOp.Pt, e);\n\t    }\n\t    return newOp;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t{\n\t  var tmp = new ClipperLib.IntPoint(pt1.Value);\n\t  //pt1.Value = pt2.Value;\n\t  pt1.Value.X = pt2.Value.X;\n\t  pt1.Value.Y = pt2.Value.Y;\n\t  //pt2.Value = tmp;\n\t  pt2.Value.X = tmp.X;\n\t  pt2.Value.Y = tmp.Y;\n\t};\n\tClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (Pt1a, Pt1b, Pt2a, Pt2b)\n\t{\n\t  //precondition: both segments are horizontal\n\t  if ((Pt1a.X > Pt2a.X) == (Pt1a.X < Pt2b.X))\n\t    return true;\n\t  else if ((Pt1b.X > Pt2a.X) == (Pt1b.X < Pt2b.X))\n\t    return true;\n\t  else if ((Pt2a.X > Pt1a.X) == (Pt2a.X < Pt1b.X))\n\t    return true;\n\t  else if ((Pt2b.X > Pt1a.X) == (Pt2b.X < Pt1b.X))\n\t    return true;\n\t  else if ((Pt1a.X == Pt2a.X) && (Pt1b.X == Pt2b.X))\n\t    return true;\n\t  else if ((Pt1a.X == Pt2b.X) && (Pt1b.X == Pt2a.X))\n\t    return true;\n\t  else\n\t    return false;\n\t};\n\tClipperLib.Clipper.prototype.InsertPolyPtBetween = function (p1, p2, pt)\n\t{\n\t  var result = new ClipperLib.OutPt();\n\t  //result.Pt = pt;\n\t  result.Pt.X = pt.X;\n\t  result.Pt.Y = pt.Y;\n\t  if (p2 == p1.Next)\n\t  {\n\t    p1.Next = result;\n\t    p2.Prev = result;\n\t    result.Next = p2;\n\t    result.Prev = p1;\n\t  }\n\t  else\n\t  {\n\t    p2.Next = result;\n\t    p1.Prev = result;\n\t    result.Next = p1;\n\t    result.Prev = p2;\n\t  }\n\t  return result;\n\t};\n\tClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t{\n\t  var isHole = false;\n\t  var e2 = e.PrevInAEL;\n\t  while (e2 !== null)\n\t  {\n\t    if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n\t    {\n\t      isHole = !isHole;\n\t      if (outRec.FirstLeft === null)\n\t        outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n\t    }\n\t    e2 = e2.PrevInAEL;\n\t  }\n\t  if (isHole)\n\t    outRec.IsHole = true;\n\t};\n\tClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t{\n\t  if (pt1.Y == pt2.Y)\n\t    return ClipperLib.ClipperBase.horizontal;\n\t  else\n\t    return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t};\n\tClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t{\n\t  var p = btmPt1.Prev;\n\t  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t    p = p.Prev;\n\t  var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t  p = btmPt1.Next;\n\t  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t    p = p.Next;\n\t  var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t  p = btmPt2.Prev;\n\t  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t    p = p.Prev;\n\t  var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t  p = btmPt2.Next;\n\t  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t    p = p.Next;\n\t  var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t  return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t};\n\tClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t{\n\t  var dups = null;\n\t  var p = pp.Next;\n\t  while (p != pp)\n\t  {\n\t    if (p.Pt.Y > pp.Pt.Y)\n\t    {\n\t      pp = p;\n\t      dups = null;\n\t    }\n\t    else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t    {\n\t      if (p.Pt.X < pp.Pt.X)\n\t      {\n\t        dups = null;\n\t        pp = p;\n\t      }\n\t      else\n\t      {\n\t        if (p.Next != pp && p.Prev != pp)\n\t          dups = p;\n\t      }\n\t    }\n\t    p = p.Next;\n\t  }\n\t  if (dups !== null)\n\t  {\n\t    //there appears to be at least 2 vertices at bottomPt so ...\n\t    while (dups != p)\n\t    {\n\t      if (!this.FirstIsBottomPt(p, dups))\n\t        pp = dups;\n\t      dups = dups.Next;\n\t      while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t        dups = dups.Next;\n\t    }\n\t  }\n\t  return pp;\n\t};\n\tClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t{\n\t  //work out which polygon fragment has the correct hole state ...\n\t  if (outRec1.BottomPt === null)\n\t    outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t  if (outRec2.BottomPt === null)\n\t    outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t  var bPt1 = outRec1.BottomPt;\n\t  var bPt2 = outRec2.BottomPt;\n\t  if (bPt1.Pt.Y > bPt2.Pt.Y)\n\t    return outRec1;\n\t  else if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t    return outRec2;\n\t  else if (bPt1.Pt.X < bPt2.Pt.X)\n\t    return outRec1;\n\t  else if (bPt1.Pt.X > bPt2.Pt.X)\n\t    return outRec2;\n\t  else if (bPt1.Next == bPt1)\n\t    return outRec2;\n\t  else if (bPt2.Next == bPt2)\n\t    return outRec1;\n\t  else if (this.FirstIsBottomPt(bPt1, bPt2))\n\t    return outRec1;\n\t  else\n\t    return outRec2;\n\t};\n\tClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n\t{\n\t  do {\n\t    outRec1 = outRec1.FirstLeft;\n\t    if (outRec1 == outRec2)\n\t      return true;\n\t  }\n\t  while (outRec1 !== null)\n\t  return false;\n\t};\n\tClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t{\n\t  var outrec = this.m_PolyOuts[idx];\n\t  while (outrec != this.m_PolyOuts[outrec.Idx])\n\t    outrec = this.m_PolyOuts[outrec.Idx];\n\t  return outrec;\n\t};\n\tClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t{\n\t  //get the start and ends of both output polygons ...\n\t  var outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t  var outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t  var holeStateRec;\n\t  if (this.Param1RightOfParam2(outRec1, outRec2))\n\t    holeStateRec = outRec2;\n\t  else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t    holeStateRec = outRec1;\n\t  else\n\t    holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t  var p1_lft = outRec1.Pts;\n\t  var p1_rt = p1_lft.Prev;\n\t  var p2_lft = outRec2.Pts;\n\t  var p2_rt = p2_lft.Prev;\n\t  var side;\n\t  //join e2 poly onto e1 poly and delete pointers to e2 ...\n\t  if (e1.Side == ClipperLib.EdgeSide.esLeft)\n\t  {\n\t    if (e2.Side == ClipperLib.EdgeSide.esLeft)\n\t    {\n\t      //z y x a b c\n\t      this.ReversePolyPtLinks(p2_lft);\n\t      p2_lft.Next = p1_lft;\n\t      p1_lft.Prev = p2_lft;\n\t      p1_rt.Next = p2_rt;\n\t      p2_rt.Prev = p1_rt;\n\t      outRec1.Pts = p2_rt;\n\t    }\n\t    else\n\t    {\n\t      //x y z a b c\n\t      p2_rt.Next = p1_lft;\n\t      p1_lft.Prev = p2_rt;\n\t      p2_lft.Prev = p1_rt;\n\t      p1_rt.Next = p2_lft;\n\t      outRec1.Pts = p2_lft;\n\t    }\n\t    side = ClipperLib.EdgeSide.esLeft;\n\t  }\n\t  else\n\t  {\n\t    if (e2.Side == ClipperLib.EdgeSide.esRight)\n\t    {\n\t      //a b c z y x\n\t      this.ReversePolyPtLinks(p2_lft);\n\t      p1_rt.Next = p2_rt;\n\t      p2_rt.Prev = p1_rt;\n\t      p2_lft.Next = p1_lft;\n\t      p1_lft.Prev = p2_lft;\n\t    }\n\t    else\n\t    {\n\t      //a b c x y z\n\t      p1_rt.Next = p2_lft;\n\t      p2_lft.Prev = p1_rt;\n\t      p1_lft.Prev = p2_rt;\n\t      p2_rt.Next = p1_lft;\n\t    }\n\t    side = ClipperLib.EdgeSide.esRight;\n\t  }\n\t  outRec1.BottomPt = null;\n\t  if (holeStateRec == outRec2)\n\t  {\n\t    if (outRec2.FirstLeft != outRec1)\n\t      outRec1.FirstLeft = outRec2.FirstLeft;\n\t    outRec1.IsHole = outRec2.IsHole;\n\t  }\n\t  outRec2.Pts = null;\n\t  outRec2.BottomPt = null;\n\t  outRec2.FirstLeft = outRec1;\n\t  var OKIdx = e1.OutIdx;\n\t  var ObsoleteIdx = e2.OutIdx;\n\t  e1.OutIdx = -1;\n\t  //nb: safe because we only get here via AddLocalMaxPoly\n\t  e2.OutIdx = -1;\n\t  var e = this.m_ActiveEdges;\n\t  while (e !== null)\n\t  {\n\t    if (e.OutIdx == ObsoleteIdx)\n\t    {\n\t      e.OutIdx = OKIdx;\n\t      e.Side = side;\n\t      break;\n\t    }\n\t    e = e.NextInAEL;\n\t  }\n\t  outRec2.Idx = outRec1.Idx;\n\t};\n\tClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t{\n\t  if (pp === null)\n\t    return;\n\t  var pp1;\n\t  var pp2;\n\t  pp1 = pp;\n\t  do {\n\t    pp2 = pp1.Next;\n\t    pp1.Next = pp1.Prev;\n\t    pp1.Prev = pp2;\n\t    pp1 = pp2;\n\t  }\n\t  while (pp1 != pp)\n\t};\n\tClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t{\n\t  var side = edge1.Side;\n\t  edge1.Side = edge2.Side;\n\t  edge2.Side = side;\n\t};\n\tClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t{\n\t  var outIdx = edge1.OutIdx;\n\t  edge1.OutIdx = edge2.OutIdx;\n\t  edge2.OutIdx = outIdx;\n\t};\n\tClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt, protect)\n\t{\n\t  //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t  //e2 in AEL except when e1 is being inserted at the intersection point ...\n\t  var e1stops = !protect && e1.NextInLML === null &&\n\t    e1.Top.X == pt.X && e1.Top.Y == pt.Y;\n\t  var e2stops = !protect && e2.NextInLML === null &&\n\t    e2.Top.X == pt.X && e2.Top.Y == pt.Y;\n\t  var e1Contributing = (e1.OutIdx >= 0);\n\t  var e2Contributing = (e2.OutIdx >= 0);\n\t  if (use_lines)\n\t  {\n\t    //if either edge is on an OPEN path ...\n\t    if (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t    {\n\t      //ignore subject-subject open path intersections UNLESS they\n\t      //are both open paths, AND they are both 'contributing maximas' ...\n\t      if (e1.WindDelta === 0 && e2.WindDelta === 0)\n\t      {\n\t        if ((e1stops || e2stops) && e1Contributing && e2Contributing)\n\t          this.AddLocalMaxPoly(e1, e2, pt);\n\t      }\n\t      //if intersecting a subj line with a subj poly ...\n\t      else if (e1.PolyTyp == e2.PolyTyp &&\n\t        e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n\t      {\n\t        if (e1.WindDelta === 0)\n\t        {\n\t          if (e2Contributing)\n\t          {\n\t            this.AddOutPt(e1, pt);\n\t            if (e1Contributing)\n\t              e1.OutIdx = -1;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (e1Contributing)\n\t          {\n\t            this.AddOutPt(e2, pt);\n\t            if (e2Contributing)\n\t              e2.OutIdx = -1;\n\t          }\n\t        }\n\t      }\n\t      else if (e1.PolyTyp != e2.PolyTyp)\n\t      {\n\t        if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n\t          (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t        {\n\t          this.AddOutPt(e1, pt);\n\t          if (e1Contributing)\n\t            e1.OutIdx = -1;\n\t        }\n\t        else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n\t          (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t        {\n\t          this.AddOutPt(e2, pt);\n\t          if (e2Contributing)\n\t            e2.OutIdx = -1;\n\t        }\n\t      }\n\t      if (e1stops)\n\t        if (e1.OutIdx < 0)\n\t          this.DeleteFromAEL(e1);\n\t        else\n\t          ClipperLib.Error(\"Error intersecting polylines\");\n\t      if (e2stops)\n\t        if (e2.OutIdx < 0)\n\t          this.DeleteFromAEL(e2);\n\t        else\n\t          ClipperLib.Error(\"Error intersecting polylines\");\n\t      return;\n\t    }\n\t  }\n\t  //update winding counts...\n\t  //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t  if (e1.PolyTyp == e2.PolyTyp)\n\t  {\n\t    if (this.IsEvenOddFillType(e1))\n\t    {\n\t      var oldE1WindCnt = e1.WindCnt;\n\t      e1.WindCnt = e2.WindCnt;\n\t      e2.WindCnt = oldE1WindCnt;\n\t    }\n\t    else\n\t    {\n\t      if (e1.WindCnt + e2.WindDelta === 0)\n\t        e1.WindCnt = -e1.WindCnt;\n\t      else\n\t        e1.WindCnt += e2.WindDelta;\n\t      if (e2.WindCnt - e1.WindDelta === 0)\n\t        e2.WindCnt = -e2.WindCnt;\n\t      else\n\t        e2.WindCnt -= e1.WindDelta;\n\t    }\n\t  }\n\t  else\n\t  {\n\t    if (!this.IsEvenOddFillType(e2))\n\t      e1.WindCnt2 += e2.WindDelta;\n\t    else\n\t      e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t    if (!this.IsEvenOddFillType(e1))\n\t      e2.WindCnt2 -= e1.WindDelta;\n\t    else\n\t      e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t  }\n\t  var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t  if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t  {\n\t    e1FillType = this.m_SubjFillType;\n\t    e1FillType2 = this.m_ClipFillType;\n\t  }\n\t  else\n\t  {\n\t    e1FillType = this.m_ClipFillType;\n\t    e1FillType2 = this.m_SubjFillType;\n\t  }\n\t  if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t  {\n\t    e2FillType = this.m_SubjFillType;\n\t    e2FillType2 = this.m_ClipFillType;\n\t  }\n\t  else\n\t  {\n\t    e2FillType = this.m_ClipFillType;\n\t    e2FillType2 = this.m_SubjFillType;\n\t  }\n\t  var e1Wc, e2Wc;\n\t  switch (e1FillType)\n\t  {\n\t  case ClipperLib.PolyFillType.pftPositive:\n\t    e1Wc = e1.WindCnt;\n\t    break;\n\t  case ClipperLib.PolyFillType.pftNegative:\n\t    e1Wc = -e1.WindCnt;\n\t    break;\n\t  default:\n\t    e1Wc = Math.abs(e1.WindCnt);\n\t    break;\n\t  }\n\t  switch (e2FillType)\n\t  {\n\t  case ClipperLib.PolyFillType.pftPositive:\n\t    e2Wc = e2.WindCnt;\n\t    break;\n\t  case ClipperLib.PolyFillType.pftNegative:\n\t    e2Wc = -e2.WindCnt;\n\t    break;\n\t  default:\n\t    e2Wc = Math.abs(e2.WindCnt);\n\t    break;\n\t  }\n\t  if (e1Contributing && e2Contributing)\n\t  {\n\t    if (e1stops || e2stops || (e1Wc !== 0 && e1Wc != 1) || (e2Wc !== 0 && e2Wc != 1) ||\n\t      (e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t      this.AddLocalMaxPoly(e1, e2, pt);\n\t    else\n\t    {\n\t      this.AddOutPt(e1, pt);\n\t      this.AddOutPt(e2, pt);\n\t      ClipperLib.Clipper.SwapSides(e1, e2);\n\t      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t    }\n\t  }\n\t  else if (e1Contributing)\n\t  {\n\t    if (e2Wc === 0 || e2Wc == 1)\n\t    {\n\t      this.AddOutPt(e1, pt);\n\t      ClipperLib.Clipper.SwapSides(e1, e2);\n\t      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t    }\n\t  }\n\t  else if (e2Contributing)\n\t  {\n\t    if (e1Wc === 0 || e1Wc == 1)\n\t    {\n\t      this.AddOutPt(e2, pt);\n\t      ClipperLib.Clipper.SwapSides(e1, e2);\n\t      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t    }\n\t  }\n\t  else if ((e1Wc === 0 || e1Wc == 1) &&\n\t    (e2Wc === 0 || e2Wc == 1) && !e1stops && !e2stops)\n\t  {\n\t    //neither edge is currently contributing ...\n\t    var e1Wc2, e2Wc2;\n\t    switch (e1FillType2)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e1Wc2 = e1.WindCnt2;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e1Wc2 = -e1.WindCnt2;\n\t      break;\n\t    default:\n\t      e1Wc2 = Math.abs(e1.WindCnt2);\n\t      break;\n\t    }\n\t    switch (e2FillType2)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e2Wc2 = e2.WindCnt2;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e2Wc2 = -e2.WindCnt2;\n\t      break;\n\t    default:\n\t      e2Wc2 = Math.abs(e2.WindCnt2);\n\t      break;\n\t    }\n\t    if (e1.PolyTyp != e2.PolyTyp)\n\t      this.AddLocalMinPoly(e1, e2, pt);\n\t    else if (e1Wc == 1 && e2Wc == 1)\n\t      switch (this.m_ClipType)\n\t      {\n\t      case ClipperLib.ClipType.ctIntersection:\n\t        if (e1Wc2 > 0 && e2Wc2 > 0)\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t        break;\n\t      case ClipperLib.ClipType.ctUnion:\n\t        if (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t        break;\n\t      case ClipperLib.ClipType.ctDifference:\n\t        if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t          ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t        break;\n\t      case ClipperLib.ClipType.ctXor:\n\t        this.AddLocalMinPoly(e1, e2, pt);\n\t        break;\n\t      }\n\t    else\n\t      ClipperLib.Clipper.SwapSides(e1, e2);\n\t  }\n\t  if ((e1stops != e2stops) &&\n\t    ((e1stops && (e1.OutIdx >= 0)) || (e2stops && (e2.OutIdx >= 0))))\n\t  {\n\t    ClipperLib.Clipper.SwapSides(e1, e2);\n\t    ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t  }\n\t  //finally, delete any non-contributing maxima edges  ...\n\t  if (e1stops)\n\t    this.DeleteFromAEL(e1);\n\t  if (e2stops)\n\t    this.DeleteFromAEL(e2);\n\t};\n\tClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n\t{\n\t  var AelPrev = e.PrevInAEL;\n\t  var AelNext = e.NextInAEL;\n\t  if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n\t    return;\n\t  //already deleted\n\t  if (AelPrev !== null)\n\t    AelPrev.NextInAEL = AelNext;\n\t  else\n\t    this.m_ActiveEdges = AelNext;\n\t  if (AelNext !== null)\n\t    AelNext.PrevInAEL = AelPrev;\n\t  e.NextInAEL = null;\n\t  e.PrevInAEL = null;\n\t};\n\tClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t{\n\t  var SelPrev = e.PrevInSEL;\n\t  var SelNext = e.NextInSEL;\n\t  if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n\t    return;\n\t  //already deleted\n\t  if (SelPrev !== null)\n\t    SelPrev.NextInSEL = SelNext;\n\t  else\n\t    this.m_SortedEdges = SelNext;\n\t  if (SelNext !== null)\n\t    SelNext.PrevInSEL = SelPrev;\n\t  e.NextInSEL = null;\n\t  e.PrevInSEL = null;\n\t};\n\tClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n\t{\n\t  if (e.NextInLML === null)\n\t    ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t  var AelPrev = e.PrevInAEL;\n\t  var AelNext = e.NextInAEL;\n\t  e.NextInLML.OutIdx = e.OutIdx;\n\t  if (AelPrev !== null)\n\t    AelPrev.NextInAEL = e.NextInLML;\n\t  else\n\t    this.m_ActiveEdges = e.NextInLML;\n\t  if (AelNext !== null)\n\t    AelNext.PrevInAEL = e.NextInLML;\n\t  e.NextInLML.Side = e.Side;\n\t  e.NextInLML.WindDelta = e.WindDelta;\n\t  e.NextInLML.WindCnt = e.WindCnt;\n\t  e.NextInLML.WindCnt2 = e.WindCnt2;\n\t  e = e.NextInLML;\n\t  //    e.Curr = e.Bot;\n\t  e.Curr.X = e.Bot.X;\n\t  e.Curr.Y = e.Bot.Y;\n\t  e.PrevInAEL = AelPrev;\n\t  e.NextInAEL = AelNext;\n\t  if (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t    this.InsertScanbeam(e.Top.Y);\n\t  return e;\n\t};\n\tClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n\t{\n\t  var horzEdge = this.m_SortedEdges;\n\t  while (horzEdge !== null)\n\t  {\n\t    this.DeleteFromSEL(horzEdge);\n\t    this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n\t    horzEdge = this.m_SortedEdges;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t{\n\t  if (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t  {\n\t      $var.Left = HorzEdge.Bot.X;\n\t      $var.Right = HorzEdge.Top.X;\n\t      $var.Dir = ClipperLib.Direction.dLeftToRight;\n\t  }\n\t  else\n\t  {\n\t      $var.Left = HorzEdge.Top.X;\n\t      $var.Right = HorzEdge.Bot.X;\n\t      $var.Dir = ClipperLib.Direction.dRightToLeft;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.PrepareHorzJoins = function (horzEdge, isTopOfScanbeam)\n\t{\n\t  //get the last Op for this horizontal edge\n\t  //the point may be anywhere along the horizontal ...\n\t  var outPt = this.m_PolyOuts[horzEdge.OutIdx].Pts;\n\t  if (horzEdge.Side != ClipperLib.EdgeSide.esLeft)\n\t    outPt = outPt.Prev;\n\t  //First, match up overlapping horizontal edges (eg when one polygon's\n\t  //intermediate horz edge overlaps an intermediate horz edge of another, or\n\t  //when one polygon sits on top of another) ...\n\t  //for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; ++i) {\n\t  //  var j = this.m_GhostJoins[i];\n\t  //  if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, horzEdge.Bot, horzEdge.Top))\n\t  //    this.AddJoin(j.OutPt1, outPt, j.OffPt);\n\t  //}\n\t\n\t  //Also, since horizontal edges at the top of one SB are often removed from\n\t  //the AEL before we process the horizontal edges at the bottom of the next,\n\t  //we need to create 'ghost' Join records of 'contrubuting' horizontals that\n\t  //we can compare with horizontals at the bottom of the next SB.\n\t  if (isTopOfScanbeam)\n\t    if (ClipperLib.IntPoint.op_Equality(outPt.Pt, horzEdge.Top))\n\t      this.AddGhostJoin(outPt, horzEdge.Bot);\n\t    else\n\t      this.AddGhostJoin(outPt, horzEdge.Top);\n\t};\n\tClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n\t{\n\t  var $var = {Dir: null, Left: null, Right: null};\n\t  this.GetHorzDirection(horzEdge, $var);\n\t  var dir = $var.Dir;\n\t  var horzLeft = $var.Left;\n\t  var horzRight = $var.Right;\n\t\n\t  var eLastHorz = horzEdge,\n\t    eMaxPair = null;\n\t  while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t    eLastHorz = eLastHorz.NextInLML;\n\t  if (eLastHorz.NextInLML === null)\n\t    eMaxPair = this.GetMaximaPair(eLastHorz);\n\t  for (;;)\n\t  {\n\t    var IsLastHorz = (horzEdge == eLastHorz);\n\t    var e = this.GetNextInAEL(horzEdge, dir);\n\t    while (e !== null)\n\t    {\n\t      //Break if we've got to the end of an intermediate horizontal edge ...\n\t      //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t      if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t        break;\n\t      var eNext = this.GetNextInAEL(e, dir);\n\t      //saves eNext for later\n\t      if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n\t      {\n\t\n\t        if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta != 0)\n\t          this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);\n\t\n\t        //so far we're still in range of the horizontal Edge  but make sure\n\t        //we're at the last of consec. horizontals when matching with eMaxPair\n\t        if (e == eMaxPair && IsLastHorz)\n\t        {\n\t          if (dir == ClipperLib.Direction.dLeftToRight)\n\t            this.IntersectEdges(horzEdge, e, e.Top, false);\n\t          else\n\t            this.IntersectEdges(e, horzEdge, e.Top, false);\n\t          if (eMaxPair.OutIdx >= 0)\n\t            ClipperLib.Error(\"ProcessHorizontal error\");\n\t          return;\n\t        }\n\t        else if (dir == ClipperLib.Direction.dLeftToRight)\n\t        {\n\t          var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t          this.IntersectEdges(horzEdge, e, Pt, true);\n\t        }\n\t        else\n\t        {\n\t          var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t          this.IntersectEdges(e, horzEdge, Pt, true);\n\t        }\n\t        this.SwapPositionsInAEL(horzEdge, e);\n\t      }\n\t      else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n\t        break;\n\t      e = eNext;\n\t    }\n\t    //end while\n\t    if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta !== 0)\n\t      this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);\n\t    if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t    {\n\t      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t      if (horzEdge.OutIdx >= 0)\n\t        this.AddOutPt(horzEdge, horzEdge.Bot);\n\t        \n\t        var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n\t        this.GetHorzDirection(horzEdge, $var);\n\t        dir = $var.Dir;\n\t        horzLeft = $var.Left;\n\t        horzRight = $var.Right;\n\t    }\n\t    else\n\t      break;\n\t  }\n\t  //end for (;;)\n\t  if (horzEdge.NextInLML !== null)\n\t  {\n\t    if (horzEdge.OutIdx >= 0)\n\t    {\n\t      var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t      if (horzEdge.WindDelta === 0)\n\t        return;\n\t      //nb: HorzEdge is no longer horizontal here\n\t      var ePrev = horzEdge.PrevInAEL;\n\t      var eNext = horzEdge.NextInAEL;\n\t      if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n\t        ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n\t        (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n\t      {\n\t        var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t        this.AddJoin(op1, op2, horzEdge.Top);\n\t      }\n\t      else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n\t        eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n\t        eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t        ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n\t      {\n\t        var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t        this.AddJoin(op1, op2, horzEdge.Top);\n\t      }\n\t    }\n\t    else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t  }\n\t  else if (eMaxPair !== null)\n\t  {\n\t    if (eMaxPair.OutIdx >= 0)\n\t    {\n\t      if (dir == ClipperLib.Direction.dLeftToRight)\n\t        this.IntersectEdges(horzEdge, eMaxPair, horzEdge.Top, false);\n\t      else\n\t        this.IntersectEdges(eMaxPair, horzEdge, horzEdge.Top, false);\n\t      if (eMaxPair.OutIdx >= 0)\n\t        ClipperLib.Error(\"ProcessHorizontal error\");\n\t    }\n\t    else\n\t    {\n\t      this.DeleteFromAEL(horzEdge);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t  }\n\t  else\n\t  {\n\t    if (horzEdge.OutIdx >= 0)\n\t      this.AddOutPt(horzEdge, horzEdge.Top);\n\t    this.DeleteFromAEL(horzEdge);\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t{\n\t  return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t};\n\tClipperLib.Clipper.prototype.IsMinima = function (e)\n\t{\n\t  return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n\t};\n\tClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t{\n\t  return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n\t};\n\tClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t{\n\t  return (e.Top.Y == Y && e.NextInLML !== null);\n\t};\n\tClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t{\n\t  var result = null;\n\t  if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t    result = e.Next;\n\t  else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t    result = e.Prev;\n\t  if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n\t    return null;\n\t  return result;\n\t};\n\tClipperLib.Clipper.prototype.ProcessIntersections = function (botY, topY)\n\t{\n\t  if (this.m_ActiveEdges == null)\n\t    return true;\n\t  try\n\t  {\n\t    this.BuildIntersectList(botY, topY);\n\t    if (this.m_IntersectList.length == 0)\n\t      return true;\n\t    if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n\t      this.ProcessIntersectList();\n\t    else\n\t      return false;\n\t  }\n\t  catch ($$e2)\n\t  {\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList.length = 0;\n\t    ClipperLib.Error(\"ProcessIntersections error\");\n\t  }\n\t  this.m_SortedEdges = null;\n\t  return true;\n\t};\n\tClipperLib.Clipper.prototype.BuildIntersectList = function (botY, topY)\n\t{\n\t  if (this.m_ActiveEdges === null)\n\t    return;\n\t  //prepare for sorting ...\n\t  var e = this.m_ActiveEdges;\n\t  //console.log(JSON.stringify(JSON.decycle( e )));\n\t  this.m_SortedEdges = e;\n\t  while (e !== null)\n\t  {\n\t    e.PrevInSEL = e.PrevInAEL;\n\t    e.NextInSEL = e.NextInAEL;\n\t    e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t    e = e.NextInAEL;\n\t  }\n\t  //bubblesort ...\n\t  var isModified = true;\n\t  while (isModified && this.m_SortedEdges !== null)\n\t  {\n\t    isModified = false;\n\t    e = this.m_SortedEdges;\n\t    while (e.NextInSEL !== null)\n\t    {\n\t      var eNext = e.NextInSEL;\n\t      var pt = new ClipperLib.IntPoint();\n\t      //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t      if (e.Curr.X > eNext.Curr.X)\n\t      {\n\t        if (!this.IntersectPoint(e, eNext, pt) && e.Curr.X > eNext.Curr.X + 1)\n\t        {\n\t          //console.log(\"e.Curr.X: \"+JSON.stringify(JSON.decycle( e.Curr.X )));\n\t          //console.log(\"eNext.Curr.X+1: \"+JSON.stringify(JSON.decycle( eNext.Curr.X+1)));\n\t          ClipperLib.Error(\"Intersection error\");\n\t        }\n\t        if (pt.Y > botY)\n\t        {\n\t          pt.Y = botY;\n\t          if (Math.abs(e.Dx) > Math.abs(eNext.Dx))\n\t            pt.X = ClipperLib.Clipper.TopX(eNext, botY);\n\t          else\n\t            pt.X = ClipperLib.Clipper.TopX(e, botY);\n\t        }\n\t        var newNode = new ClipperLib.IntersectNode();\n\t        newNode.Edge1 = e;\n\t        newNode.Edge2 = eNext;\n\t        //newNode.Pt = pt;\n\t        newNode.Pt.X = pt.X;\n\t        newNode.Pt.Y = pt.Y;\n\t        this.m_IntersectList.push(newNode);\n\t        this.SwapPositionsInSEL(e, eNext);\n\t        isModified = true;\n\t      }\n\t      else\n\t        e = eNext;\n\t    }\n\t    if (e.PrevInSEL !== null)\n\t      e.PrevInSEL.NextInSEL = null;\n\t    else\n\t      break;\n\t  }\n\t  this.m_SortedEdges = null;\n\t};\n\tClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t{\n\t  return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n\t};\n\tClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t{\n\t  //the following typecast is safe because the differences in Pt.Y will\n\t  //be limited to the height of the scanbeam.\n\t  return (node2.Pt.Y - node1.Pt.Y);\n\t};\n\tClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t{\n\t  //pre-condition: intersections are sorted bottom-most first.\n\t  //Now it's crucial that intersections are made only between adjacent edges,\n\t  //so to ensure this the order of intersections may need adjusting ...\n\t  this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t  this.CopyAELToSEL();\n\t  var cnt = this.m_IntersectList.length;\n\t  for (var i = 0; i < cnt; i++)\n\t  {\n\t    if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t    {\n\t      var j = i + 1;\n\t      while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t        j++;\n\t      if (j == cnt)\n\t        return false;\n\t      var tmp = this.m_IntersectList[i];\n\t      this.m_IntersectList[i] = this.m_IntersectList[j];\n\t      this.m_IntersectList[j] = tmp;\n\t    }\n\t    this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t  }\n\t  return true;\n\t};\n\tClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t{\n\t  for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t  {\n\t    var iNode = this.m_IntersectList[i];\n\t    this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt, true);\n\t    this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t  }\n\t  this.m_IntersectList.length = 0;\n\t};\n\t/*\n\t--------------------------------\n\tRound speedtest: http://jsperf.com/fastest-round\n\t--------------------------------\n\t*/\n\tvar R1 = function (a)\n\t{\n\t  return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t};\n\tvar R2 = function (a)\n\t{\n\t  return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t};\n\tvar R3 = function (a)\n\t{\n\t  return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t};\n\tvar R4 = function (a)\n\t{\n\t  if (a < 0)\n\t  {\n\t    a -= 0.5;\n\t    return a < -2147483648 ? Math.ceil(a) : a | 0;\n\t  }\n\t  else\n\t  {\n\t    a += 0.5;\n\t    return a > 2147483647 ? Math.floor(a) : a | 0;\n\t  }\n\t};\n\tif (browser.msie) ClipperLib.Clipper.Round = R1;\n\telse if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\telse if (browser.safari) ClipperLib.Clipper.Round = R4;\n\telse ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\tClipperLib.Clipper.TopX = function (edge, currentY)\n\t{\n\t  //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t  //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t  if (currentY == edge.Top.Y)\n\t    return edge.Top.X;\n\t  return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t};\n\tClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t{\n\t  ip.X = 0;\n\t  ip.Y = 0;\n\t  var b1, b2;\n\t  //nb: with very large coordinate values, it's possible for SlopesEqual() to \n\t  //return false but for the edge.Dx value be equal due to double precision rounding.\n\t  if (ClipperLib.ClipperBase.SlopesEqual(edge1, edge2, this.m_UseFullRange) || edge1.Dx == edge2.Dx)\n\t  {\n\t    if (edge2.Bot.Y > edge1.Bot.Y)\n\t    {\n\t      ip.X = edge2.Bot.X;\n\t      ip.Y = edge2.Bot.Y;\n\t    }\n\t    else\n\t    {\n\t      ip.X = edge1.Bot.X;\n\t      ip.Y = edge1.Bot.Y;\n\t    }\n\t    return false;\n\t  }\n\t  else if (edge1.Delta.X === 0)\n\t  {\n\t    ip.X = edge1.Bot.X;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t    {\n\t      ip.Y = edge2.Bot.Y;\n\t    }\n\t    else\n\t    {\n\t      b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t    }\n\t  }\n\t  else if (edge2.Delta.X === 0)\n\t  {\n\t    ip.X = edge2.Bot.X;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t    {\n\t      ip.Y = edge1.Bot.Y;\n\t    }\n\t    else\n\t    {\n\t      b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t    }\n\t  }\n\t  else\n\t  {\n\t    b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t    b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t    var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t    ip.Y = ClipperLib.Clipper.Round(q);\n\t    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t      ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t    else\n\t      ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t  }\n\t  if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t  {\n\t    if (edge1.Top.Y > edge2.Top.Y)\n\t    {\n\t      ip.Y = edge1.Top.Y;\n\t      ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t      return ip.X < edge1.Top.X;\n\t    }\n\t    else\n\t      ip.Y = edge2.Top.Y;\n\t    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t      ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t    else\n\t      ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t  }\n\t  return true;\n\t};\n\tClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t{\n\t  var e = this.m_ActiveEdges;\n\t  while (e !== null)\n\t  {\n\t    //1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t    var IsMaximaEdge = this.IsMaxima(e, topY);\n\t    if (IsMaximaEdge)\n\t    {\n\t      var eMaxPair = this.GetMaximaPair(e);\n\t      IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t    }\n\t    if (IsMaximaEdge)\n\t    {\n\t      var ePrev = e.PrevInAEL;\n\t      this.DoMaxima(e);\n\t      if (ePrev === null)\n\t        e = this.m_ActiveEdges;\n\t      else\n\t        e = ePrev.NextInAEL;\n\t    }\n\t    else\n\t    {\n\t      //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t      if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t      {\n\t        e = this.UpdateEdgeIntoAEL(e);\n\t        if (e.OutIdx >= 0)\n\t          this.AddOutPt(e, e.Bot);\n\t        this.AddEdgeToSEL(e);\n\t      }\n\t      else\n\t      {\n\t        e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t        e.Curr.Y = topY;\n\t      }\n\t      if (this.StrictlySimple)\n\t      {\n\t        var ePrev = e.PrevInAEL;\n\t        if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t          (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n\t          (ePrev.WindDelta !== 0))\n\t        {\n\t          var op = this.AddOutPt(ePrev, e.Curr);\n\t          var op2 = this.AddOutPt(e, e.Curr);\n\t          this.AddJoin(op, op2, e.Curr);\n\t          //StrictlySimple (type-3) join\n\t        }\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t  }\n\t  //3. Process horizontals at the Top of the scanbeam ...\n\t  this.ProcessHorizontals(true);\n\t  //4. Promote intermediate vertices ...\n\t  e = this.m_ActiveEdges;\n\t  while (e !== null)\n\t  {\n\t    if (this.IsIntermediate(e, topY))\n\t    {\n\t      var op = null;\n\t      if (e.OutIdx >= 0)\n\t        op = this.AddOutPt(e, e.Top);\n\t      e = this.UpdateEdgeIntoAEL(e);\n\t      //if output polygons share an edge, they'll need joining later ...\n\t      var ePrev = e.PrevInAEL;\n\t      var eNext = e.NextInAEL;\n\t      if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n\t        ePrev.Curr.Y == e.Bot.Y && op !== null &&\n\t        ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t        ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n\t        (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t      {\n\t        var op2 = this.AddOutPt(ePrev, e.Bot);\n\t        this.AddJoin(op, op2, e.Top);\n\t      }\n\t      else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n\t        eNext.Curr.Y == e.Bot.Y && op !== null &&\n\t        eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t        ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n\t        (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t      {\n\t        var op2 = this.AddOutPt(eNext, e.Bot);\n\t        this.AddJoin(op, op2, e.Top);\n\t      }\n\t    }\n\t    e = e.NextInAEL;\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t{\n\t  var eMaxPair = this.GetMaximaPair(e);\n\t  if (eMaxPair === null)\n\t  {\n\t    if (e.OutIdx >= 0)\n\t      this.AddOutPt(e, e.Top);\n\t    this.DeleteFromAEL(e);\n\t    return;\n\t  }\n\t  var eNext = e.NextInAEL;\n\t  var use_lines = true;\n\t  while (eNext !== null && eNext != eMaxPair)\n\t  {\n\t    this.IntersectEdges(e, eNext, e.Top, true);\n\t    this.SwapPositionsInAEL(e, eNext);\n\t    eNext = e.NextInAEL;\n\t  }\n\t  if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n\t  {\n\t    this.DeleteFromAEL(e);\n\t    this.DeleteFromAEL(eMaxPair);\n\t  }\n\t  else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t  {\n\t    this.IntersectEdges(e, eMaxPair, e.Top, false);\n\t  }\n\t  else if (use_lines && e.WindDelta === 0)\n\t  {\n\t    if (e.OutIdx >= 0)\n\t    {\n\t      this.AddOutPt(e, e.Top);\n\t      e.OutIdx = -1;\n\t    }\n\t    this.DeleteFromAEL(e);\n\t    if (eMaxPair.OutIdx >= 0)\n\t    {\n\t      this.AddOutPt(eMaxPair, e.Top);\n\t      eMaxPair.OutIdx = -1;\n\t    }\n\t    this.DeleteFromAEL(eMaxPair);\n\t  }\n\t  else\n\t    ClipperLib.Error(\"DoMaxima error\");\n\t};\n\tClipperLib.Clipper.ReversePaths = function (polys)\n\t{\n\t  for (var i = 0, len = polys.length; i < len; i++)\n\t    polys[i].reverse();\n\t};\n\tClipperLib.Clipper.Orientation = function (poly)\n\t{\n\t  return ClipperLib.Clipper.Area(poly) >= 0;\n\t};\n\tClipperLib.Clipper.prototype.PointCount = function (pts)\n\t{\n\t  if (pts === null)\n\t    return 0;\n\t  var result = 0;\n\t  var p = pts;\n\t  do {\n\t    result++;\n\t    p = p.Next;\n\t  }\n\t  while (p != pts)\n\t  return result;\n\t};\n\tClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t{\n\t  ClipperLib.Clear(polyg);\n\t  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t  {\n\t    var outRec = this.m_PolyOuts[i];\n\t    if (outRec.Pts === null)\n\t      continue;\n\t    var p = outRec.Pts.Prev;\n\t    var cnt = this.PointCount(p);\n\t    if (cnt < 2)\n\t      continue;\n\t    var pg = new Array(cnt);\n\t    for (var j = 0; j < cnt; j++)\n\t    {\n\t      pg[j] = p.Pt;\n\t      p = p.Prev;\n\t    }\n\t    polyg.push(pg);\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t{\n\t  polytree.Clear();\n\t  //add each output polygon/contour to polytree ...\n\t  //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t  {\n\t    var outRec = this.m_PolyOuts[i];\n\t    var cnt = this.PointCount(outRec.Pts);\n\t    if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t      continue;\n\t    this.FixHoleLinkage(outRec);\n\t    var pn = new ClipperLib.PolyNode();\n\t    polytree.m_AllPolys.push(pn);\n\t    outRec.PolyNode = pn;\n\t    pn.m_polygon.length = cnt;\n\t    var op = outRec.Pts.Prev;\n\t    for (var j = 0; j < cnt; j++)\n\t    {\n\t      pn.m_polygon[j] = op.Pt;\n\t      op = op.Prev;\n\t    }\n\t  }\n\t  //fixup PolyNode links etc ...\n\t  //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t  {\n\t    var outRec = this.m_PolyOuts[i];\n\t    if (outRec.PolyNode === null)\n\t      continue;\n\t    else if (outRec.IsOpen)\n\t    {\n\t      outRec.PolyNode.IsOpen = true;\n\t      polytree.AddChild(outRec.PolyNode);\n\t    }\n\t    else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n\t      outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t    else\n\t      polytree.AddChild(outRec.PolyNode);\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t{\n\t  //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t  //parallel edges by removing the middle vertex.\n\t  var lastOK = null;\n\t  outRec.BottomPt = null;\n\t  var pp = outRec.Pts;\n\t  for (;;)\n\t  {\n\t    if (pp.Prev == pp || pp.Prev == pp.Next)\n\t    {\n\t      this.DisposeOutPts(pp);\n\t      outRec.Pts = null;\n\t      return;\n\t    }\n\t    //test for duplicate points and collinear edges ...\n\t    if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n\t      (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n\t        (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t    {\n\t      lastOK = null;\n\t      var tmp = pp;\n\t      pp.Prev.Next = pp.Next;\n\t      pp.Next.Prev = pp.Prev;\n\t      pp = pp.Prev;\n\t      tmp = null;\n\t    }\n\t    else if (pp == lastOK)\n\t      break;\n\t    else\n\t    {\n\t      if (lastOK === null)\n\t        lastOK = pp;\n\t      pp = pp.Next;\n\t    }\n\t  }\n\t  outRec.Pts = pp;\n\t};\n\tClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t{\n\t  var result = new ClipperLib.OutPt();\n\t  //result.Pt = outPt.Pt;\n\t  result.Pt.X = outPt.Pt.X;\n\t  result.Pt.Y = outPt.Pt.Y;\n\t  result.Idx = outPt.Idx;\n\t  if (InsertAfter)\n\t  {\n\t    result.Next = outPt.Next;\n\t    result.Prev = outPt;\n\t    outPt.Next.Prev = result;\n\t    outPt.Next = result;\n\t  }\n\t  else\n\t  {\n\t    result.Prev = outPt.Prev;\n\t    result.Next = outPt;\n\t    outPt.Prev.Next = result;\n\t    outPt.Prev = result;\n\t  }\n\t  return result;\n\t};\n\tClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t{\n\t  if (a1 < a2)\n\t  {\n\t    if (b1 < b2)\n\t    {\n\t      $val.Left = Math.max(a1, b1);\n\t      $val.Right = Math.min(a2, b2);\n\t    }\n\t    else\n\t    {\n\t      $val.Left = Math.max(a1, b2);\n\t      $val.Right = Math.min(a2, b1);\n\t    }\n\t  }\n\t  else\n\t  {\n\t    if (b1 < b2)\n\t    {\n\t      $val.Left = Math.max(a2, b1);\n\t      $val.Right = Math.min(a1, b2);\n\t    }\n\t    else\n\t    {\n\t      $val.Left = Math.max(a2, b2);\n\t      $val.Right = Math.min(a1, b1);\n\t    }\n\t  }\n\t  return $val.Left < $val.Right;\n\t};\n\tClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t{\n\t  var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t  var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t  if (Dir1 == Dir2)\n\t    return false;\n\t  //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t  //So, to facilitate this while inserting Op1b and Op2b ...\n\t  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t  if (Dir1 == ClipperLib.Direction.dLeftToRight)\n\t  {\n\t    while (op1.Next.Pt.X <= Pt.X &&\n\t      op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t      op1 = op1.Next;\n\t    if (DiscardLeft && (op1.Pt.X != Pt.X))\n\t      op1 = op1.Next;\n\t    op1b = this.DupOutPt(op1, !DiscardLeft);\n\t    if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t    {\n\t      op1 = op1b;\n\t      //op1.Pt = Pt;\n\t      op1.Pt.X = Pt.X;\n\t      op1.Pt.Y = Pt.Y;\n\t      op1b = this.DupOutPt(op1, !DiscardLeft);\n\t    }\n\t  }\n\t  else\n\t  {\n\t    while (op1.Next.Pt.X >= Pt.X &&\n\t      op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t      op1 = op1.Next;\n\t    if (!DiscardLeft && (op1.Pt.X != Pt.X))\n\t      op1 = op1.Next;\n\t    op1b = this.DupOutPt(op1, DiscardLeft);\n\t    if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t    {\n\t      op1 = op1b;\n\t      //op1.Pt = Pt;\n\t      op1.Pt.X = Pt.X;\n\t      op1.Pt.Y = Pt.Y;\n\t      op1b = this.DupOutPt(op1, DiscardLeft);\n\t    }\n\t  }\n\t  if (Dir2 == ClipperLib.Direction.dLeftToRight)\n\t  {\n\t    while (op2.Next.Pt.X <= Pt.X &&\n\t      op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t      op2 = op2.Next;\n\t    if (DiscardLeft && (op2.Pt.X != Pt.X))\n\t      op2 = op2.Next;\n\t    op2b = this.DupOutPt(op2, !DiscardLeft);\n\t    if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t    {\n\t      op2 = op2b;\n\t      //op2.Pt = Pt;\n\t      op2.Pt.X = Pt.X;\n\t      op2.Pt.Y = Pt.Y;\n\t      op2b = this.DupOutPt(op2, !DiscardLeft);\n\t    }\n\t  }\n\t  else\n\t  {\n\t    while (op2.Next.Pt.X >= Pt.X &&\n\t      op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t      op2 = op2.Next;\n\t    if (!DiscardLeft && (op2.Pt.X != Pt.X))\n\t      op2 = op2.Next;\n\t    op2b = this.DupOutPt(op2, DiscardLeft);\n\t    if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t    {\n\t      op2 = op2b;\n\t      //op2.Pt = Pt;\n\t      op2.Pt.X = Pt.X;\n\t      op2.Pt.Y = Pt.Y;\n\t      op2b = this.DupOutPt(op2, DiscardLeft);\n\t    }\n\t  }\n\t  if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n\t  {\n\t    op1.Prev = op2;\n\t    op2.Next = op1;\n\t    op1b.Next = op2b;\n\t    op2b.Prev = op1b;\n\t  }\n\t  else\n\t  {\n\t    op1.Next = op2;\n\t    op2.Prev = op1;\n\t    op1b.Prev = op2b;\n\t    op2b.Next = op1b;\n\t  }\n\t  return true;\n\t};\n\tClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t{\n\t  var op1 = j.OutPt1,\n\t    op1b = new ClipperLib.OutPt();\n\t  var op2 = j.OutPt2,\n\t    op2b = new ClipperLib.OutPt();\n\t  //There are 3 kinds of joins for output polygons ...\n\t  //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n\t  //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t  //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t  //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t  //3. StrictlySimple joins where edges touch but are not collinear and where\n\t  //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t  var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n\t  if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t  {\n\t    //Strictly Simple join ...\n\t    op1b = j.OutPt1.Next;\n\t    while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t      op1b = op1b.Next;\n\t    var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t    op2b = j.OutPt2.Next;\n\t    while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t      op2b = op2b.Next;\n\t    var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t    if (reverse1 == reverse2)\n\t      return false;\n\t    if (reverse1)\n\t    {\n\t      op1b = this.DupOutPt(op1, false);\n\t      op2b = this.DupOutPt(op2, true);\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op1b;\n\t      return true;\n\t    }\n\t    else\n\t    {\n\t      op1b = this.DupOutPt(op1, true);\n\t      op2b = this.DupOutPt(op2, false);\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op1b;\n\t      return true;\n\t    }\n\t  }\n\t  else if (isHorizontal)\n\t  {\n\t    //treat horizontal joins differently to non-horizontal joins since with\n\t    //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t    //may be anywhere along the horizontal edge.\n\t    op1b = op1;\n\t    while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n\t      op1 = op1.Prev;\n\t    while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n\t      op1b = op1b.Next;\n\t    if (op1b.Next == op1 || op1b.Next == op2)\n\t      return false;\n\t    //a flat 'polygon'\n\t    op2b = op2;\n\t    while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n\t      op2 = op2.Prev;\n\t    while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n\t      op2b = op2b.Next;\n\t    if (op2b.Next == op2 || op2b.Next == op1)\n\t      return false;\n\t    //a flat 'polygon'\n\t    //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\t\n\t    var $val = {Left: null, Right: null};\n\t    if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t      return false;\n\t    var Left = $val.Left;\n\t    var Right = $val.Right;\n\t\n\t    //DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t    //on the discard Side as either may still be needed for other joins ...\n\t    var Pt = new ClipperLib.IntPoint();\n\t    var DiscardLeftSide;\n\t    if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t    {\n\t      //Pt = op1.Pt;\n\t      Pt.X = op1.Pt.X;\n\t      Pt.Y = op1.Pt.Y;\n\t      DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t    }\n\t    else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t    {\n\t      //Pt = op2.Pt;\n\t      Pt.X = op2.Pt.X;\n\t      Pt.Y = op2.Pt.Y;\n\t      DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t    }\n\t    else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t    {\n\t      //Pt = op1b.Pt;\n\t      Pt.X = op1b.Pt.X;\n\t      Pt.Y = op1b.Pt.Y;\n\t      DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t    }\n\t    else\n\t    {\n\t      //Pt = op2b.Pt;\n\t      Pt.X = op2b.Pt.X;\n\t      Pt.Y = op2b.Pt.Y;\n\t      DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t    }\n\t    j.OutPt1 = op1;\n\t    j.OutPt2 = op2;\n\t    return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t  }\n\t  else\n\t  {\n\t    //nb: For non-horizontal joins ...\n\t    //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t    //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t    //make sure the polygons are correctly oriented ...\n\t    op1b = op1.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t      op1b = op1b.Next;\n\t    var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t    if (Reverse1)\n\t    {\n\t      op1b = op1.Prev;\n\t      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t        op1b = op1b.Prev;\n\t      if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t        return false;\n\t    }\n\t    op2b = op2.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t      op2b = op2b.Next;\n\t    var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t    if (Reverse2)\n\t    {\n\t      op2b = op2.Prev;\n\t      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t        op2b = op2b.Prev;\n\t      if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t        return false;\n\t    }\n\t    if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n\t      ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n\t      return false;\n\t    if (Reverse1)\n\t    {\n\t      op1b = this.DupOutPt(op1, false);\n\t      op2b = this.DupOutPt(op2, true);\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op1b;\n\t      return true;\n\t    }\n\t    else\n\t    {\n\t      op1b = this.DupOutPt(op1, true);\n\t      op2b = this.DupOutPt(op2, false);\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op1b;\n\t      return true;\n\t    }\n\t  }\n\t};\n\tClipperLib.Clipper.GetBounds = function (paths)\n\t{\n\t  var i = 0,\n\t    cnt = paths.length;\n\t  while (i < cnt && paths[i].length == 0) i++;\n\t  if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t  var result = new ClipperLib.IntRect();\n\t  result.left = paths[i][0].X;\n\t  result.right = result.left;\n\t  result.top = paths[i][0].Y;\n\t  result.bottom = result.top;\n\t  for (; i < cnt; i++)\n\t    for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t    {\n\t      if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t      else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t      if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t      else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t    }\n\t  return result;\n\t}\n\tClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t{\n\t  var opStart = ops;\n\t  var result = new ClipperLib.IntRect();\n\t  result.left = ops.Pt.X;\n\t  result.right = ops.Pt.X;\n\t  result.top = ops.Pt.Y;\n\t  result.bottom = ops.Pt.Y;\n\t  ops = ops.Next;\n\t  while (ops != opStart)\n\t  {\n\t    if (ops.Pt.X < result.left)\n\t      result.left = ops.Pt.X;\n\t    if (ops.Pt.X > result.right)\n\t      result.right = ops.Pt.X;\n\t    if (ops.Pt.Y < result.top)\n\t      result.top = ops.Pt.Y;\n\t    if (ops.Pt.Y > result.bottom)\n\t      result.bottom = ops.Pt.Y;\n\t    ops = ops.Next;\n\t  }\n\t  return result;\n\t};\n\t\n\tClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t{\n\t  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t  var result = 0,\n\t    cnt = path.length;\n\t  if (cnt < 3)\n\t    return 0;\n\t  var ip = path[0];\n\t  for (var i = 1; i <= cnt; ++i)\n\t  {\n\t    var ipNext = (i == cnt ? path[0] : path[i]);\n\t    if (ipNext.Y == pt.Y)\n\t    {\n\t      if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n\t        return -1;\n\t    }\n\t    if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n\t    {\n\t      if (ip.X >= pt.X)\n\t      {\n\t        if (ipNext.X > pt.X)\n\t          result = 1 - result;\n\t        else\n\t        {\n\t          var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t          if (d == 0)\n\t            return -1;\n\t          else if ((d > 0) == (ipNext.Y > ip.Y))\n\t            result = 1 - result;\n\t        }\n\t      }\n\t      else\n\t      {\n\t        if (ipNext.X > pt.X)\n\t        {\n\t          var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t          if (d == 0)\n\t            return -1;\n\t          else if ((d > 0) == (ipNext.Y > ip.Y))\n\t            result = 1 - result;\n\t        }\n\t      }\n\t    }\n\t    ip = ipNext;\n\t  }\n\t  return result;\n\t};\n\t    \n\tClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t{\n\t  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t  var result = 0;\n\t  var startOp = op;\n\t  for (;;)\n\t  {\n\t    var poly0x = op.Pt.X,\n\t      poly0y = op.Pt.Y;\n\t    var poly1x = op.Next.Pt.X,\n\t      poly1y = op.Next.Pt.Y;\n\t    if (poly1y == pt.Y)\n\t    {\n\t      if ((poly1x == pt.X) || (poly0y == pt.Y && ((poly1x > pt.X) == (poly0x < pt.X))))\n\t        return -1;\n\t    }\n\t    if ((poly0y < pt.Y) != (poly1y < pt.Y))\n\t    {\n\t      if (poly0x >= pt.X)\n\t      {\n\t        if (poly1x > pt.X)\n\t          result = 1 - result;\n\t        else\n\t        {\n\t          var d = (poly0x - pt.X) * (poly1y - pt.Y) - (poly1x - pt.X) * (poly0y - pt.Y);\n\t          if (d == 0)\n\t            return -1;\n\t          if ((d > 0) == (poly1y > poly0y))\n\t            result = 1 - result;\n\t        }\n\t      }\n\t      else\n\t      {\n\t        if (poly1x > pt.X)\n\t        {\n\t          var d = (poly0x - pt.X) * (poly1y - pt.Y) - (poly1x - pt.X) * (poly0y - pt.Y);\n\t          if (d == 0)\n\t            return -1;\n\t          if ((d > 0) == (poly1y > poly0y))\n\t            result = 1 - result;\n\t        }\n\t      }\n\t    }\n\t    op = op.Next;\n\t    if (startOp == op)\n\t      break;\n\t  }\n\t  return result;\n\t};\n\t\n\tClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t{\n\t  var op = outPt1;\n\t  do {\n\t    var res = this.PointInPolygon(op.Pt, outPt2);\n\t    if (res >= 0)\n\t      return res != 0;\n\t    op = op.Next;\n\t  }\n\t  while (op != outPt1)\n\t  return true;\n\t};\n\tClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t{\n\t  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t  {\n\t    var outRec = this.m_PolyOuts[i];\n\t    if (outRec.Pts !== null && outRec.FirstLeft == OldOutRec)\n\t    {\n\t      if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t        outRec.FirstLeft = NewOutRec;\n\t    }\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n\t{\n\t  for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n\t    if (outRec.FirstLeft == OldOutRec)\n\t      outRec.FirstLeft = NewOutRec;\n\t};\n\tClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t{\n\t  while (FirstLeft != null && FirstLeft.Pts == null)\n\t    FirstLeft = FirstLeft.FirstLeft;\n\t  return FirstLeft;\n\t};\n\tClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t{\n\t  for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t  {\n\t    var join = this.m_Joins[i];\n\t    var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t    var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t    if (outRec1.Pts == null || outRec2.Pts == null)\n\t      continue;\n\t    //get the polygon fragment with the correct hole state (FirstLeft)\n\t    //before calling JoinPoints() ...\n\t    var holeStateRec;\n\t    if (outRec1 == outRec2)\n\t      holeStateRec = outRec1;\n\t    else if (this.Param1RightOfParam2(outRec1, outRec2))\n\t      holeStateRec = outRec2;\n\t    else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t      holeStateRec = outRec1;\n\t    else\n\t      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t\n\t    if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\t\n\t    if (outRec1 == outRec2)\n\t    {\n\t      //instead of joining two polygons, we've just created a new one by\n\t      //splitting one polygon into two.\n\t      outRec1.Pts = join.OutPt1;\n\t      outRec1.BottomPt = null;\n\t      outRec2 = this.CreateOutRec();\n\t      outRec2.Pts = join.OutPt2;\n\t      //update all OutRec2.Pts Idx's ...\n\t      this.UpdateOutPtIdxs(outRec2);\n\t      //We now need to check every OutRec.FirstLeft pointer. If it points\n\t      //to OutRec1 it may need to point to OutRec2 instead ...\n\t      if (this.m_UsingPolyTree)\n\t        for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n\t        {\n\t          var oRec = this.m_PolyOuts[j];\n\t          if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n\t            continue;\n\t          if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n\t            oRec.FirstLeft = outRec2;\n\t        }\n\t      if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t      {\n\t        //outRec2 is contained by outRec1 ...\n\t        outRec2.IsHole = !outRec1.IsHole;\n\t        outRec2.FirstLeft = outRec1;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec2, outRec1);\n\t        if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n\t          this.ReversePolyPtLinks(outRec2.Pts);\n\t      }\n\t      else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t      {\n\t        //outRec1 is contained by outRec2 ...\n\t        outRec2.IsHole = outRec1.IsHole;\n\t        outRec1.IsHole = !outRec2.IsHole;\n\t        outRec2.FirstLeft = outRec1.FirstLeft;\n\t        outRec1.FirstLeft = outRec2;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec1, outRec2);\n\t        if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n\t          this.ReversePolyPtLinks(outRec1.Pts);\n\t      }\n\t      else\n\t      {\n\t        //the 2 polygons are completely separate ...\n\t        outRec2.IsHole = outRec1.IsHole;\n\t        outRec2.FirstLeft = outRec1.FirstLeft;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec2\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts1(outRec1, outRec2);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      //joined 2 polygons together ...\n\t      outRec2.Pts = null;\n\t      outRec2.BottomPt = null;\n\t      outRec2.Idx = outRec1.Idx;\n\t      outRec1.IsHole = holeStateRec.IsHole;\n\t      if (holeStateRec == outRec2)\n\t        outRec1.FirstLeft = outRec2.FirstLeft;\n\t      outRec2.FirstLeft = outRec1;\n\t      //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t      if (this.m_UsingPolyTree)\n\t        this.FixupFirstLefts2(outRec2, outRec1);\n\t    }\n\t  }\n\t};\n\tClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t{\n\t  var op = outrec.Pts;\n\t  do {\n\t    op.Idx = outrec.Idx;\n\t    op = op.Prev;\n\t  }\n\t  while (op != outrec.Pts)\n\t};\n\tClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t{\n\t  var i = 0;\n\t  while (i < this.m_PolyOuts.length)\n\t  {\n\t    var outrec = this.m_PolyOuts[i++];\n\t    var op = outrec.Pts;\n\t    if (op === null)\n\t      continue;\n\t    do //for each Pt in Polygon until duplicate found do ...\n\t    {\n\t      var op2 = op.Next;\n\t      while (op2 != outrec.Pts)\n\t      {\n\t        if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n\t        {\n\t          //split the polygon into two ...\n\t          var op3 = op.Prev;\n\t          var op4 = op2.Prev;\n\t          op.Prev = op4;\n\t          op4.Next = op;\n\t          op2.Prev = op3;\n\t          op3.Next = op2;\n\t          outrec.Pts = op;\n\t          var outrec2 = this.CreateOutRec();\n\t          outrec2.Pts = op2;\n\t          this.UpdateOutPtIdxs(outrec2);\n\t          if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t          {\n\t            //OutRec2 is contained by OutRec1 ...\n\t            outrec2.IsHole = !outrec.IsHole;\n\t            outrec2.FirstLeft = outrec;\n\t          }\n\t          else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t          {\n\t            //OutRec1 is contained by OutRec2 ...\n\t            outrec2.IsHole = outrec.IsHole;\n\t            outrec.IsHole = !outrec2.IsHole;\n\t            outrec2.FirstLeft = outrec.FirstLeft;\n\t            outrec.FirstLeft = outrec2;\n\t          }\n\t          else\n\t          {\n\t            //the 2 polygons are separate ...\n\t            outrec2.IsHole = outrec.IsHole;\n\t            outrec2.FirstLeft = outrec.FirstLeft;\n\t          }\n\t          op2 = op;\n\t          //ie get ready for the next iteration\n\t        }\n\t        op2 = op2.Next;\n\t      }\n\t      op = op.Next;\n\t    }\n\t    while (op != outrec.Pts)\n\t  }\n\t};\n\tClipperLib.Clipper.Area = function (poly)\n\t{\n\t  var cnt = poly.length;\n\t  if (cnt < 3)\n\t    return 0;\n\t  var a = 0;\n\t  for (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t  {\n\t    a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t    j = i;\n\t  }\n\t  return -a * 0.5;\n\t};\n\tClipperLib.Clipper.prototype.Area = function (outRec)\n\t{\n\t  var op = outRec.Pts;\n\t  if (op == null)\n\t    return 0;\n\t  var a = 0;\n\t  do {\n\t    a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t    op = op.Next;\n\t  }\n\t  while (op != outRec.Pts)\n\t  return a * 0.5;\n\t};\n\tif (use_deprecated)\n\t{\n\t  ClipperLib.Clipper.OffsetPaths = function (polys, delta, jointype, endtype, MiterLimit)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    var co = new ClipperLib.ClipperOffset(MiterLimit, MiterLimit);\n\t    co.AddPaths(polys, jointype, endtype);\n\t    co.Execute(result, delta);\n\t    return result;\n\t  };\n\t}\n\tClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t{\n\t  var result = new Array();\n\t  var c = new ClipperLib.Clipper(0);\n\t  c.StrictlySimple = true;\n\t  c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t  return result;\n\t};\n\tClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t{\n\t  if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t  var result = new Array();\n\t  var c = new ClipperLib.Clipper(0);\n\t  c.StrictlySimple = true;\n\t  c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t  return result;\n\t};\n\tClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t{\n\t  var dx = (pt1.X - pt2.X);\n\t  var dy = (pt1.Y - pt2.Y);\n\t  return (dx * dx + dy * dy);\n\t};\n\tClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t{\n\t  //The equation of a line in general form (Ax + By + C = 0)\n\t  //given 2 points (x,y) & (x,y) is ...\n\t  //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n\t  //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n\t  //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n\t  //see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t  var A = ln1.Y - ln2.Y;\n\t  var B = ln2.X - ln1.X;\n\t  var C = A * ln1.X + B * ln1.Y;\n\t  C = A * pt.X + B * pt.Y - C;\n\t  return (C * C) / (A * A + B * B);\n\t};\n\tClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)\n\t{\n\t  return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t};\n\tClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t{\n\t  var dx = pt1.X - pt2.X;\n\t  var dy = pt1.Y - pt2.Y;\n\t  return ((dx * dx) + (dy * dy) <= distSqrd);\n\t};\n\t//------------------------------------------------------------------------------\n\tClipperLib.Clipper.ExcludeOp = function (op)\n\t{\n\t  var result = op.Prev;\n\t  result.Next = op.Next;\n\t  op.Next.Prev = result;\n\t  result.Idx = 0;\n\t  return result;\n\t};\n\tClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t{\n\t  if (typeof (distance) == \"undefined\") distance = 1.415;\n\t  //distance = proximity in units/pixels below which vertices will be stripped. \n\t  //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have \n\t  //both x & y coords within 1 unit, then the second vertex will be stripped.\n\t  var cnt = path.length;\n\t  if (cnt == 0)\n\t    return new Array();\n\t  var outPts = new Array(cnt);\n\t  for (var i = 0; i < cnt; ++i)\n\t    outPts[i] = new ClipperLib.OutPt();\n\t  for (var i = 0; i < cnt; ++i)\n\t  {\n\t    outPts[i].Pt = path[i];\n\t    outPts[i].Next = outPts[(i + 1) % cnt];\n\t    outPts[i].Next.Prev = outPts[i];\n\t    outPts[i].Idx = 0;\n\t  }\n\t  var distSqrd = distance * distance;\n\t  var op = outPts[0];\n\t  while (op.Idx == 0 && op.Next != op.Prev)\n\t  {\n\t    if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t    {\n\t      op = ClipperLib.Clipper.ExcludeOp(op);\n\t      cnt--;\n\t    }\n\t    else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t    {\n\t      ClipperLib.Clipper.ExcludeOp(op.Next);\n\t      op = ClipperLib.Clipper.ExcludeOp(op);\n\t      cnt -= 2;\n\t    }\n\t    else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t    {\n\t      op = ClipperLib.Clipper.ExcludeOp(op);\n\t      cnt--;\n\t    }\n\t    else\n\t    {\n\t      op.Idx = 1;\n\t      op = op.Next;\n\t    }\n\t  }\n\t  if (cnt < 3)\n\t    cnt = 0;\n\t  var result = new Array(cnt);\n\t  for (var i = 0; i < cnt; ++i)\n\t  {\n\t    result[i] = new ClipperLib.IntPoint(op.Pt);\n\t    op = op.Next;\n\t  }\n\t  outPts = null;\n\t  return result;\n\t};\n\tClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t{\n\t  var result = new Array(polys.length);\n\t  for (var i = 0, ilen = polys.length; i < ilen; i++)\n\t    result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t  return result;\n\t};\n\tClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t{\n\t  var delta = (IsClosed ? 1 : 0);\n\t  var polyCnt = pattern.length;\n\t  var pathCnt = path.length;\n\t  var result = new Array();\n\t  if (IsSum)\n\t    for (var i = 0; i < pathCnt; i++)\n\t    {\n\t      var p = new Array(polyCnt);\n\t      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t        p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\t      result.push(p);\n\t    }\n\t  else\n\t    for (var i = 0; i < pathCnt; i++)\n\t    {\n\t      var p = new Array(polyCnt);\n\t      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t        p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\t      result.push(p);\n\t    }\n\t  var quads = new Array();\n\t  for (var i = 0; i < pathCnt - 1 + delta; i++)\n\t    for (var j = 0; j < polyCnt; j++)\n\t    {\n\t      var quad = new Array();\n\t      quad.push(result[i % pathCnt][j % polyCnt]);\n\t      quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t      quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t      quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t      if (!ClipperLib.Clipper.Orientation(quad))\n\t        quad.reverse();\n\t      quads.push(quad);\n\t    }\n\t  var c = new ClipperLib.Clipper(0);\n\t  c.AddPaths(quads, ClipperLib.PolyType.ptSubject, true);\n\t  c.Execute(ClipperLib.ClipType.ctUnion, result, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t  return result;\n\t};\n\t\n\tClipperLib.Clipper.MinkowskiSum = function ()\n\t{\n\t  var a = arguments,\n\t    alen = a.length;\n\t  if (alen == 3) // MinkowskiSum(Path pattern, path, pathIsClosed)\n\t  {\n\t    var pattern = a[0],\n\t      path = a[1],\n\t      pathIsClosed = a[2];\n\t    return ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t  }\n\t  else if (alen == 4) // MinkowskiSum(pattern, paths, pathFillType, pathIsClosed)\n\t  {\n\t    var pattern = a[0],\n\t      paths = a[1],\n\t      pathFillType = a[2],\n\t      pathIsClosed = a[3];\n\t    var c = new ClipperLib.Clipper(),\n\t      tmp;\n\t    for (var i = 0, ilen = paths.length; i < ilen; ++i)\n\t    {\n\t      var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t      c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t    }\n\t    if (pathIsClosed) c.AddPaths(paths, ClipperLib.PolyType.ptClip, true);\n\t    var solution = new ClipperLib.Paths();\n\t    c.Execute(ClipperLib.ClipType.ctUnion, solution, pathFillType, pathFillType);\n\t    return solution;\n\t  }\n\t};\n\t\n\tClipperLib.Clipper.MinkowskiDiff = function (pattern, path, pathIsClosed)\n\t{\n\t  return ClipperLib.Clipper.Minkowski(pattern, path, false, pathIsClosed);\n\t};\n\t\n\tClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t{\n\t  var result = new Array();\n\t  //result.set_Capacity(polytree.get_Total());\n\t  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t  return result;\n\t};\n\tClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t{\n\t  var match = true;\n\t  switch (nt)\n\t  {\n\t  case ClipperLib.Clipper.NodeType.ntOpen:\n\t    return;\n\t  case ClipperLib.Clipper.NodeType.ntClosed:\n\t    match = !polynode.IsOpen;\n\t    break;\n\t  default:\n\t    break;\n\t  }\n\t  if (polynode.m_polygon.length > 0 && match)\n\t    paths.push(polynode.m_polygon);\n\t  for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t};\n\tClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t{\n\t  var result = new ClipperLib.Paths();\n\t  //result.set_Capacity(polytree.ChildCount());\n\t  for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t    if (polytree.Childs()[i].IsOpen)\n\t      result.push(polytree.Childs()[i].m_polygon);\n\t  return result;\n\t};\n\tClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t{\n\t  var result = new ClipperLib.Paths();\n\t  //result.set_Capacity(polytree.Total());\n\t  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t  return result;\n\t};\n\tInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\tClipperLib.Clipper.NodeType = {\n\t  ntAny: 0,\n\t  ntOpen: 1,\n\t  ntClosed: 2\n\t};\n\tClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t{\n\t  if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n\t  if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t  this.m_destPolys = new ClipperLib.Paths();\n\t  this.m_srcPoly = new ClipperLib.Path();\n\t  this.m_destPoly = new ClipperLib.Path();\n\t  this.m_normals = new Array();\n\t  this.m_delta = 0;\n\t  this.m_sinA = 0;\n\t  this.m_sin = 0;\n\t  this.m_cos = 0;\n\t  this.m_miterLim = 0;\n\t  this.m_StepsPerRad = 0;\n\t  this.m_lowest = new ClipperLib.IntPoint();\n\t  this.m_polyNodes = new ClipperLib.PolyNode();\n\t  this.MiterLimit = miterLimit;\n\t  this.ArcTolerance = arcTolerance;\n\t  this.m_lowest.X = -1;\n\t};\n\tClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\tClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\tClipperLib.ClipperOffset.prototype.Clear = function ()\n\t{\n\t  ClipperLib.Clear(this.m_polyNodes.Childs());\n\t  this.m_lowest.X = -1;\n\t};\n\tClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\tClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t{\n\t  var highI = path.length - 1;\n\t  if (highI < 0)\n\t    return;\n\t  var newNode = new ClipperLib.PolyNode();\n\t  newNode.m_jointype = joinType;\n\t  newNode.m_endtype = endType;\n\t  //strip duplicate points from path and also get index to the lowest point ...\n\t  if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n\t    while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t      highI--;\n\t  //newNode.m_polygon.set_Capacity(highI + 1);\n\t  newNode.m_polygon.push(path[0]);\n\t  var j = 0,\n\t    k = 0;\n\t  for (var i = 1; i <= highI; i++)\n\t    if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t    {\n\t      j++;\n\t      newNode.m_polygon.push(path[i]);\n\t      if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t        k = j;\n\t    }\n\t  if ((endType == ClipperLib.EndType.etClosedPolygon && j < 2) || (endType != ClipperLib.EndType.etClosedPolygon && j < 0))\n\t    return;\n\t  this.m_polyNodes.AddChild(newNode);\n\t  //if this path's lowest pt is lower than all the others then update m_lowest\n\t  if (endType != ClipperLib.EndType.etClosedPolygon)\n\t    return;\n\t  if (this.m_lowest.X < 0)\n\t    this.m_lowest = new ClipperLib.IntPoint(0, k);\n\t  else\n\t  {\n\t    var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t    if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n\t      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t  }\n\t};\n\tClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t{\n\t  for (var i = 0, ilen = paths.length; i < ilen; i++)\n\t    this.AddPath(paths[i], joinType, endType);\n\t};\n\tClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t{\n\t  //fixup orientations of all closed paths if the orientation of the\n\t  //closed path with the lowermost vertex is wrong ...\n\t  if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t  {\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t        node.m_polygon.reverse();\n\t    }\n\t  }\n\t  else\n\t  {\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t        node.m_polygon.reverse();\n\t    }\n\t  }\n\t};\n\tClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t{\n\t  var dx = (pt2.X - pt1.X);\n\t  var dy = (pt2.Y - pt1.Y);\n\t  if ((dx == 0) && (dy == 0))\n\t    return new ClipperLib.DoublePoint(0, 0);\n\t  var f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t  dx *= f;\n\t  dy *= f;\n\t  return new ClipperLib.DoublePoint(dy, -dx);\n\t};\n\tClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t{\n\t  this.m_destPolys = new Array();\n\t  this.m_delta = delta;\n\t  //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t  if (ClipperLib.ClipperBase.near_zero(delta))\n\t  {\n\t    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t        this.m_destPolys.push(node.m_polygon);\n\t    }\n\t    return;\n\t  }\n\t  //see offset_triginometry3.svg in the documentation folder ...\n\t  if (this.MiterLimit > 2)\n\t    this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t  else\n\t    this.m_miterLim = 0.5;\n\t  var y;\n\t  if (this.ArcTolerance <= 0)\n\t    y = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t  else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t    y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t  else\n\t    y = this.ArcTolerance;\n\t  //see offset_triginometry2.svg in the documentation folder ...\n\t  var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t  this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t  this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t  this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t  if (delta < 0)\n\t    this.m_sin = -this.m_sin;\n\t  //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t  for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t  {\n\t    var node = this.m_polyNodes.Childs()[i];\n\t    this.m_srcPoly = node.m_polygon;\n\t    var len = this.m_srcPoly.length;\n\t    if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n\t      continue;\n\t    this.m_destPoly = new Array();\n\t    if (len == 1)\n\t    {\n\t      if (node.m_jointype == ClipperLib.JoinType.jtRound)\n\t      {\n\t        var X = 1,\n\t          Y = 0;\n\t        for (var j = 1; j <= steps; j++)\n\t        {\n\t          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t          var X2 = X;\n\t          X = X * this.m_cos - this.m_sin * Y;\n\t          Y = X2 * this.m_sin + Y * this.m_cos;\n\t        }\n\t      }\n\t      else\n\t      {\n\t        var X = -1,\n\t          Y = -1;\n\t        for (var j = 0; j < 4; ++j)\n\t        {\n\t          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t          if (X < 0)\n\t            X = 1;\n\t          else if (Y < 0)\n\t            Y = 1;\n\t          else\n\t            X = -1;\n\t        }\n\t      }\n\t      this.m_destPolys.push(this.m_destPoly);\n\t      continue;\n\t    }\n\t    //build m_normals ...\n\t    this.m_normals.length = 0;\n\t    //this.m_normals.set_Capacity(len);\n\t    for (var j = 0; j < len - 1; j++)\n\t      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t    if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t    else\n\t      this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\t    if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t    {\n\t      var k = len - 1;\n\t      for (var j = 0; j < len; j++)\n\t        k = this.OffsetPoint(j, k, node.m_jointype);\n\t      this.m_destPolys.push(this.m_destPoly);\n\t    }\n\t    else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n\t    {\n\t      var k = len - 1;\n\t      for (var j = 0; j < len; j++)\n\t        k = this.OffsetPoint(j, k, node.m_jointype);\n\t      this.m_destPolys.push(this.m_destPoly);\n\t      this.m_destPoly = new Array();\n\t      //re-build m_normals ...\n\t      var n = this.m_normals[len - 1];\n\t      for (var j = len - 1; j > 0; j--)\n\t        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t      this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n\t      k = 0;\n\t      for (var j = len - 1; j >= 0; j--)\n\t        k = this.OffsetPoint(j, k, node.m_jointype);\n\t      this.m_destPolys.push(this.m_destPoly);\n\t    }\n\t    else\n\t    {\n\t      var k = 0;\n\t      for (var j = 1; j < len - 1; ++j)\n\t        k = this.OffsetPoint(j, k, node.m_jointype);\n\t      var pt1;\n\t      if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t      {\n\t        var j = len - 1;\n\t        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t        this.m_destPoly.push(pt1);\n\t        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t        this.m_destPoly.push(pt1);\n\t      }\n\t      else\n\t      {\n\t        var j = len - 1;\n\t        k = len - 2;\n\t        this.m_sinA = 0;\n\t        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t          this.DoSquare(j, k);\n\t        else\n\t          this.DoRound(j, k);\n\t      }\n\t      //re-build m_normals ...\n\t      for (var j = len - 1; j > 0; j--)\n\t        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t      this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t      k = len - 1;\n\t      for (var j = k - 1; j > 0; --j)\n\t        k = this.OffsetPoint(j, k, node.m_jointype);\n\t      if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t      {\n\t        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t        this.m_destPoly.push(pt1);\n\t        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t        this.m_destPoly.push(pt1);\n\t      }\n\t      else\n\t      {\n\t        k = 1;\n\t        this.m_sinA = 0;\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t          this.DoSquare(0, 1);\n\t        else\n\t          this.DoRound(0, 1);\n\t      }\n\t      this.m_destPolys.push(this.m_destPoly);\n\t    }\n\t  }\n\t};\n\tClipperLib.ClipperOffset.prototype.Execute = function ()\n\t{\n\t  var a = arguments,\n\t    ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t  if (!ispolytree) // function (solution, delta)\n\t  {\n\t    var solution = a[0],\n\t      delta = a[1];\n\t    ClipperLib.Clear(solution);\n\t    this.FixOrientations();\n\t    this.DoOffset(delta);\n\t    //now clean up 'corners' ...\n\t    var clpr = new ClipperLib.Clipper(0);\n\t    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t    if (delta > 0)\n\t    {\n\t      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t    }\n\t    else\n\t    {\n\t      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t      var outer = new ClipperLib.Path();\n\t      outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t      outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t      outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t      outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t      clpr.ReverseSolution = true;\n\t      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t      if (solution.length > 0)\n\t        solution.splice(0, 1);\n\t    }\n\t    //console.log(JSON.stringify(solution));\n\t  }\n\t  else // function (polytree, delta)\n\t  {\n\t    var solution = a[0],\n\t      delta = a[1];\n\t    solution.Clear();\n\t    this.FixOrientations();\n\t    this.DoOffset(delta);\n\t    //now clean up 'corners' ...\n\t    var clpr = new ClipperLib.Clipper(0);\n\t    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t    if (delta > 0)\n\t    {\n\t      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t    }\n\t    else\n\t    {\n\t      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t      var outer = new ClipperLib.Path();\n\t      outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t      outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t      outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t      outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t      clpr.ReverseSolution = true;\n\t      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t      //remove the outer PolyNode rectangle ...\n\t      if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n\t      {\n\t        var outerNode = solution.Childs()[0];\n\t        //solution.Childs.set_Capacity(outerNode.ChildCount);\n\t        solution.Childs()[0] = outerNode.Childs()[0];\n\t        for (var i = 1; i < outerNode.ChildCount(); i++)\n\t          solution.AddChild(outerNode.Childs()[i]);\n\t      }\n\t      else\n\t        solution.Clear();\n\t    }\n\t  }\n\t};\n\tClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t{\n\t  this.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\t  if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)\n\t    return k;\n\t  else if (this.m_sinA > 1)\n\t    this.m_sinA = 1.0;\n\t  else if (this.m_sinA < -1)\n\t    this.m_sinA = -1.0;\n\t  if (this.m_sinA * this.m_delta < 0)\n\t  {\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t  }\n\t  else\n\t    switch (jointype)\n\t    {\n\t    case ClipperLib.JoinType.jtMiter:\n\t      {\n\t        var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t        if (r >= this.m_miterLim)\n\t          this.DoMiter(j, k, r);\n\t        else\n\t          this.DoSquare(j, k);\n\t        break;\n\t      }\n\t    case ClipperLib.JoinType.jtSquare:\n\t      this.DoSquare(j, k);\n\t      break;\n\t    case ClipperLib.JoinType.jtRound:\n\t      this.DoRound(j, k);\n\t      break;\n\t    }\n\t  k = j;\n\t  return k;\n\t};\n\tClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t{\n\t  var dx = Math.tan(Math.atan2(this.m_sinA,\n\t    this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t  this.m_destPoly.push(new ClipperLib.IntPoint(\n\t    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t  this.m_destPoly.push(new ClipperLib.IntPoint(\n\t    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t};\n\tClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t{\n\t  var q = this.m_delta / r;\n\t  this.m_destPoly.push(new ClipperLib.IntPoint(\n\t    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t};\n\tClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t{\n\t  var a = Math.atan2(this.m_sinA,\n\t    this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\t  var steps = ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a)));\n\t  var X = this.m_normals[k].X,\n\t    Y = this.m_normals[k].Y,\n\t    X2;\n\t  for (var i = 0; i < steps; ++i)\n\t  {\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t    X2 = X;\n\t    X = X * this.m_cos - this.m_sin * Y;\n\t    Y = X2 * this.m_sin + Y * this.m_cos;\n\t  }\n\t  this.m_destPoly.push(new ClipperLib.IntPoint(\n\t    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t};\n\tClipperLib.Error = function (message)\n\t{\n\t  try\n\t  {\n\t    throw new Error(message);\n\t  }\n\t  catch (err)\n\t  {\n\t    alert(err.message);\n\t  }\n\t};\n\t// ---------------------------------\n\t// JS extension by Timo 2013\n\tClipperLib.JS = {};\n\tClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t{\n\t  if (!scale) scale = 1;\n\t  return ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t};\n\tClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t{\n\t  if (!scale) scale = 1;\n\t  var area = 0;\n\t  for (var i = 0; i < poly.length; i++)\n\t  {\n\t    area += ClipperLib.Clipper.Area(poly[i]);\n\t  }\n\t  return area / (scale * scale);\n\t};\n\tClipperLib.JS.BoundsOfPath = function (path, scale)\n\t{\n\t  return ClipperLib.JS.BoundsOfPaths([path], scale);\n\t};\n\tClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t{\n\t  if (!scale) scale = 1;\n\t  var bounds = ClipperLib.Clipper.GetBounds(paths);\n\t  bounds.left /= scale;\n\t  bounds.bottom /= scale;\n\t  bounds.right /= scale;\n\t  bounds.top /= scale;\n\t  return bounds;\n\t};\n\t// Clean() joins vertices that are too near each other\n\t// and causes distortion to offsetted polygons without cleaning\n\tClipperLib.JS.Clean = function (polygon, delta)\n\t{\n\t  if (!(polygon instanceof Array)) return [];\n\t  var isPolygons = polygon[0] instanceof Array;\n\t  var polygon = ClipperLib.JS.Clone(polygon);\n\t  if (typeof delta != \"number\" || delta === null)\n\t  {\n\t    ClipperLib.Error(\"Delta is not a number in Clean().\");\n\t    return polygon;\n\t  }\n\t  if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t  if (!isPolygons) polygon = [polygon];\n\t  var k_length = polygon.length;\n\t  var len, poly, result, d, p, j, i;\n\t  var results = [];\n\t  for (var k = 0; k < k_length; k++)\n\t  {\n\t    poly = polygon[k];\n\t    len = poly.length;\n\t    if (len === 0) continue;\n\t    else if (len < 3)\n\t    {\n\t      result = poly;\n\t      results.push(result);\n\t      continue;\n\t    }\n\t    result = poly;\n\t    d = delta * delta;\n\t    //d = Math.floor(c_delta * c_delta);\n\t    p = poly[0];\n\t    j = 1;\n\t    for (i = 1; i < len; i++)\n\t    {\n\t      if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t        (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t        continue;\n\t      result[j] = poly[i];\n\t      p = poly[i];\n\t      j++;\n\t    }\n\t    p = poly[j - 1];\n\t    if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t      (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t      j--;\n\t    if (j < len)\n\t      result.splice(j, len - j);\n\t    if (result.length) results.push(result);\n\t  }\n\t  if (!isPolygons && results.length) results = results[0];\n\t  else if (!isPolygons && results.length === 0) results = [];\n\t  else if (isPolygons && results.length === 0) results = [\n\t    []\n\t  ];\n\t  return results;\n\t}\n\t// Make deep copy of Polygons or Polygon\n\t// so that also IntPoint objects are cloned and not only referenced\n\t// This should be the fastest way\n\tClipperLib.JS.Clone = function (polygon)\n\t{\n\t  if (!(polygon instanceof Array)) return [];\n\t  if (polygon.length === 0) return [];\n\t  else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n\t  var isPolygons = polygon[0] instanceof Array;\n\t  if (!isPolygons) polygon = [polygon];\n\t  var len = polygon.length,\n\t    plen, i, j, result;\n\t  var results = new Array(len);\n\t  for (i = 0; i < len; i++)\n\t  {\n\t    plen = polygon[i].length;\n\t    result = new Array(plen);\n\t    for (j = 0; j < plen; j++)\n\t    {\n\t      result[j] = {\n\t        X: polygon[i][j].X,\n\t        Y: polygon[i][j].Y\n\t      };\n\t    }\n\t    results[i] = result;\n\t  }\n\t  if (!isPolygons) results = results[0];\n\t  return results;\n\t};\n\t// Removes points that doesn't affect much to the visual appearance.\n\t// If middle point is at or under certain distance (tolerance) of the line segment between \n\t// start and end point, the middle point is removed.\n\tClipperLib.JS.Lighten = function (polygon, tolerance)\n\t{\n\t  if (!(polygon instanceof Array)) return [];\n\t  if (typeof tolerance != \"number\" || tolerance === null)\n\t  {\n\t    ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t    return ClipperLib.JS.Clone(polygon);\n\t  }\n\t  if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n\t  {\n\t    return ClipperLib.JS.Clone(polygon);\n\t  }\n\t  if (!(polygon[0] instanceof Array)) polygon = [polygon];\n\t  var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t  var bxax, byay, l, ax, ay;\n\t  var len = polygon.length;\n\t  var toleranceSq = tolerance * tolerance;\n\t  var results = [];\n\t  for (i = 0; i < len; i++)\n\t  {\n\t    poly = polygon[i];\n\t    plen = poly.length;\n\t    if (plen == 0) continue;\n\t    for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t    {\n\t      poly2 = [];\n\t      plen = poly.length;\n\t      // the first have to added to the end, if first and last are not the same\n\t      // this way we ensure that also the actual last point can be removed if needed\n\t      if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n\t      {\n\t        addlast = 1;\n\t        poly.push(\n\t        {\n\t          X: poly[0].X,\n\t          Y: poly[0].Y\n\t        });\n\t        plen = poly.length;\n\t      }\n\t      else addlast = 0;\n\t      rem = []; // Indexes of removed points\n\t      for (j = 0; j < plen - 2; j++)\n\t      {\n\t        A = poly[j]; // Start point of line segment\n\t        P = poly[j + 1]; // Middle point. This is the one to be removed.\n\t        B = poly[j + 2]; // End point of line segment\n\t        ax = A.X;\n\t        ay = A.Y;\n\t        bxax = B.X - ax;\n\t        byay = B.Y - ay;\n\t        if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t        {\n\t          l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t          if (l > 1)\n\t          {\n\t            ax = B.X;\n\t            ay = B.Y;\n\t          }\n\t          else if (l > 0)\n\t          {\n\t            ax += bxax * l;\n\t            ay += byay * l;\n\t          }\n\t        }\n\t        bxax = P.X - ax;\n\t        byay = P.Y - ay;\n\t        d = bxax * bxax + byay * byay;\n\t        if (d <= toleranceSq)\n\t        {\n\t          rem[j + 1] = 1;\n\t          j++; // when removed, transfer the pointer to the next one\n\t        }\n\t      }\n\t      // add all unremoved points to poly2\n\t      poly2.push(\n\t      {\n\t        X: poly[0].X,\n\t        Y: poly[0].Y\n\t      });\n\t      for (j = 1; j < plen - 1; j++)\n\t        if (!rem[j]) poly2.push(\n\t        {\n\t          X: poly[j].X,\n\t          Y: poly[j].Y\n\t        });\n\t      poly2.push(\n\t      {\n\t        X: poly[plen - 1].X,\n\t        Y: poly[plen - 1].Y\n\t      });\n\t      // if the first point was added to the end, remove it\n\t      if (addlast) poly.pop();\n\t      // break, if there was not anymore removed points\n\t      if (!rem.length) break;\n\t      // else continue looping using poly2, to check if there are points to remove\n\t      else poly = poly2;\n\t    }\n\t    plen = poly2.length;\n\t    // remove duplicate from end, if needed\n\t    if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n\t    {\n\t      poly2.pop();\n\t    }\n\t    if (poly2.length > 2) // to avoid two-point-polygons\n\t      results.push(poly2);\n\t  }\n\t  if (!polygon[0] instanceof Array) results = results[0];\n\t  if (typeof (results) == \"undefined\") results = [\n\t    []\n\t  ];\n\t  return results;\n\t}\n\tClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t{\n\t  if (typeof (path) == \"undefined\") return 0;\n\t  var sqrt = Math.sqrt;\n\t  var perimeter = 0.0;\n\t  var p1, p2, p1x = 0.0,\n\t    p1y = 0.0,\n\t    p2x = 0.0,\n\t    p2y = 0.0;\n\t  var j = path.length;\n\t  if (j < 2) return 0;\n\t  if (closed)\n\t  {\n\t    path[j] = path[0];\n\t    j++;\n\t  }\n\t  while (--j)\n\t  {\n\t    p1 = path[j];\n\t    p1x = p1.X;\n\t    p1y = p1.Y;\n\t    p2 = path[j - 1];\n\t    p2x = p2.X;\n\t    p2y = p2.Y;\n\t    perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t  }\n\t  if (closed) path.pop();\n\t  return perimeter / scale;\n\t};\n\tClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t{\n\t  if (!scale) scale = 1;\n\t  var perimeter = 0;\n\t  for (var i = 0; i < paths.length; i++)\n\t  {\n\t    perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t  }\n\t  return perimeter;\n\t};\n\tClipperLib.JS.ScaleDownPath = function (path, scale)\n\t{\n\t  var i, p;\n\t  if (!scale) scale = 1;\n\t  i = path.length;\n\t  while (i--)\n\t  {\n\t    p = path[i];\n\t    p.X = p.X / scale;\n\t    p.Y = p.Y / scale;\n\t  }\n\t};\n\tClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t{\n\t  var i, j, p, round = Math.round;\n\t  if (!scale) scale = 1;\n\t  i = paths.length;\n\t  while (i--)\n\t  {\n\t    j = paths[i].length;\n\t    while (j--)\n\t    {\n\t      p = paths[i][j];\n\t      p.X = p.X / scale;\n\t      p.Y = p.Y / scale;\n\t    }\n\t  }\n\t};\n\tClipperLib.JS.ScaleUpPath = function (path, scale)\n\t{\n\t  var i, p, round = Math.round;\n\t  if (!scale) scale = 1;\n\t  i = path.length;\n\t  while (i--)\n\t  {\n\t    p = path[i];\n\t    p.X = round(p.X * scale);\n\t    p.Y = round(p.Y * scale);\n\t  }\n\t};\n\tClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t{\n\t  var i, j, p, round = Math.round;\n\t  if (!scale) scale = 1;\n\t  i = paths.length;\n\t  while (i--)\n\t  {\n\t    j = paths[i].length;\n\t    while (j--)\n\t    {\n\t      p = paths[i][j];\n\t      p.X = round(p.X * scale);\n\t      p.Y = round(p.Y * scale);\n\t    }\n\t  }\n\t};\n\tClipperLib.ExPolygons = function ()\n\t{\n\t  return [];\n\t}\n\tClipperLib.ExPolygon = function ()\n\t{\n\t  this.outer = null;\n\t  this.holes = null;\n\t};\n\tClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t{\n\t  var ep = new ClipperLib.ExPolygon();\n\t  ep.outer = polynode.Contour();\n\t  var childs = polynode.Childs();\n\t  var ilen = childs.length;\n\t  ep.holes = new Array(ilen);\n\t  var node, n, i, j, childs2, jlen;\n\t  for (i = 0; i < ilen; i++)\n\t  {\n\t    node = childs[i];\n\t    ep.holes[i] = node.Contour();\n\t    //Add outer polygons contained by (nested within) holes ...\n\t    for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t    {\n\t      n = childs2[j];\n\t      ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t    }\n\t  }\n\t  expolygons.push(ep);\n\t};\n\tClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t{\n\t  var a, i, alen, ilen;\n\t  var paths = new ClipperLib.Paths();\n\t  for (a = 0, alen = expolygons.length; a < alen; a++)\n\t  {\n\t    paths.push(expolygons[a].outer);\n\t    for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t    {\n\t      paths.push(expolygons[a].holes[i]);\n\t    }\n\t  }\n\t  return paths;\n\t}\n\tClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t{\n\t  var expolygons = new ClipperLib.ExPolygons();\n\t  var node, i, childs, ilen;\n\t  for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t  {\n\t    node = childs[i];\n\t    ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t  }\n\t  return expolygons;\n\t};\n\t\n\t\n\tmodule.exports = ClipperLib;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 4 */,\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar L = __webpack_require__(1);\n\t\n\tvar MinZoomIndicator = L.Control.extend({\n\t\n\t    options: {},\n\t\n\t    _layers: {},\n\t\n\t    initialize: function initialize(options) {\n\t\n\t        L.Util.setOptions(this, options);\n\t\n\t        this._layers = {};\n\t    },\n\t\n\t    _addLayer: function _addLayer(layer) {\n\t\n\t        var minZoom = 15;\n\t\n\t        if (layer.options.minZoom) {\n\t\n\t            minZoom = layer.options.minZoom;\n\t        }\n\t\n\t        this._layers[layer._leaflet_id] = minZoom;\n\t\n\t        this._updateBox(null);\n\t    },\n\t\n\t    _removeLayer: function _removeLayer(layer) {\n\t\n\t        this._layers[layer._leaflet_id] = null;\n\t\n\t        this._updateBox(null);\n\t    },\n\t\n\t    _getMinZoomLevel: function _getMinZoomLevel() {\n\t\n\t        var key,\n\t            minZoomLevel = -1;\n\t\n\t        for (key in this._layers) {\n\t\n\t            if (this._layers[key] !== null && this._layers[key] > minZoomLevel) {\n\t\n\t                minZoomLevel = this._layers[key];\n\t            }\n\t        }\n\t\n\t        return minZoomLevel;\n\t    },\n\t\n\t    _updateBox: function _updateBox(event) {\n\t\n\t        var minZoomLevel = this._getMinZoomLevel();\n\t\n\t        if (event !== null) {\n\t\n\t            L.DomEvent.preventDefault(event);\n\t        }\n\t\n\t        if (minZoomLevel == -1) {\n\t\n\t            this._container.innerHTML = this.options.minZoomMessageNoLayer;\n\t        } else {\n\t\n\t            this._container.innerHTML = this.options.minZoomMessage.replace(/CURRENTZOOM/, this._map.getZoom()).replace(/MINZOOMLEVEL/, minZoomLevel);\n\t        }\n\t\n\t        if (this._map.getZoom() >= minZoomLevel) {\n\t\n\t            this._container.style.display = 'none';\n\t        } else {\n\t\n\t            this._container.style.display = 'block';\n\t        }\n\t    },\n\t\n\t    onAdd: function onAdd(map) {\n\t\n\t        this._map = map;\n\t\n\t        this._map.zoomIndicator = this;\n\t\n\t        this._container = L.DomUtil.create('div', 'leaflet-control-minZoomIndicator');\n\t\n\t        this._map.on('moveend', this._updateBox, this);\n\t\n\t        this._updateBox(null);\n\t\n\t        return this._container;\n\t    },\n\t\n\t    onRemove: function onRemove(map) {\n\t\n\t        L.Control.prototype.onRemove.call(this, map);\n\t\n\t        map.off({\n\t\n\t            'moveend': this._updateBox\n\t        }, this);\n\t\n\t        this._map = null;\n\t    }\n\t});\n\t\n\tL.Control.MinZoomIndicator = MinZoomIndicator;\n\tmodule.exports = MinZoomIndicator;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// OverPassLayer.bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b1b0e3b7e8441ec283a5","\nvar L = require('leaflet');\nvar ClipperLib = require('js-clipper');\nvar css = require('./OverPassLayer.css');\nvar MinZoomIndicator = require('./MinZoomIndicator');\n\nvar OverPassLayer = L.FeatureGroup.extend({\n\n    options: {\n\n        'debug': false,\n        'minZoom': 15,\n        'endPoint': 'https://overpass-api.de/api/',\n        'query': '(node({{bbox}})[organic];node({{bbox}})[second_hand];);out qt;',\n        'loadedBounds': [],\n        'markerIcon': null,\n        'timeout': 30 * 1000, // Milliseconds\n        'retryOnTimeout': false,\n        'noInitialRequest': false,\n        'noInitialRequest': false,\n\n        beforeRequest: function() {\n\n        },\n\n        afterRequest: function() {\n\n        },\n\n        onSuccess: function(data) {\n\n            for(var i = 0; i < data.elements.length; i++) {\n\n                var pos, popupContent, popup, marker,\n                e = data.elements[i];\n\n                if ( e.id in this._ids ) {\n\n                    continue;\n                }\n\n                this._ids[e.id] = true;\n\n                if ( e.type === 'node' ) {\n\n                    pos = new L.LatLng(e.lat, e.lon);\n                } else {\n\n                    pos = new L.LatLng(e.center.lat, e.center.lon);\n                }\n\n                if (this.options.markerIcon) {\n                    marker = L.marker(pos, { icon: this.options.markerIcon });\n                }\n                else {\n                    marker = L.circle(pos, 20, {\n                        'stroke': false,\n                        'fillColor': '#E54041',\n                        'fillOpacity': 0.9,\n                    });\n                }\n\n                popupContent = this._getPoiPopupHTML(e.tags, e.id);\n                popup = L.popup().setContent( popupContent );\n                marker.bindPopup(popup);\n\n                this._markers.addLayer(marker);\n            }\n        },\n\n        onError: function() {\n\n        },\n\n        onTimeout: function() {\n\n        },\n\n        minZoomIndicatorOptions: {\n\n            'minZoomMessageNoLayer': 'No layer assigned',\n            'minZoomMessage': 'Current zoom Level: CURRENTZOOM. Data are visible at Level: MINZOOMLEVEL.',\n        },\n    },\n\n    initialize: function (options) {\n\n        L.Util.setOptions(this, options);\n\n        this._ids = {};\n        this._loadedBounds = options.loadedBounds || [];\n        this._requestInProgress = false;\n    },\n\n    _getPoiPopupHTML: function(tags, id) {\n\n        var row,\n        link = document.createElement('a'),\n        table = document.createElement('table'),\n        div = document.createElement('div');\n\n        link.href = 'http://www.openstreetmap.org/edit?editor=id&node=' + id;\n        link.appendChild(document.createTextNode('Edit this entry in iD'));\n\n        table.style.borderSpacing = '10px';\n        table.style.borderCollapse = 'separate';\n\n        for (var key in tags){\n\n            row = table.insertRow(0);\n            row.insertCell(0).appendChild(document.createTextNode(key));\n            row.insertCell(1).appendChild(document.createTextNode(tags[key]));\n        }\n\n        div.appendChild(link);\n        div.appendChild(table);\n\n        return div;\n    },\n\n\n    _buildRequestBox: function (bounds) {\n\n        return L.rectangle(bounds, {\n            'bounds': bounds,\n            'color': '#204a87',\n            'stroke': false,\n            'fillOpacity': 0.1,\n            'clickable': false\n        });\n    },\n\n    _addRequestBox: function (box) {\n\n        return this._requestBoxes.addLayer( box );\n    },\n\n    _getRequestBoxes: function () {\n\n        return this._requestBoxes.getLayers();\n    },\n\n    _removeRequestBox: function (box) {\n\n        this._requestBoxes.removeLayer( box );\n    },\n\n    _removeRequestBoxes: function () {\n\n        return this._requestBoxes.clearLayers();\n    },\n\n    _addResponseBox: function (box) {\n\n        return this._responseBoxes.addLayer( box );\n    },\n\n    _addResponseBoxes: function (requestBoxes) {\n        var self = this,\n        count = requestBoxes.length;\n\n        this._removeRequestBoxes();\n\n        requestBoxes.forEach(function(box) {\n\n            box.setStyle({\n                'color': 'black',\n                'weight': 2\n            });\n            self._addResponseBox( box );\n        });\n    },\n\n\n    _isFullyLoadedBounds: function (bounds, loadedBounds) {\n\n        if (loadedBounds.length === 0) {\n            return false;\n        }\n\n        var solutionExPolygons,\n        subjectClips = this._buildClipsFromBounds([bounds]),\n        knownClips = this._buildClipsFromBounds(loadedBounds),\n        clipper = new ClipperLib.Clipper(),\n        solutionPolyTree = new ClipperLib.PolyTree();\n\n        clipper.AddPaths(subjectClips, ClipperLib.PolyType.ptSubject, true);\n        clipper.AddPaths(knownClips, ClipperLib.PolyType.ptClip, true);\n\n        clipper.Execute(\n            ClipperLib.ClipType.ctDifference,\n            solutionPolyTree,\n            ClipperLib.PolyFillType.pftNonZero,\n            ClipperLib.PolyFillType.pftNonZero\n        );\n\n        solutionExPolygons = ClipperLib.JS.PolyTreeToExPolygons(solutionPolyTree);\n\n        if (solutionExPolygons.length === 0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    },\n\n    _getLoadedBounds: function () {\n\n        return this._loadedBounds;\n    },\n\n    _addLoadedBounds: function (bounds) {\n\n        this._loadedBounds.push(bounds);\n    },\n\n    _buildClipsFromBounds: function (bounds) {\n\n        var clips = [];\n\n        bounds.forEach(function (bound) {\n            clips.push([\n                {\n                    'X': bound._southWest.lng * 1000000,\n                    'Y': bound._southWest.lat * 1000000\n                },\n                {\n                    'X': bound._southWest.lng * 1000000,\n                    'Y': bound._northEast.lat * 1000000\n                },\n                {\n                    'X': bound._northEast.lng * 1000000,\n                    'Y': bound._northEast.lat * 1000000\n                },\n                {\n                    'X': bound._northEast.lng * 1000000,\n                    'Y': bound._southWest.lat * 1000000\n                }\n            ]);\n        });\n\n        return clips;\n    },\n\n    _buildBoundsFromClips: function (clips) {\n\n        var bounds = [];\n\n        clips.forEach(function (clip) {\n            bounds.push(\n                new L.LatLngBounds(\n                    new L.LatLng(\n                        clip[0].Y / 1000000,\n                        clip[0].X / 1000000\n                    ),\n                    new L.LatLng(\n                        clip[2].Y / 1000000,\n                        clip[2].X / 1000000\n                    )\n                )\n            );\n        });\n\n        return bounds;\n    },\n\n\n    _buildOverpassQueryFromQueryAndBounds: function (query, bounds){\n\n        var sw = bounds._southWest,\n        ne = bounds._northEast,\n        coordinates = [sw.lat, sw.lng, ne.lat, ne.lng].join(',');\n\n        query = query.replace(/(\\/\\/.*)/g, '');\n        query = query.replace(/(\\{\\{bbox\\}\\})/g, coordinates);\n\n        return query;\n    },\n\n    _buildOverpassUrlFromEndPointAndQuery: function (endPoint, query){\n\n        return endPoint + 'interpreter?data=[out:json];'+ query;\n    },\n\n    _buildLargerBounds: function (bounds) {\n\n        var width = Math.abs( bounds._northEast.lng - bounds._southWest.lng ),\n        height = Math.abs( bounds._northEast.lat - bounds._southWest.lat ),\n        biggestDimension = (width > height) ? width : height;\n\n        bounds._southWest.lat -= biggestDimension / 2;\n        bounds._southWest.lng -= biggestDimension / 2;\n        bounds._northEast.lat += biggestDimension / 2;\n        bounds._northEast.lng += biggestDimension / 2;\n\n        return L.latLngBounds(\n            L.latLng(bounds._southWest.lat, bounds._southWest.lng),\n            L.latLng(bounds._northEast.lat, bounds._northEast.lng)\n        );\n    },\n\n    _setRequestInProgress: function (isInProgress) {\n\n        this._requestInProgress = isInProgress;\n    },\n\n    _isRequestInProgress: function () {\n\n        return this._requestInProgress;\n    },\n\n    _hasNextRequest: function () {\n\n        if ( this._nextRequest ) {\n\n            return true;\n        }\n\n        return false;\n    },\n\n    _getNextRequest: function (nextRequest) {\n\n        return this._nextRequest;\n    },\n\n    _setNextRequest: function (nextRequest) {\n\n        this._nextRequest = nextRequest;\n    },\n\n    _removeNextRequest: function () {\n\n        this._nextRequest = null;\n    },\n\n\t_prepareRequest: function () {\n\n        if (this._map.getZoom() < this.options.minZoom) {\n\n            return false;\n        }\n\n        var bounds = this._buildLargerBounds( this._map.getBounds() ),\n        nextRequest = this._sendRequest.bind(this, bounds);\n\n        if ( this._isRequestInProgress() ) {\n\n            this._setNextRequest(nextRequest);\n        }\n        else {\n\n            this._removeNextRequest();\n            nextRequest();\n        }\n    },\n\n    _sendRequest: function(bounds) {\n\n        var loadedBounds = this._getLoadedBounds();\n\n        if ( this._isFullyLoadedBounds(bounds, loadedBounds) ) {\n            this._setRequestInProgress(false);\n            return;\n        }\n\n        var self = this,\n        requestBounds = this._buildLargerBounds(bounds),\n        url = this._buildOverpassUrlFromEndPointAndQuery(\n            this.options.endPoint,\n            this._buildOverpassQueryFromQueryAndBounds(this.options.query, requestBounds)\n        ),\n        request = new XMLHttpRequest(),\n        beforeRequestResult = this.options.beforeRequest.call(this);\n\n        if ( beforeRequestResult === false ) {\n\n            this.options.afterRequest.call(this);\n\n            return;\n        }\n\n        this._setRequestInProgress(true);\n\n        if (this.options.debug) {\n\n            this._addRequestBox(\n                this._buildRequestBox(requestBounds)\n            );\n        }\n\n        request.open('GET', url, true);\n        request.timeout = this.options.timeout;\n\n        request.ontimeout = function () {\n\n            self._onRequestTimeout(this, url, requestBounds);\n        };\n\n        request.onload = function () {\n\n            self._onRequestLoad(this, requestBounds);\n        };\n\n        request.send();\n    },\n\n    _onRequestLoad: function (xhr, bounds) {\n\n        if (xhr.status >= 200 && xhr.status < 400) {\n\n            this.options.onSuccess.call(this, JSON.parse(xhr.response));\n\n            this._onRequestLoadCallback(bounds);\n        }\n        else {\n\n            this._onRequestErrorCallback(bounds);\n\n            this.options.onError.call(this, xhr);\n        }\n\n        this._onRequestCompleteCallback(bounds);\n    },\n\n    _onRequestTimeout: function (xhr, url, bounds) {\n\n        this.options.onTimeout.call(this, xhr);\n\n        if ( this.options.retryOnTimeout ) {\n\n            this._sendRequest(url);\n        }\n        else {\n\n            this._onRequestErrorCallback(bounds);\n            this._onRequestCompleteCallback(bounds);\n        }\n    },\n\n    _onRequestLoadCallback: function (bounds) {\n\n        this._addLoadedBounds(bounds);\n\n        if (this.options.debug) {\n\n            this._addResponseBoxes(\n\n                this._getRequestBoxes()\n            );\n        }\n    },\n\n    _onRequestErrorCallback: function (bounds) {\n\n        if (this.options.debug) {\n\n            this._removeRequestBox(\n                this._buildRequestBox(bounds)\n            );\n        }\n    },\n\n    _onRequestCompleteCallback: function (bounds) {\n\n        this.options.afterRequest.call(this);\n\n        if ( this._hasNextRequest() ) {\n\n            var nextRequest = this._getNextRequest();\n\n            this._removeNextRequest();\n\n            nextRequest();\n        }\n        else {\n\n            this._setRequestInProgress(false);\n        }\n    },\n\n    onAdd: function (map) {\n\n        this._map = map;\n\n        if (this._map.zoomIndicator) {\n\n            this._zoomControl = this._map.zoomIndicator;\n            this._zoomControl._addLayer(this);\n        } else {\n\n            this._zoomControl = new L.Control.MinZoomIndicator(this.options.minZoomIndicatorOptions);\n\n            this._map.addControl(this._zoomControl);\n\n            this._zoomControl._addLayer(this);\n        }\n\n        if (this.options.debug) {\n\n            this._requestBoxes = L.featureGroup().addTo(this._map);\n            this._responseBoxes = L.featureGroup().addTo(this._map);\n        }\n\n        this._markers = L.featureGroup().addTo(this._map);\n\n        if ( !this.options.noInitialRequest ) {\n            this._prepareRequest();\n        }\n\n        this._map.on('moveend', this._prepareRequest, this);\n    },\n\n    onRemove: function (map) {\n\n        L.LayerGroup.prototype.onRemove.call(this, map);\n\n        map.removeLayer(this._markers);\n        map.removeLayer(this._requestBoxes);\n        map.removeLayer(this._responseBoxes);\n\n        map.off('moveend', this._prepareRequest, this);\n\n        this._map = null;\n    },\n\n    setQuery: function (query) {\n        this.options.query = query;\n        this._resetData();\n        this._prepareRequest();\n    },\n\n    _resetData: function (map) {\n        this._ids = {};\n        this._loadedBounds = [];\n        this._requestInProgress = false;\n\n        if (this.options.debug) {\n            this._markers.clearLayers();\n            this._requestBoxes.clearLayers();\n            this._responseBoxes.clearLayers();\n        }\n    },\n\n    getData: function () {\n\n        return this._data;\n    },\n});\n\nL.OverPassLayer = OverPassLayer;\nL.overpassLayer = function (options) {\n  return new L.OverPassLayer(options);\n};\nmodule.exports = OverPassLayer;\n\n\n\n// WEBPACK FOOTER //\n// ./OverPassLayer.js","module.exports = L;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"L\"\n// module id = 1\n// module chunks = 0","// rev 452\n/********************************************************************************\n*                                                                              *\n* Author    :  Angus Johnson                                                   *\n* Version   :  6.1.3a                                                          *\n* Date      :  22 January 2014                                                 *\n* Website   :  http://www.angusj.com                                           *\n* Copyright :  Angus Johnson 2010-2014                                         *\n*                                                                              *\n* License:                                                                     *\n* Use, modification & distribution is subject to Boost Software License Ver 1. *\n* http://www.boost.org/LICENSE_1_0.txt                                         *\n*                                                                              *\n* Attributions:                                                                *\n* The code in this library is an extension of Bala Vatti's clipping algorithm: *\n* \"A generic solution to polygon clipping\"                                     *\n* Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n* http://portal.acm.org/citation.cfm?id=129906                                 *\n*                                                                              *\n* Computer graphics and geometric modeling: implementation and algorithms      *\n* By Max K. Agoston                                                            *\n* Springer; 1 edition (January 4, 2005)                                        *\n* http://books.google.com/books?q=vatti+clipping+agoston                       *\n*                                                                              *\n* See also:                                                                    *\n* \"Polygon Offsetting by Computing Winding Numbers\"                            *\n* Paper no. DETC2005-85513 pp. 565-575                                         *\n* ASME 2005 International Design Engineering Technical Conferences             *\n* and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n* September 24-28, 2005 , Long Beach, California, USA                          *\n* http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n*                                                                              *\n*******************************************************************************/\n/*******************************************************************************\n*                                                                              *\n* Author    :  Timo                                                            *\n* Version   :  6.1.3.2                                                         *\n* Date      :  1 February 2014                                                 *\n*                                                                              *\n* This is a translation of the C# Clipper library to Javascript.               *\n* Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n* Because Javascript lacks support for 64-bit integers, the space              *\n* is a little more restricted than in C# version.                              *\n*                                                                              *\n* C# version has support for coordinate space:                                 *\n* +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n* while Javascript version has support for space:                              *\n* +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n*                                                                              *\n* Tom Wu's JSBN proved to be the fastest big integer library:                  *\n* http://jsperf.com/big-integer-library-test                                   *\n*                                                                              *\n* This class can be made simpler when (if ever) 64-bit integer support comes.  *\n*                                                                              *\n*******************************************************************************/\n/*******************************************************************************\n*                                                                              *\n* Basic JavaScript BN library - subset useful for RSA encryption.              *\n* http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n* Copyright (c) 2005  Tom Wu                                                   *\n* All Rights Reserved.                                                         *\n* See \"LICENSE\" for details:                                                   *\n* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n*                                                                              *\n*******************************************************************************/\n\n\"use strict\";\n//use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n//improve performance but coordinate values are limited to the range +/- 46340\nvar use_int32 = false;\n//use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\nvar use_xyz = false;\n//UseLines: Enables line clipping. Adds a very minor cost to performance.\nvar use_lines = true;\n//use_deprecated: Enables support for the obsolete OffsetPaths() function\n//which has been replace with the ClipperOffset class.\nvar use_deprecated = false;\n\nvar ClipperLib = {};\nvar isNode = false;\nif (typeof module !== 'undefined' && module.exports)\n{\n  module.exports = ClipperLib;\n  isNode = true;\n}\nelse\n{\n  if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n  else self['ClipperLib'] = ClipperLib;\n}\nvar navigator_appName;\nif (!isNode)\n{\n  var nav = navigator.userAgent.toString().toLowerCase();\n  navigator_appName = navigator.appName;\n}\nelse\n{\n  var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n  navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n}\n// Browser test to speedup performance critical functions\nvar browser = {};\nif (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\nelse browser.chrome = 0;\nif (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\nelse browser.chromium = 0;\nif (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\nelse browser.safari = 0;\nif (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\nelse browser.firefox = 0;\nif (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\nelse browser.firefox17 = 0;\nif (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\nelse browser.firefox15 = 0;\nif (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\nelse browser.firefox3 = 0;\nif (nav.indexOf(\"opera\") != -1) browser.opera = 1;\nelse browser.opera = 0;\nif (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\nelse browser.msie10 = 0;\nif (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\nelse browser.msie9 = 0;\nif (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\nelse browser.msie8 = 0;\nif (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\nelse browser.msie7 = 0;\nif (nav.indexOf(\"msie \") != -1) browser.msie = 1;\nelse browser.msie = 0;\nClipperLib.biginteger_used = null;\n// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n// Basic JavaScript BN library - subset useful for RSA encryption.\n// Bits per digit\nvar dbits;\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary & 0xffffff) == 0xefcafe);\n// (public) Constructor\nfunction BigInteger(a, b, c)\n{\n  // This test variable can be removed,\n  // but at least for performance tests it is useful piece of knowledge\n  // This is the only ClipperLib related variable in BigInteger library\n  ClipperLib.biginteger_used = 1;\n  if (a != null)\n    if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n    else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n  else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n  else this.fromString(a, b);\n}\n// return new, unset BigInteger\nfunction nbi()\n{\n  return new BigInteger(null);\n}\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\nfunction am1(i, x, w, j, c, n)\n{\n  while (--n >= 0)\n  {\n    var v = x * this[i++] + w[j] + c;\n    c = Math.floor(v / 0x4000000);\n    w[j++] = v & 0x3ffffff;\n  }\n  return c;\n}\n// am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\nfunction am2(i, x, w, j, c, n)\n{\n  var xl = x & 0x7fff,\n    xh = x >> 15;\n  while (--n >= 0)\n  {\n    var l = this[i] & 0x7fff;\n    var h = this[i++] >> 15;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n    w[j++] = l & 0x3fffffff;\n  }\n  return c;\n}\n// Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i, x, w, j, c, n)\n{\n  var xl = x & 0x3fff,\n    xh = x >> 14;\n  while (--n >= 0)\n  {\n    var l = this[i] & 0x3fff;\n    var h = this[i++] >> 14;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n    c = (l >> 28) + (m >> 14) + xh * h;\n    w[j++] = l & 0xfffffff;\n  }\n  return c;\n}\nif (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n{\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n}\nelse if (j_lm && (navigator_appName != \"Netscape\"))\n{\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n}\nelse\n{ // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1 << dbits) - 1);\nBigInteger.prototype.DV = (1 << dbits);\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\nBigInteger.prototype.F1 = BI_FP - dbits;\nBigInteger.prototype.F2 = 2 * dbits - BI_FP;\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr, vv;\nrr = \"0\".charCodeAt(0);\nfor (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n)\n{\n  return BI_RM.charAt(n);\n}\n\nfunction intAt(s, i)\n{\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c == null) ? -1 : c;\n}\n// (protected) copy this to r\nfunction bnpCopyTo(r)\n{\n  for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x)\n{\n  this.t = 1;\n  this.s = (x < 0) ? -1 : 0;\n  if (x > 0) this[0] = x;\n  else if (x < -1) this[0] = x + this.DV;\n  else this.t = 0;\n}\n// return bigint initialized to value\nfunction nbv(i)\n{\n  var r = nbi();\n  r.fromInt(i);\n  return r;\n}\n// (protected) set from string and radix\nfunction bnpFromString(s, b)\n{\n  var k;\n  if (b == 16) k = 4;\n  else if (b == 8) k = 3;\n  else if (b == 256) k = 8; // byte array\n  else if (b == 2) k = 1;\n  else if (b == 32) k = 5;\n  else if (b == 4) k = 2;\n  else\n  {\n    this.fromRadix(s, b);\n    return;\n  }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length,\n    mi = false,\n    sh = 0;\n  while (--i >= 0)\n  {\n    var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n    if (x < 0)\n    {\n      if (s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n    mi = false;\n    if (sh == 0)\n      this[this.t++] = x;\n    else if (sh + k > this.DB)\n    {\n      this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n      this[this.t++] = (x >> (this.DB - sh));\n    }\n    else\n      this[this.t - 1] |= x << sh;\n    sh += k;\n    if (sh >= this.DB) sh -= this.DB;\n  }\n  if (k == 8 && (s[0] & 0x80) != 0)\n  {\n    this.s = -1;\n    if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n  }\n  this.clamp();\n  if (mi) BigInteger.ZERO.subTo(this, this);\n}\n// (protected) clamp off excess high words\nfunction bnpClamp()\n{\n  var c = this.s & this.DM;\n  while (this.t > 0 && this[this.t - 1] == c)--this.t;\n}\n// (public) return string representation in given radix\nfunction bnToString(b)\n{\n  if (this.s < 0) return \"-\" + this.negate().toString(b);\n  var k;\n  if (b == 16) k = 4;\n  else if (b == 8) k = 3;\n  else if (b == 2) k = 1;\n  else if (b == 32) k = 5;\n  else if (b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1 << k) - 1,\n    d, m = false,\n    r = \"\",\n    i = this.t;\n  var p = this.DB - (i * this.DB) % k;\n  if (i-- > 0)\n  {\n    if (p < this.DB && (d = this[i] >> p) > 0)\n    {\n      m = true;\n      r = int2char(d);\n    }\n    while (i >= 0)\n    {\n      if (p < k)\n      {\n        d = (this[i] & ((1 << p) - 1)) << (k - p);\n        d |= this[--i] >> (p += this.DB - k);\n      }\n      else\n      {\n        d = (this[i] >> (p -= k)) & km;\n        if (p <= 0)\n        {\n          p += this.DB;\n          --i;\n        }\n      }\n      if (d > 0) m = true;\n      if (m) r += int2char(d);\n    }\n  }\n  return m ? r : \"0\";\n}\n// (public) -this\nfunction bnNegate()\n{\n  var r = nbi();\n  BigInteger.ZERO.subTo(this, r);\n  return r;\n}\n// (public) |this|\nfunction bnAbs()\n{\n  return (this.s < 0) ? this.negate() : this;\n}\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a)\n{\n  var r = this.s - a.s;\n  if (r != 0) return r;\n  var i = this.t;\n  r = i - a.t;\n  if (r != 0) return (this.s < 0) ? -r : r;\n  while (--i >= 0)\n    if ((r = this[i] - a[i]) != 0) return r;\n  return 0;\n}\n// returns bit length of the integer x\nfunction nbits(x)\n{\n  var r = 1,\n    t;\n  if ((t = x >>> 16) != 0)\n  {\n    x = t;\n    r += 16;\n  }\n  if ((t = x >> 8) != 0)\n  {\n    x = t;\n    r += 8;\n  }\n  if ((t = x >> 4) != 0)\n  {\n    x = t;\n    r += 4;\n  }\n  if ((t = x >> 2) != 0)\n  {\n    x = t;\n    r += 2;\n  }\n  if ((t = x >> 1) != 0)\n  {\n    x = t;\n    r += 1;\n  }\n  return r;\n}\n// (public) return the number of bits in \"this\"\nfunction bnBitLength()\n{\n  if (this.t <= 0) return 0;\n  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n}\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n, r)\n{\n  var i;\n  for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n  for (i = n - 1; i >= 0; --i) r[i] = 0;\n  r.t = this.t + n;\n  r.s = this.s;\n}\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n, r)\n{\n  for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n  r.t = Math.max(this.t - n, 0);\n  r.s = this.s;\n}\n// (protected) r = this << n\nfunction bnpLShiftTo(n, r)\n{\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << cbs) - 1;\n  var ds = Math.floor(n / this.DB),\n    c = (this.s << bs) & this.DM,\n    i;\n  for (i = this.t - 1; i >= 0; --i)\n  {\n    r[i + ds + 1] = (this[i] >> cbs) | c;\n    c = (this[i] & bm) << bs;\n  }\n  for (i = ds - 1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t + ds + 1;\n  r.s = this.s;\n  r.clamp();\n}\n// (protected) r = this >> n\nfunction bnpRShiftTo(n, r)\n{\n  r.s = this.s;\n  var ds = Math.floor(n / this.DB);\n  if (ds >= this.t)\n  {\n    r.t = 0;\n    return;\n  }\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << bs) - 1;\n  r[0] = this[ds] >> bs;\n  for (var i = ds + 1; i < this.t; ++i)\n  {\n    r[i - ds - 1] |= (this[i] & bm) << cbs;\n    r[i - ds] = this[i] >> bs;\n  }\n  if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n  r.t = this.t - ds;\n  r.clamp();\n}\n// (protected) r = this - a\nfunction bnpSubTo(a, r)\n{\n  var i = 0,\n    c = 0,\n    m = Math.min(a.t, this.t);\n  while (i < m)\n  {\n    c += this[i] - a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n  if (a.t < this.t)\n  {\n    c -= a.s;\n    while (i < this.t)\n    {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else\n  {\n    c += this.s;\n    while (i < a.t)\n    {\n      c -= a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c < 0) ? -1 : 0;\n  if (c < -1) r[i++] = this.DV + c;\n  else if (c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a, r)\n{\n  var x = this.abs(),\n    y = a.abs();\n  var i = x.t;\n  r.t = i + y.t;\n  while (--i >= 0) r[i] = 0;\n  for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n  r.s = 0;\n  r.clamp();\n  if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n}\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r)\n{\n  var x = this.abs();\n  var i = r.t = 2 * x.t;\n  while (--i >= 0) r[i] = 0;\n  for (i = 0; i < x.t - 1; ++i)\n  {\n    var c = x.am(i, x[i], r, 2 * i, 0, 1);\n    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n    {\n      r[i + x.t] -= x.DV;\n      r[i + x.t + 1] = 1;\n    }\n  }\n  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n  r.s = 0;\n  r.clamp();\n}\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m, q, r)\n{\n  var pm = m.abs();\n  if (pm.t <= 0) return;\n  var pt = this.abs();\n  if (pt.t < pm.t)\n  {\n    if (q != null) q.fromInt(0);\n    if (r != null) this.copyTo(r);\n    return;\n  }\n  if (r == null) r = nbi();\n  var y = nbi(),\n    ts = this.s,\n    ms = m.s;\n  var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n  if (nsh > 0)\n  {\n    pm.lShiftTo(nsh, y);\n    pt.lShiftTo(nsh, r);\n  }\n  else\n  {\n    pm.copyTo(y);\n    pt.copyTo(r);\n  }\n  var ys = y.t;\n  var y0 = y[ys - 1];\n  if (y0 == 0) return;\n  var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n  var d1 = this.FV / yt,\n    d2 = (1 << this.F1) / yt,\n    e = 1 << this.F2;\n  var i = r.t,\n    j = i - ys,\n    t = (q == null) ? nbi() : q;\n  y.dlShiftTo(j, t);\n  if (r.compareTo(t) >= 0)\n  {\n    r[r.t++] = 1;\n    r.subTo(t, r);\n  }\n  BigInteger.ONE.dlShiftTo(ys, t);\n  t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n  while (y.t < ys) y[y.t++] = 0;\n  while (--j >= 0)\n  {\n    // Estimate quotient digit\n    var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n    { // Try it out\n      y.dlShiftTo(j, t);\n      r.subTo(t, r);\n      while (r[i] < --qd) r.subTo(t, r);\n    }\n  }\n  if (q != null)\n  {\n    r.drShiftTo(ys, q);\n    if (ts != ms) BigInteger.ZERO.subTo(q, q);\n  }\n  r.t = ys;\n  r.clamp();\n  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n  if (ts < 0) BigInteger.ZERO.subTo(r, r);\n}\n// (public) this mod a\nfunction bnMod(a)\n{\n  var r = nbi();\n  this.abs().divRemTo(a, null, r);\n  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n  return r;\n}\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m)\n{\n  this.m = m;\n}\n\nfunction cConvert(x)\n{\n  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\n\nfunction cRevert(x)\n{\n  return x;\n}\n\nfunction cReduce(x)\n{\n  x.divRemTo(this.m, null, x);\n}\n\nfunction cMulTo(x, y, r)\n{\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\n\nfunction cSqrTo(x, r)\n{\n  x.squareTo(r);\n  this.reduce(r);\n}\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit()\n{\n  if (this.t < 1) return 0;\n  var x = this[0];\n  if ((x & 1) == 0) return 0;\n  var y = x & 3; // y == 1/x mod 2^2\n  y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n  y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n  y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y > 0) ? this.DV - y : -y;\n}\n// Montgomery reduction\nfunction Montgomery(m)\n{\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp & 0x7fff;\n  this.mph = this.mp >> 15;\n  this.um = (1 << (m.DB - 15)) - 1;\n  this.mt2 = 2 * m.t;\n}\n// xR mod m\nfunction montConvert(x)\n{\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t, r);\n  r.divRemTo(this.m, null, r);\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n  return r;\n}\n// x/R mod m\nfunction montRevert(x)\n{\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x)\n{\n  while (x.t <= this.mt2) // pad x so am has enough room later\n    x[x.t++] = 0;\n  for (var i = 0; i < this.m.t; ++i)\n  {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i] & 0x7fff;\n    var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i + this.m.t;\n    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n    // propagate carry\n    while (x[j] >= x.DV)\n    {\n      x[j] -= x.DV;\n      x[++j]++;\n    }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t, x);\n  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n}\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x, r)\n{\n  x.squareTo(r);\n  this.reduce(r);\n}\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x, y, r)\n{\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n// (protected) true iff this is even\nfunction bnpIsEven()\n{\n  return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n}\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e, z)\n{\n  if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(),\n    r2 = nbi(),\n    g = z.convert(this),\n    i = nbits(e) - 1;\n  g.copyTo(r);\n  while (--i >= 0)\n  {\n    z.sqrTo(r, r2);\n    if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n    else\n    {\n      var t = r;\n      r = r2;\n      r2 = t;\n    }\n  }\n  return z.revert(r);\n}\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e, m)\n{\n  var z;\n  if (e < 256 || m.isEven()) z = new Classic(m);\n  else z = new Montgomery(m);\n  return this.exp(e, z);\n}\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n// Extended JavaScript BN functions, required for RSA private ops.\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n// Version 1.2: square() API, isProbablePrime fix\n// (public)\nfunction bnClone()\n{\n  var r = nbi();\n  this.copyTo(r);\n  return r;\n}\n// (public) return value as integer\nfunction bnIntValue()\n{\n  if (this.s < 0)\n  {\n    if (this.t == 1) return this[0] - this.DV;\n    else if (this.t == 0) return -1;\n  }\n  else if (this.t == 1) return this[0];\n  else if (this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n}\n// (public) return value as byte\nfunction bnByteValue()\n{\n  return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n}\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue()\n{\n  return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n}\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r)\n{\n  return Math.floor(Math.LN2 * this.DB / Math.log(r));\n}\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum()\n{\n  if (this.s < 0) return -1;\n  else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n// (protected) convert to radix string\nfunction bnpToRadix(b)\n{\n  if (b == null) b = 10;\n  if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b, cs);\n  var d = nbv(a),\n    y = nbi(),\n    z = nbi(),\n    r = \"\";\n  this.divRemTo(d, y, z);\n  while (y.signum() > 0)\n  {\n    r = (a + z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d, y, z);\n  }\n  return z.intValue().toString(b) + r;\n}\n// (protected) convert from radix string\nfunction bnpFromRadix(s, b)\n{\n  this.fromInt(0);\n  if (b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b, cs),\n    mi = false,\n    j = 0,\n    w = 0;\n  for (var i = 0; i < s.length; ++i)\n  {\n    var x = intAt(s, i);\n    if (x < 0)\n    {\n      if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b * w + x;\n    if (++j >= cs)\n    {\n      this.dMultiply(d);\n      this.dAddOffset(w, 0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if (j > 0)\n  {\n    this.dMultiply(Math.pow(b, j));\n    this.dAddOffset(w, 0);\n  }\n  if (mi) BigInteger.ZERO.subTo(this, this);\n}\n// (protected) alternate constructor\nfunction bnpFromNumber(a, b, c)\n{\n  if (\"number\" == typeof b)\n  {\n    // new BigInteger(int,int,RNG)\n    if (a < 2) this.fromInt(1);\n    else\n    {\n      this.fromNumber(a, c);\n      if (!this.testBit(a - 1)) // force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n      if (this.isEven()) this.dAddOffset(1, 0); // force odd\n      while (!this.isProbablePrime(b))\n      {\n        this.dAddOffset(2, 0);\n        if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n      }\n    }\n  }\n  else\n  {\n    // new BigInteger(int,RNG)\n    var x = new Array(),\n      t = a & 7;\n    x.length = (a >> 3) + 1;\n    b.nextBytes(x);\n    if (t > 0) x[0] &= ((1 << t) - 1);\n    else x[0] = 0;\n    this.fromString(x, 256);\n  }\n}\n// (public) convert to bigendian byte array\nfunction bnToByteArray()\n{\n  var i = this.t,\n    r = new Array();\n  r[0] = this.s;\n  var p = this.DB - (i * this.DB) % 8,\n    d, k = 0;\n  if (i-- > 0)\n  {\n    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n      r[k++] = d | (this.s << (this.DB - p));\n    while (i >= 0)\n    {\n      if (p < 8)\n      {\n        d = (this[i] & ((1 << p) - 1)) << (8 - p);\n        d |= this[--i] >> (p += this.DB - 8);\n      }\n      else\n      {\n        d = (this[i] >> (p -= 8)) & 0xff;\n        if (p <= 0)\n        {\n          p += this.DB;\n          --i;\n        }\n      }\n      if ((d & 0x80) != 0) d |= -256;\n      if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n      if (k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a)\n{\n  return (this.compareTo(a) == 0);\n}\n\nfunction bnMin(a)\n{\n  return (this.compareTo(a) < 0) ? this : a;\n}\n\nfunction bnMax(a)\n{\n  return (this.compareTo(a) > 0) ? this : a;\n}\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a, op, r)\n{\n  var i, f, m = Math.min(a.t, this.t);\n  for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n  if (a.t < this.t)\n  {\n    f = a.s & this.DM;\n    for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n    r.t = this.t;\n  }\n  else\n  {\n    f = this.s & this.DM;\n    for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s, a.s);\n  r.clamp();\n}\n// (public) this & a\nfunction op_and(x, y)\n{\n  return x & y;\n}\n\nfunction bnAnd(a)\n{\n  var r = nbi();\n  this.bitwiseTo(a, op_and, r);\n  return r;\n}\n// (public) this | a\nfunction op_or(x, y)\n{\n  return x | y;\n}\n\nfunction bnOr(a)\n{\n  var r = nbi();\n  this.bitwiseTo(a, op_or, r);\n  return r;\n}\n// (public) this ^ a\nfunction op_xor(x, y)\n{\n  return x ^ y;\n}\n\nfunction bnXor(a)\n{\n  var r = nbi();\n  this.bitwiseTo(a, op_xor, r);\n  return r;\n}\n// (public) this & ~a\nfunction op_andnot(x, y)\n{\n  return x & ~y;\n}\n\nfunction bnAndNot(a)\n{\n  var r = nbi();\n  this.bitwiseTo(a, op_andnot, r);\n  return r;\n}\n// (public) ~this\nfunction bnNot()\n{\n  var r = nbi();\n  for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n// (public) this << n\nfunction bnShiftLeft(n)\n{\n  var r = nbi();\n  if (n < 0) this.rShiftTo(-n, r);\n  else this.lShiftTo(n, r);\n  return r;\n}\n// (public) this >> n\nfunction bnShiftRight(n)\n{\n  var r = nbi();\n  if (n < 0) this.lShiftTo(-n, r);\n  else this.rShiftTo(n, r);\n  return r;\n}\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x)\n{\n  if (x == 0) return -1;\n  var r = 0;\n  if ((x & 0xffff) == 0)\n  {\n    x >>= 16;\n    r += 16;\n  }\n  if ((x & 0xff) == 0)\n  {\n    x >>= 8;\n    r += 8;\n  }\n  if ((x & 0xf) == 0)\n  {\n    x >>= 4;\n    r += 4;\n  }\n  if ((x & 3) == 0)\n  {\n    x >>= 2;\n    r += 2;\n  }\n  if ((x & 1) == 0)++r;\n  return r;\n}\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit()\n{\n  for (var i = 0; i < this.t; ++i)\n    if (this[i] != 0) return i * this.DB + lbit(this[i]);\n  if (this.s < 0) return this.t * this.DB;\n  return -1;\n}\n// return number of 1 bits in x\nfunction cbit(x)\n{\n  var r = 0;\n  while (x != 0)\n  {\n    x &= x - 1;\n    ++r;\n  }\n  return r;\n}\n// (public) return number of set bits\nfunction bnBitCount()\n{\n  var r = 0,\n    x = this.s & this.DM;\n  for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n  return r;\n}\n// (public) true iff nth bit is set\nfunction bnTestBit(n)\n{\n  var j = Math.floor(n / this.DB);\n  if (j >= this.t) return (this.s != 0);\n  return ((this[j] & (1 << (n % this.DB))) != 0);\n}\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n, op)\n{\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r, op, r);\n  return r;\n}\n// (public) this | (1<<n)\nfunction bnSetBit(n)\n{\n  return this.changeBit(n, op_or);\n}\n// (public) this & ~(1<<n)\nfunction bnClearBit(n)\n{\n  return this.changeBit(n, op_andnot);\n}\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n)\n{\n  return this.changeBit(n, op_xor);\n}\n// (protected) r = this + a\nfunction bnpAddTo(a, r)\n{\n  var i = 0,\n    c = 0,\n    m = Math.min(a.t, this.t);\n  while (i < m)\n  {\n    c += this[i] + a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n  if (a.t < this.t)\n  {\n    c += a.s;\n    while (i < this.t)\n    {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else\n  {\n    c += this.s;\n    while (i < a.t)\n    {\n      c += a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c < 0) ? -1 : 0;\n  if (c > 0) r[i++] = c;\n  else if (c < -1) r[i++] = this.DV + c;\n  r.t = i;\n  r.clamp();\n}\n// (public) this + a\nfunction bnAdd(a)\n{\n  var r = nbi();\n  this.addTo(a, r);\n  return r;\n}\n// (public) this - a\nfunction bnSubtract(a)\n{\n  var r = nbi();\n  this.subTo(a, r);\n  return r;\n}\n// (public) this * a\nfunction bnMultiply(a)\n{\n  var r = nbi();\n  this.multiplyTo(a, r);\n  return r;\n}\n// (public) this^2\nfunction bnSquare()\n{\n  var r = nbi();\n  this.squareTo(r);\n  return r;\n}\n// (public) this / a\nfunction bnDivide(a)\n{\n  var r = nbi();\n  this.divRemTo(a, r, null);\n  return r;\n}\n// (public) this % a\nfunction bnRemainder(a)\n{\n  var r = nbi();\n  this.divRemTo(a, null, r);\n  return r;\n}\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a)\n{\n  var q = nbi(),\n    r = nbi();\n  this.divRemTo(a, q, r);\n  return new Array(q, r);\n}\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n)\n{\n  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n  ++this.t;\n  this.clamp();\n}\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n, w)\n{\n  if (n == 0) return;\n  while (this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while (this[w] >= this.DV)\n  {\n    this[w] -= this.DV;\n    if (++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n// A \"null\" reducer\nfunction NullExp()\n{}\n\nfunction nNop(x)\n{\n  return x;\n}\n\nfunction nMulTo(x, y, r)\n{\n  x.multiplyTo(y, r);\n}\n\nfunction nSqrTo(x, r)\n{\n  x.squareTo(r);\n}\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n// (public) this^e\nfunction bnPow(e)\n{\n  return this.exp(e, new NullExp());\n}\n// (protected) r = lower n words of \"this * a\", a.t <= n\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a, n, r)\n{\n  var i = Math.min(this.t + a.t, n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while (i > 0) r[--i] = 0;\n  var j;\n  for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n  for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n  r.clamp();\n}\n// (protected) r = \"this * a\" without lower n words, n > 0\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a, n, r)\n{\n  --n;\n  var i = r.t = this.t + a.t - n;\n  r.s = 0; // assumes a,this >= 0\n  while (--i >= 0) r[i] = 0;\n  for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n  r.clamp();\n  r.drShiftTo(1, r);\n}\n// Barrett modular reduction\nfunction Barrett(m)\n{\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x)\n{\n  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n  else if (x.compareTo(this.m) < 0) return x;\n  else\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n}\n\nfunction barrettRevert(x)\n{\n  return x;\n}\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x)\n{\n  x.drShiftTo(this.m.t - 1, this.r2);\n  if (x.t > this.m.t + 1)\n  {\n    x.t = this.m.t + 1;\n    x.clamp();\n  }\n  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n  while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n  x.subTo(this.r2, x);\n  while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n}\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x, r)\n{\n  x.squareTo(r);\n  this.reduce(r);\n}\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x, y, r)\n{\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e, m)\n{\n  var i = e.bitLength(),\n    k, r = nbv(1),\n    z;\n  if (i <= 0) return r;\n  else if (i < 18) k = 1;\n  else if (i < 48) k = 3;\n  else if (i < 144) k = 4;\n  else if (i < 768) k = 5;\n  else k = 6;\n  if (i < 8)\n    z = new Classic(m);\n  else if (m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n  // precomputation\n  var g = new Array(),\n    n = 3,\n    k1 = k - 1,\n    km = (1 << k) - 1;\n  g[1] = z.convert(this);\n  if (k > 1)\n  {\n    var g2 = nbi();\n    z.sqrTo(g[1], g2);\n    while (n <= km)\n    {\n      g[n] = nbi();\n      z.mulTo(g2, g[n - 2], g[n]);\n      n += 2;\n    }\n  }\n  var j = e.t - 1,\n    w, is1 = true,\n    r2 = nbi(),\n    t;\n  i = nbits(e[j]) - 1;\n  while (j >= 0)\n  {\n    if (i >= k1) w = (e[j] >> (i - k1)) & km;\n    else\n    {\n      w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n      if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n    }\n    n = k;\n    while ((w & 1) == 0)\n    {\n      w >>= 1;\n      --n;\n    }\n    if ((i -= n) < 0)\n    {\n      i += this.DB;\n      --j;\n    }\n    if (is1)\n    { // ret == 1, don't bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else\n    {\n      while (n > 1)\n      {\n        z.sqrTo(r, r2);\n        z.sqrTo(r2, r);\n        n -= 2;\n      }\n      if (n > 0) z.sqrTo(r, r2);\n      else\n      {\n        t = r;\n        r = r2;\n        r2 = t;\n      }\n      z.mulTo(r2, g[w], r);\n    }\n    while (j >= 0 && (e[j] & (1 << i)) == 0)\n    {\n      z.sqrTo(r, r2);\n      t = r;\n      r = r2;\n      r2 = t;\n      if (--i < 0)\n      {\n        i = this.DB - 1;\n        --j;\n      }\n    }\n  }\n  return z.revert(r);\n}\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a)\n{\n  var x = (this.s < 0) ? this.negate() : this.clone();\n  var y = (a.s < 0) ? a.negate() : a.clone();\n  if (x.compareTo(y) < 0)\n  {\n    var t = x;\n    x = y;\n    y = t;\n  }\n  var i = x.getLowestSetBit(),\n    g = y.getLowestSetBit();\n  if (g < 0) return x;\n  if (i < g) g = i;\n  if (g > 0)\n  {\n    x.rShiftTo(g, x);\n    y.rShiftTo(g, y);\n  }\n  while (x.signum() > 0)\n  {\n    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n    if (x.compareTo(y) >= 0)\n    {\n      x.subTo(y, x);\n      x.rShiftTo(1, x);\n    }\n    else\n    {\n      y.subTo(x, y);\n      y.rShiftTo(1, y);\n    }\n  }\n  if (g > 0) y.lShiftTo(g, y);\n  return y;\n}\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n)\n{\n  if (n <= 0) return 0;\n  var d = this.DV % n,\n    r = (this.s < 0) ? n - 1 : 0;\n  if (this.t > 0)\n    if (d == 0) r = this[0] % n;\n    else\n      for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n  return r;\n}\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m)\n{\n  var ac = m.isEven();\n  if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(),\n    v = this.clone();\n  var a = nbv(1),\n    b = nbv(0),\n    c = nbv(0),\n    d = nbv(1);\n  while (u.signum() != 0)\n  {\n    while (u.isEven())\n    {\n      u.rShiftTo(1, u);\n      if (ac)\n      {\n        if (!a.isEven() || !b.isEven())\n        {\n          a.addTo(this, a);\n          b.subTo(m, b);\n        }\n        a.rShiftTo(1, a);\n      }\n      else if (!b.isEven()) b.subTo(m, b);\n      b.rShiftTo(1, b);\n    }\n    while (v.isEven())\n    {\n      v.rShiftTo(1, v);\n      if (ac)\n      {\n        if (!c.isEven() || !d.isEven())\n        {\n          c.addTo(this, c);\n          d.subTo(m, d);\n        }\n        c.rShiftTo(1, c);\n      }\n      else if (!d.isEven()) d.subTo(m, d);\n      d.rShiftTo(1, d);\n    }\n    if (u.compareTo(v) >= 0)\n    {\n      u.subTo(v, u);\n      if (ac) a.subTo(c, a);\n      b.subTo(d, b);\n    }\n    else\n    {\n      v.subTo(u, v);\n      if (ac) c.subTo(a, c);\n      d.subTo(b, d);\n    }\n  }\n  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if (d.compareTo(m) >= 0) return d.subtract(m);\n  if (d.signum() < 0) d.addTo(m, d);\n  else return d;\n  if (d.signum() < 0) return d.add(m);\n  else return d;\n}\nvar lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\nvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t)\n{\n  var i, x = this.abs();\n  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n  {\n    for (i = 0; i < lowprimes.length; ++i)\n      if (x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if (x.isEven()) return false;\n  i = 1;\n  while (i < lowprimes.length)\n  {\n    var m = lowprimes[i],\n      j = i + 1;\n    while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while (i < j)\n      if (m % lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t)\n{\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if (k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t + 1) >> 1;\n  if (t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for (var i = 0; i < t; ++i)\n  {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n    var y = a.modPow(r, this);\n    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n    {\n      var j = 1;\n      while (j++ < k && y.compareTo(n1) != 0)\n      {\n        y = y.modPowInt(2, this);\n        if (y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if (y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\nvar Int128 = BigInteger;\n// BigInteger interfaces not implemented in jsbn:\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n// Helper functions to make BigInteger functions callable with two parameters\n// as in original C# Clipper\nInt128.prototype.IsNegative = function ()\n{\n  if (this.compareTo(Int128.ZERO) == -1) return true;\n  else return false;\n};\nInt128.op_Equality = function (val1, val2)\n{\n  if (val1.compareTo(val2) == 0) return true;\n  else return false;\n};\nInt128.op_Inequality = function (val1, val2)\n{\n  if (val1.compareTo(val2) != 0) return true;\n  else return false;\n};\nInt128.op_GreaterThan = function (val1, val2)\n{\n  if (val1.compareTo(val2) > 0) return true;\n  else return false;\n};\nInt128.op_LessThan = function (val1, val2)\n{\n  if (val1.compareTo(val2) < 0) return true;\n  else return false;\n};\nInt128.op_Addition = function (lhs, rhs)\n{\n  return new Int128(lhs).add(new Int128(rhs));\n};\nInt128.op_Subtraction = function (lhs, rhs)\n{\n  return new Int128(lhs).subtract(new Int128(rhs));\n};\nInt128.Int128Mul = function (lhs, rhs)\n{\n  return new Int128(lhs).multiply(new Int128(rhs));\n};\nInt128.op_Division = function (lhs, rhs)\n{\n  return lhs.divide(rhs);\n};\nInt128.prototype.ToDouble = function ()\n{\n  return parseFloat(this.toString()); // This could be something faster\n};\n// end of Int128 section\n/*\n// Uncomment the following two lines if you want to use Int128 outside ClipperLib\nif (typeof(document) !== \"undefined\") window.Int128 = Int128;\nelse self.Int128 = Int128;\n*/\n// ---------------------------------------------  \n// Here starts the actual Clipper library:\n// Helper function to support Inheritance in Javascript\nif (typeof (Inherit) == 'undefined')\n{\n  var Inherit = function (ce, ce2)\n  {\n    var p;\n    if (typeof (Object.getOwnPropertyNames) == 'undefined')\n    {\n      for (p in ce2.prototype)\n        if (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n      for (p in ce2)\n        if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n      ce.$baseCtor = ce2;\n    }\n    else\n    {\n      var props = Object.getOwnPropertyNames(ce2.prototype);\n      for (var i = 0; i < props.length; i++)\n        if (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n      for (p in ce2)\n        if (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n      ce.$baseCtor = ce2;\n    }\n  };\n}\nClipperLib.Path = function ()\n{\n  return [];\n};\nClipperLib.Paths = function ()\n{\n  return []; // Was previously [[]], but caused problems when pushed\n};\n// Preserves the calling way of original C# Clipper\n// Is essential due to compatibility, because DoublePoint is public class in original C# version\nClipperLib.DoublePoint = function ()\n{\n  var a = arguments;\n  this.X = 0;\n  this.Y = 0;\n  // public DoublePoint(DoublePoint dp)\n  // public DoublePoint(IntPoint ip)\n  if (a.length == 1)\n  {\n    this.X = a[0].X;\n    this.Y = a[0].Y;\n  }\n  else if (a.length == 2)\n  {\n    this.X = a[0];\n    this.Y = a[1];\n  }\n}; // This is internal faster function when called without arguments\nClipperLib.DoublePoint0 = function ()\n{\n  this.X = 0;\n  this.Y = 0;\n};\n// This is internal faster function when called with 1 argument (dp or ip)\nClipperLib.DoublePoint1 = function (dp)\n{\n  this.X = dp.X;\n  this.Y = dp.Y;\n};\n// This is internal faster function when called with 2 arguments (x and y)\nClipperLib.DoublePoint2 = function (x, y)\n{\n  this.X = x;\n  this.Y = y;\n};\n// PolyTree & PolyNode start\n// -------------------------------\nClipperLib.PolyNode = function ()\n{\n  this.m_Parent = null;\n  this.m_polygon = new ClipperLib.Path();\n  this.m_Index = 0;\n  this.m_jointype = 0;\n  this.m_endtype = 0;\n  this.m_Childs = [];\n  this.IsOpen = false;\n};\nClipperLib.PolyNode.prototype.IsHoleNode = function ()\n{\n  var result = true;\n  var node = this.m_Parent;\n  while (node !== null)\n  {\n    result = !result;\n    node = node.m_Parent;\n  }\n  return result;\n};\nClipperLib.PolyNode.prototype.ChildCount = function ()\n{\n  return this.m_Childs.length;\n};\nClipperLib.PolyNode.prototype.Contour = function ()\n{\n  return this.m_polygon;\n};\nClipperLib.PolyNode.prototype.AddChild = function (Child)\n{\n  var cnt = this.m_Childs.length;\n  this.m_Childs.push(Child);\n  Child.m_Parent = this;\n  Child.m_Index = cnt;\n};\nClipperLib.PolyNode.prototype.GetNext = function ()\n{\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return this.GetNextSiblingUp();\n};\nClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n{\n  if (this.m_Parent === null)\n    return null;\n  else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n    return this.m_Parent.GetNextSiblingUp();\n  else\n    return this.m_Parent.m_Childs[this.m_Index + 1];\n};\nClipperLib.PolyNode.prototype.Childs = function ()\n{\n  return this.m_Childs;\n};\nClipperLib.PolyNode.prototype.Parent = function ()\n{\n  return this.m_Parent;\n};\nClipperLib.PolyNode.prototype.IsHole = function ()\n{\n  return this.IsHoleNode();\n};\n// PolyTree : PolyNode\nClipperLib.PolyTree = function ()\n{\n  this.m_AllPolys = [];\n  ClipperLib.PolyNode.call(this);\n};\nClipperLib.PolyTree.prototype.Clear = function ()\n{\n  for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n    this.m_AllPolys[i] = null;\n  this.m_AllPolys.length = 0;\n  this.m_Childs.length = 0;\n};\nClipperLib.PolyTree.prototype.GetFirst = function ()\n{\n  if (this.m_Childs.length > 0)\n    return this.m_Childs[0];\n  else\n    return null;\n};\nClipperLib.PolyTree.prototype.Total = function ()\n{\n  return this.m_AllPolys.length;\n};\nInherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n// -------------------------------\n// PolyTree & PolyNode end\nClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n{\n  return Math.abs(a);\n};\nClipperLib.Math_Max_Int32_Int32 = function (a, b)\n{\n  return Math.max(a, b);\n};\n/*\n-----------------------------------\ncast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n-----------------------------------\n*/\nif (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n{\n  return a | 0;\n};\nelse ClipperLib.Cast_Int32 = function (a)\n{ // eg. browser.chrome || browser.chromium || browser.firefox\n  return~~ a;\n};\n/*\n--------------------------\ncast_64 speedtests: http://jsperf.com/truncate-float-to-integer\nChrome: bitwise_not_floor\nFirefox17: toInteger (typeof test)\nIE9: bitwise_or_floor\nIE7 and IE8: to_parseint\nChromium: to_floor_or_ceil\nFirefox3: to_floor_or_ceil\nFirefox15: to_floor_or_ceil\nOpera: to_floor_or_ceil\nSafari: to_floor_or_ceil\n--------------------------\n*/\nif (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n{\n  if (a < -2147483648 || a > 2147483647)\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  else return~~ a;\n};\nelse if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n{\n  return Number.toInteger(a);\n};\nelse if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n{\n  return parseInt(a, 10);\n};\nelse if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n{\n  if (a < -2147483648 || a > 2147483647)\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  return a | 0;\n};\n// eg. browser.chromium || browser.firefox || browser.opera || browser.safari\nelse ClipperLib.Cast_Int64 = function (a)\n{\n  return a < 0 ? Math.ceil(a) : Math.floor(a);\n};\nClipperLib.Clear = function (a)\n{\n  a.length = 0;\n};\n//ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\nClipperLib.PI = 3.141592653589793;\nClipperLib.PI2 = 2 * 3.141592653589793;\nClipperLib.IntPoint = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  this.X = 0;\n  this.Y = 0;\n  if (use_xyz)\n  {\n    this.Z = 0;\n    if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n      this.Z = a[2];\n    }\n    else if (alen == 2) // public IntPoint(cInt x, cInt y)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n      this.Z = 0;\n    }\n    else if (alen == 1)\n    {\n      if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n      {\n        var dp = a[0];\n        this.X = ClipperLib.Clipper.Round(dp.X);\n        this.Y = ClipperLib.Clipper.Round(dp.Y);\n        this.Z = 0;\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        var pt = a[0];\n        if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n        this.X = pt.X;\n        this.Y = pt.Y;\n        this.Z = pt.Z;\n      }\n    }\n    else // public IntPoint()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    }\n  }\n  else // if (!use_xyz)\n  {\n    if (alen == 2) // public IntPoint(cInt X, cInt Y)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n    else if (alen == 1)\n    {\n      if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n      {\n        var dp = a[0];\n        this.X = ClipperLib.Clipper.Round(dp.X);\n        this.Y = ClipperLib.Clipper.Round(dp.Y);\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        var pt = a[0];\n        this.X = pt.X;\n        this.Y = pt.Y;\n      }\n    }\n    else // public IntPoint(IntPoint pt)\n    {\n      this.X = 0;\n      this.Y = 0;\n    }\n  }\n};\nClipperLib.IntPoint.op_Equality = function (a, b)\n{\n  //return a == b;\n  return a.X == b.X && a.Y == b.Y;\n};\nClipperLib.IntPoint.op_Inequality = function (a, b)\n{\n  //return a != b;\n  return a.X != b.X || a.Y != b.Y;\n};\n/*\nClipperLib.IntPoint.prototype.Equals = function (obj)\n{\n  if (obj === null)\n      return false;\n  if (obj instanceof ClipperLib.IntPoint)\n  {\n      var a = Cast(obj, ClipperLib.IntPoint);\n      return (this.X == a.X) && (this.Y == a.Y);\n  }\n  else\n      return false;\n};\n*/\nif (use_xyz)\n{\n  ClipperLib.IntPoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n    this.Z = 0;\n  };\n  ClipperLib.IntPoint1 = function (pt)\n  {\n    this.X = pt.X;\n    this.Y = pt.Y;\n    this.Z = pt.Z;\n  };\n  ClipperLib.IntPoint1dp = function (dp)\n  {\n    this.X = ClipperLib.Clipper.Round(dp.X);\n    this.Y = ClipperLib.Clipper.Round(dp.Y);\n    this.Z = 0;\n  };\n  ClipperLib.IntPoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n    this.Z = 0;\n  };\n  ClipperLib.IntPoint3 = function (x, y, z)\n  {\n    this.X = x;\n    this.Y = y;\n    this.Z = z;\n  };\n}\nelse // if (!use_xyz)\n{\n  ClipperLib.IntPoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  ClipperLib.IntPoint1 = function (pt)\n  {\n    this.X = pt.X;\n    this.Y = pt.Y;\n  };\n  ClipperLib.IntPoint1dp = function (dp)\n  {\n    this.X = ClipperLib.Clipper.Round(dp.X);\n    this.Y = ClipperLib.Clipper.Round(dp.Y);\n  };\n  ClipperLib.IntPoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n}\nClipperLib.IntRect = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  if (alen == 4) // function (l, t, r, b)\n  {\n    this.left = a[0];\n    this.top = a[1];\n    this.right = a[2];\n    this.bottom = a[3];\n  }\n  else if (alen == 1) // function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  }\n  else // function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  }\n};\nClipperLib.IntRect0 = function ()\n{\n  this.left = 0;\n  this.top = 0;\n  this.right = 0;\n  this.bottom = 0;\n};\nClipperLib.IntRect1 = function (ir)\n{\n  this.left = ir.left;\n  this.top = ir.top;\n  this.right = ir.right;\n  this.bottom = ir.bottom;\n};\nClipperLib.IntRect4 = function (l, t, r, b)\n{\n  this.left = l;\n  this.top = t;\n  this.right = r;\n  this.bottom = b;\n};\nClipperLib.ClipType = {\n  ctIntersection: 0,\n  ctUnion: 1,\n  ctDifference: 2,\n  ctXor: 3\n};\nClipperLib.PolyType = {\n  ptSubject: 0,\n  ptClip: 1\n};\nClipperLib.PolyFillType = {\n  pftEvenOdd: 0,\n  pftNonZero: 1,\n  pftPositive: 2,\n  pftNegative: 3\n};\nClipperLib.JoinType = {\n  jtSquare: 0,\n  jtRound: 1,\n  jtMiter: 2\n};\nClipperLib.EndType = {\n  etOpenSquare: 0,\n  etOpenRound: 1,\n  etOpenButt: 2,\n  etClosedLine: 3,\n  etClosedPolygon: 4\n};\nif (use_deprecated)\n  ClipperLib.EndType_ = {\n    etSquare: 0,\n    etRound: 1,\n    etButt: 2,\n    etClosed: 3\n  };\nClipperLib.EdgeSide = {\n  esLeft: 0,\n  esRight: 1\n};\nClipperLib.Direction = {\n  dRightToLeft: 0,\n  dLeftToRight: 1\n};\nClipperLib.TEdge = function ()\n{\n  this.Bot = new ClipperLib.IntPoint();\n  this.Curr = new ClipperLib.IntPoint();\n  this.Top = new ClipperLib.IntPoint();\n  this.Delta = new ClipperLib.IntPoint();\n  this.Dx = 0;\n  this.PolyTyp = ClipperLib.PolyType.ptSubject;\n  this.Side = ClipperLib.EdgeSide.esLeft;\n  this.WindDelta = 0;\n  this.WindCnt = 0;\n  this.WindCnt2 = 0;\n  this.OutIdx = 0;\n  this.Next = null;\n  this.Prev = null;\n  this.NextInLML = null;\n  this.NextInAEL = null;\n  this.PrevInAEL = null;\n  this.NextInSEL = null;\n  this.PrevInSEL = null;\n};\nClipperLib.IntersectNode = function ()\n{\n  this.Edge1 = null;\n  this.Edge2 = null;\n  this.Pt = new ClipperLib.IntPoint();\n};\nClipperLib.MyIntersectNodeSort = function () {};\nClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n{\n  return (node2.Pt.Y - node1.Pt.Y);\n};\nClipperLib.LocalMinima = function ()\n{\n  this.Y = 0;\n  this.LeftBound = null;\n  this.RightBound = null;\n  this.Next = null;\n};\nClipperLib.Scanbeam = function ()\n{\n  this.Y = 0;\n  this.Next = null;\n};\nClipperLib.OutRec = function ()\n{\n  this.Idx = 0;\n  this.IsHole = false;\n  this.IsOpen = false;\n  this.FirstLeft = null;\n  this.Pts = null;\n  this.BottomPt = null;\n  this.PolyNode = null;\n};\nClipperLib.OutPt = function ()\n{\n  this.Idx = 0;\n  this.Pt = new ClipperLib.IntPoint();\n  this.Next = null;\n  this.Prev = null;\n};\nClipperLib.Join = function ()\n{\n  this.OutPt1 = null;\n  this.OutPt2 = null;\n  this.OffPt = new ClipperLib.IntPoint();\n};\nClipperLib.ClipperBase = function ()\n{\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_edges = new Array();\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n  this.PreserveCollinear = false;\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n};\n// Ranges are in original C# too high for Javascript (in current state 2013 september):\n// protected const double horizontal = -3.4E+38;\n// internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n// internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n// So had to adjust them to more suitable for Javascript.\n// If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n// and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\nClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\nClipperLib.ClipperBase.Skip = -2;\nClipperLib.ClipperBase.Unassigned = -1;\nClipperLib.ClipperBase.tolerance = 1E-20;\nif (use_int32)\n{\n  ClipperLib.ClipperBase.loRange = 46340;\n  ClipperLib.ClipperBase.hiRange = 46340;\n}\nelse\n{\n  ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n  ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n}\nClipperLib.ClipperBase.near_zero = function (val)\n{\n  return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n};\nClipperLib.ClipperBase.IsHorizontal = function (e)\n{\n  return e.Delta.Y === 0;\n};\nClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n{\n  var pp2 = pp;\n  do {\n    if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n      return true;\n    pp2 = pp2.Next;\n  }\n  while (pp2 != pp)\n  return false;\n};\nClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n{\n  if (UseFullRange)\n    return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n      ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n      (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n      ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n      (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n        Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n  else\n    return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n};\nClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n{\n  var pp2 = pp;\n  while (true)\n  {\n    if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n      return true;\n    pp2 = pp2.Next;\n    if (pp2 == pp)\n      break;\n  }\n  return false;\n};\nClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n  if (alen == 3) // function (e1, e2, UseFullRange)\n  {\n    e1 = a[0];\n    e2 = a[1];\n    UseFullRange = a[2];\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  }\n  else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    UseFullRange = a[3];\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  }\n  else // function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    pt1 = a[0];\n    pt2 = a[1];\n    pt3 = a[2];\n    pt4 = a[3];\n    UseFullRange = a[4];\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  }\n};\nClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n{\n  if (UseFullRange)\n    return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n  else\n    return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n};\nClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n{\n  if (UseFullRange)\n    return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n  else\n    return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n};\nClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n{\n  if (UseFullRange)\n    return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n  else\n    return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n};\nClipperLib.ClipperBase.prototype.Clear = function ()\n{\n  this.DisposeLocalMinimaList();\n  for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n  {\n    for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n      this.m_edges[i][j] = null;\n    ClipperLib.Clear(this.m_edges[i]);\n  }\n  ClipperLib.Clear(this.m_edges);\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n};\nClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n{\n  while (this.m_MinimaList !== null)\n  {\n    var tmpLm = this.m_MinimaList.Next;\n    this.m_MinimaList = null;\n    this.m_MinimaList = tmpLm;\n  }\n  this.m_CurrentLM = null;\n};\nClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n{\n  if (useFullRange.Value)\n  {\n    if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n      ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n  }\n  else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n  {\n    useFullRange.Value = true;\n    this.RangeTest(Pt, useFullRange);\n  }\n};\nClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n{\n  e.Next = eNext;\n  e.Prev = ePrev;\n  //e.Curr = pt;\n  e.Curr.X = pt.X;\n  e.Curr.Y = pt.Y;\n  e.OutIdx = -1;\n};\nClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n{\n  if (e.Curr.Y >= e.Next.Curr.Y)\n  {\n    //e.Bot = e.Curr;\n    e.Bot.X = e.Curr.X;\n    e.Bot.Y = e.Curr.Y;\n    //e.Top = e.Next.Curr;\n    e.Top.X = e.Next.Curr.X;\n    e.Top.Y = e.Next.Curr.Y;\n  }\n  else\n  {\n    //e.Top = e.Curr;\n    e.Top.X = e.Curr.X;\n    e.Top.Y = e.Curr.Y;\n    //e.Bot = e.Next.Curr;\n    e.Bot.X = e.Next.Curr.X;\n    e.Bot.Y = e.Next.Curr.Y;\n  }\n  this.SetDx(e);\n  e.PolyTyp = polyType;\n};\nClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n{\n  var E2;\n  for (;;)\n  {\n    while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n      E = E.Next;\n    if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n      break;\n    while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n      E = E.Prev;\n    E2 = E;\n    while (E.Dx == ClipperLib.ClipperBase.horizontal)\n      E = E.Next;\n    if (E.Top.Y == E.Prev.Bot.Y)\n      continue;\n    //ie just an intermediate horz.\n    if (E2.Prev.Bot.X < E.Bot.X)\n      E = E2;\n    break;\n  }\n  return E;\n};\nClipperLib.ClipperBase.prototype.ProcessBound = function (E, IsClockwise)\n{\n  var EStart = E,\n    Result = E;\n  var Horz;\n  var StartX;\n  if (E.Dx == ClipperLib.ClipperBase.horizontal)\n  {\n    //it's possible for adjacent overlapping horz edges to start heading left\n    //before finishing right, so ...\n    if (IsClockwise)\n      StartX = E.Prev.Bot.X;\n    else\n      StartX = E.Next.Bot.X;\n    if (E.Bot.X != StartX)\n      this.ReverseHorizontal(E);\n  }\n  if (Result.OutIdx != ClipperLib.ClipperBase.Skip)\n  {\n    if (IsClockwise)\n    {\n      while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        Result = Result.Next;\n      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        //nb: at the top of a bound, horizontals are added to the bound\n        //only when the preceding edge attaches to the horizontal's left vertex\n        //unless a Skip edge is encountered when that becomes the top divide\n        Horz = Result;\n        while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n          Horz = Horz.Prev;\n        if (Horz.Prev.Top.X == Result.Next.Top.X)\n        {\n          if (!IsClockwise)\n            Result = Horz.Prev;\n        }\n        else if (Horz.Prev.Top.X > Result.Next.Top.X)\n          Result = Horz.Prev;\n      }\n      while (E != Result)\n      {\n        E.NextInLML = E.Next;\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n        this.ReverseHorizontal(E);\n      Result = Result.Next;\n      //move to the edge just beyond current bound\n    }\n    else\n    {\n      while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        Result = Result.Prev;\n      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        Horz = Result;\n        while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n          Horz = Horz.Next;\n        if (Horz.Next.Top.X == Result.Prev.Top.X)\n        {\n          if (!IsClockwise)\n            Result = Horz.Next;\n        }\n        else if (Horz.Next.Top.X > Result.Prev.Top.X)\n          Result = Horz.Next;\n      }\n      while (E != Result)\n      {\n        E.NextInLML = E.Prev;\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Prev;\n      }\n      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n        this.ReverseHorizontal(E);\n      Result = Result.Prev;\n      //move to the edge just beyond current bound\n    }\n  }\n  if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n  {\n    //if edges still remain in the current bound beyond the skip edge then\n    //create another LocMin and call ProcessBound once more\n    E = Result;\n    if (IsClockwise)\n    {\n      while (E.Top.Y == E.Next.Bot.Y)\n        E = E.Next;\n      //don't include top horizontals when parsing a bound a second time,\n      //they will be contained in the opposite bound ...\n      while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n    }\n    else\n    {\n      while (E.Top.Y == E.Prev.Bot.Y)\n        E = E.Prev;\n      while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n    }\n    if (E == Result)\n    {\n      if (IsClockwise)\n        Result = E.Next;\n      else\n        Result = E.Prev;\n    }\n    else\n    {\n      //there are more edges in the bound beyond result starting with E\n      if (IsClockwise)\n        E = Result.Next;\n      else\n        E = Result.Prev;\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.WindDelta = 0;\n      Result = this.ProcessBound(locMin.RightBound, IsClockwise);\n      this.InsertLocalMinima(locMin);\n    }\n  }\n  return Result;\n};\nClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n{\n  if (use_lines)\n  {\n    if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n      ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n  }\n  else\n  {\n    if (!Closed)\n      ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n  }\n  var highI = pg.length - 1;\n  if (Closed)\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n  --highI;\n  while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n  --highI;\n  if ((Closed && highI < 2) || (!Closed && highI < 1))\n    return false;\n  //create a new edge array ...\n  var edges = new Array();\n  for (var i = 0; i <= highI; i++)\n    edges.push(new ClipperLib.TEdge());\n  var IsFlat = true;\n  //1. Basic (first) edge initialization ...\n\n  //edges[1].Curr = pg[1];\n  edges[1].Curr.X = pg[1].X;\n  edges[1].Curr.Y = pg[1].Y;\n\n  var $1 = {Value: this.m_UseFullRange};\n  this.RangeTest(pg[0], $1);\n  this.m_UseFullRange = $1.Value;\n\n  $1.Value = this.m_UseFullRange;\n  this.RangeTest(pg[highI], $1);\n  this.m_UseFullRange = $1.Value;\n\n  this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n  this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n  for (var i = highI - 1; i >= 1; --i)\n  {\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[i], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n  }\n\n  var eStart = edges[0];\n  //2. Remove duplicate vertices, and (when closed) collinear edges ...\n  var E = eStart,\n    eLoopStop = eStart;\n  for (;;)\n  {\n    if (ClipperLib.IntPoint.op_Equality(E.Curr, E.Next.Curr))\n    {\n      if (E == E.Next)\n        break;\n      if (E == eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      eLoopStop = E;\n      continue;\n    }\n    if (E.Prev == E.Next)\n      break;\n    else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n    {\n      //Collinear edges are allowed for open paths but in closed paths\n      //the default is to merge adjacent collinear edges into a single edge.\n      //However, if the PreserveCollinear property is enabled, only overlapping\n      //collinear edges (ie spikes) will be removed from closed paths.\n      if (E == eStart)\n        eStart = E.Next;\n      E = this.RemoveEdge(E);\n      E = E.Prev;\n      eLoopStop = E;\n      continue;\n    }\n    E = E.Next;\n    if (E == eLoopStop)\n      break;\n  }\n  if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n    return false;\n  if (!Closed)\n  {\n    this.m_HasOpenPaths = true;\n    eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n  }\n  //3. Do second stage of edge initialization ...\n  var eHighest = eStart;\n  E = eStart;\n  do {\n    this.InitEdge2(E, polyType);\n    E = E.Next;\n    if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n      IsFlat = false;\n  }\n  while (E != eStart)\n  //4. Finally, add edge bounds to LocalMinima list ...\n  //Totally flat paths must be handled differently when adding them\n  //to LocalMinima list to avoid endless loops etc ...\n  if (IsFlat)\n  {\n    if (Closed)\n      return false;\n    E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    if (E.Prev.Bot.X < E.Prev.Top.X)\n      this.ReverseHorizontal(E.Prev);\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin.Y = E.Bot.Y;\n    locMin.LeftBound = null;\n    locMin.RightBound = E;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    locMin.RightBound.WindDelta = 0;\n    while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n    {\n      E.NextInLML = E.Next;\n      if (E.Bot.X != E.Prev.Top.X)\n        this.ReverseHorizontal(E);\n      E = E.Next;\n    }\n    this.InsertLocalMinima(locMin);\n    this.m_edges.push(edges);\n    return true;\n  }\n  this.m_edges.push(edges);\n  var clockwise;\n  var EMin = null;\n  for (;;)\n  {\n    E = this.FindNextLocMin(E);\n    if (E == EMin)\n      break;\n    else if (EMin == null)\n      EMin = E;\n    //E and E.Prev now share a local minima (left aligned if horizontal).\n    //Compare their slopes to find which starts which bound ...\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin.Y = E.Bot.Y;\n    if (E.Dx < E.Prev.Dx)\n    {\n      locMin.LeftBound = E.Prev;\n      locMin.RightBound = E;\n      clockwise = false;\n      //Q.nextInLML = Q.prev\n    }\n    else\n    {\n      locMin.LeftBound = E;\n      locMin.RightBound = E.Prev;\n      clockwise = true;\n      //Q.nextInLML = Q.next\n    }\n    locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    if (!Closed)\n      locMin.LeftBound.WindDelta = 0;\n    else if (locMin.LeftBound.Next == locMin.RightBound)\n      locMin.LeftBound.WindDelta = -1;\n    else\n      locMin.LeftBound.WindDelta = 1;\n    locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n    E = this.ProcessBound(locMin.LeftBound, clockwise);\n    var E2 = this.ProcessBound(locMin.RightBound, !clockwise);\n    if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n      locMin.LeftBound = null;\n    else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n      locMin.RightBound = null;\n    this.InsertLocalMinima(locMin);\n    if (!clockwise)\n      E = E2;\n  }\n  return true;\n};\nClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n{\n  //  console.log(\"-------------------------------------------\");\n  //  console.log(JSON.stringify(ppg));\n  var result = false;\n  for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n    if (this.AddPath(ppg[i], polyType, closed))\n      result = true;\n  return result;\n};\n//------------------------------------------------------------------------------\nClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n{\n  if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||\n    (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n    return false;\n  else if (pt1.X != pt3.X)\n    return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n  else\n    return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n};\nClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n{\n  //removes e from double_linked_list (but without removing from memory)\n  e.Prev.Next = e.Next;\n  e.Next.Prev = e.Prev;\n  var result = e.Next;\n  e.Prev = null; //flag as removed (see ClipperBase.Clear)\n  return result;\n};\nClipperLib.ClipperBase.prototype.SetDx = function (e)\n{\n  e.Delta.X = (e.Top.X - e.Bot.X);\n  e.Delta.Y = (e.Top.Y - e.Bot.Y);\n  if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n  else e.Dx = (e.Delta.X) / (e.Delta.Y);\n};\nClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n{\n  if (this.m_MinimaList === null)\n  {\n    this.m_MinimaList = newLm;\n  }\n  else if (newLm.Y >= this.m_MinimaList.Y)\n  {\n    newLm.Next = this.m_MinimaList;\n    this.m_MinimaList = newLm;\n  }\n  else\n  {\n    var tmpLm = this.m_MinimaList;\n    while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n      tmpLm = tmpLm.Next;\n    newLm.Next = tmpLm.Next;\n    tmpLm.Next = newLm;\n  }\n};\nClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n{\n  if (this.m_CurrentLM === null)\n    return;\n  this.m_CurrentLM = this.m_CurrentLM.Next;\n};\nClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n{\n  //swap horizontal edges' top and bottom x's so they follow the natural\n  //progression of the bounds - ie so their xbots will align with the\n  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n  var tmp = e.Top.X;\n  e.Top.X = e.Bot.X;\n  e.Bot.X = tmp;\n  if (use_xyz)\n  {\n    tmp = e.Top.Z;\n    e.Top.Z = e.Bot.Z;\n    e.Bot.Z = tmp;\n  }\n};\nClipperLib.ClipperBase.prototype.Reset = function ()\n{\n  this.m_CurrentLM = this.m_MinimaList;\n  if (this.m_CurrentLM == null)\n    return;\n  //ie nothing to process\n  //reset all edges ...\n  var lm = this.m_MinimaList;\n  while (lm != null)\n  {\n    var e = lm.LeftBound;\n    if (e != null)\n    {\n      //e.Curr = e.Bot;\n      e.Curr.X = e.Bot.X;\n      e.Curr.Y = e.Bot.Y;\n      e.Side = ClipperLib.EdgeSide.esLeft;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    e = lm.RightBound;\n    if (e != null)\n    {\n      //e.Curr = e.Bot;\n      e.Curr.X = e.Bot.X;\n      e.Curr.Y = e.Bot.Y;\n      e.Side = ClipperLib.EdgeSide.esRight;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n    lm = lm.Next;\n  }\n};\nClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n{\n  if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n  this.m_PolyOuts = null;\n  this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = null;\n  this.m_IntersectNodeComparer = null;\n  this.m_ExecuteLocked = false;\n  this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_Joins = null;\n  this.m_GhostJoins = null;\n  this.m_UsingPolyTree = false;\n  this.ReverseSolution = false;\n  this.StrictlySimple = false;\n  ClipperLib.ClipperBase.call(this);\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = new Array();\n  this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n  this.m_ExecuteLocked = false;\n  this.m_UsingPolyTree = false;\n  this.m_PolyOuts = new Array();\n  this.m_Joins = new Array();\n  this.m_GhostJoins = new Array();\n  this.ReverseSolution = (1 & InitOptions) !== 0;\n  this.StrictlySimple = (2 & InitOptions) !== 0;\n  this.PreserveCollinear = (4 & InitOptions) !== 0;\n  if (use_xyz)\n  {\n    this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n  }\n};\nClipperLib.Clipper.ioReverseSolution = 1;\nClipperLib.Clipper.ioStrictlySimple = 2;\nClipperLib.Clipper.ioPreserveCollinear = 4;\n\nClipperLib.Clipper.prototype.Clear = function ()\n{\n  if (this.m_edges.length === 0)\n    return;\n  //avoids problems with ClipperBase destructor\n  this.DisposeAllPolyPts();\n  ClipperLib.ClipperBase.prototype.Clear.call(this);\n};\n\nClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n{\n  while (this.m_Scanbeam !== null)\n  {\n    var sb2 = this.m_Scanbeam.Next;\n    this.m_Scanbeam = null;\n    this.m_Scanbeam = sb2;\n  }\n};\nClipperLib.Clipper.prototype.Reset = function ()\n{\n  ClipperLib.ClipperBase.prototype.Reset.call(this);\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n\n  var lm = this.m_MinimaList;\n  while (lm !== null)\n  {\n    this.InsertScanbeam(lm.Y);\n    lm = lm.Next;\n  }\n};\nClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n{\n  if (this.m_Scanbeam === null)\n  {\n    this.m_Scanbeam = new ClipperLib.Scanbeam();\n    this.m_Scanbeam.Next = null;\n    this.m_Scanbeam.Y = Y;\n  }\n  else if (Y > this.m_Scanbeam.Y)\n  {\n    var newSb = new ClipperLib.Scanbeam();\n    newSb.Y = Y;\n    newSb.Next = this.m_Scanbeam;\n    this.m_Scanbeam = newSb;\n  }\n  else\n  {\n    var sb2 = this.m_Scanbeam;\n    while (sb2.Next !== null && (Y <= sb2.Next.Y))\n      sb2 = sb2.Next;\n    if (Y == sb2.Y)\n      return;\n    //ie ignores duplicates\n    var newSb = new ClipperLib.Scanbeam();\n    newSb.Y = Y;\n    newSb.Next = sb2.Next;\n    sb2.Next = newSb;\n  }\n};\n// ************************************\nClipperLib.Clipper.prototype.Execute = function ()\n{\n  var a = arguments,\n    alen = a.length,\n    ispolytree = a[1] instanceof ClipperLib.PolyTree;\n  if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      solution = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    if (this.m_HasOpenPaths)\n      ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n    this.m_ExecuteLocked = true;\n    ClipperLib.Clear(solution);\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = false;\n    try\n    {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult(solution);\n    }\n    finally\n    {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  }\n  else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n  {\n    var clipType = a[0],\n      polytree = a[1],\n      subjFillType = a[2],\n      clipFillType = a[3];\n    if (this.m_ExecuteLocked)\n      return false;\n    this.m_ExecuteLocked = true;\n    this.m_SubjFillType = subjFillType;\n    this.m_ClipFillType = clipFillType;\n    this.m_ClipType = clipType;\n    this.m_UsingPolyTree = true;\n    try\n    {\n      var succeeded = this.ExecuteInternal();\n      //build the return polygons ...\n      if (succeeded) this.BuildResult2(polytree);\n    }\n    finally\n    {\n      this.DisposeAllPolyPts();\n      this.m_ExecuteLocked = false;\n    }\n    return succeeded;\n  }\n  else if (alen == 2 && !ispolytree) // function (clipType, solution)\n  {\n    var clipType = a[0],\n      solution = a[1];\n    return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  }\n  else if (alen == 2 && ispolytree) // function (clipType, polytree)\n  {\n    var clipType = a[0],\n      polytree = a[1];\n    return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n  }\n};\nClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n{\n  //skip if an outermost polygon or\n  //already already points to the correct FirstLeft ...\n  if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n    return;\n  var orfl = outRec.FirstLeft;\n  while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n    orfl = orfl.FirstLeft;\n  outRec.FirstLeft = orfl;\n};\nClipperLib.Clipper.prototype.ExecuteInternal = function ()\n{\n  try\n  {\n    this.Reset();\n    if (this.m_CurrentLM === null)\n      return false;\n    var botY = this.PopScanbeam();\n    do {\n      this.InsertLocalMinimaIntoAEL(botY);\n      ClipperLib.Clear(this.m_GhostJoins);\n      this.ProcessHorizontals(false);\n      if (this.m_Scanbeam === null)\n        break;\n      var topY = this.PopScanbeam();\n      //console.log(\"botY:\" + botY + \", topY:\" + topY);\n      if (!this.ProcessIntersections(botY, topY))\n        return false;\n      this.ProcessEdgesAtTopOfScanbeam(topY);\n      botY = topY;\n    }\n    while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n    //fix orientations ...\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null || outRec.IsOpen)\n        continue;\n      if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n        this.ReversePolyPtLinks(outRec.Pts);\n    }\n    this.JoinCommonEdges();\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts !== null && !outRec.IsOpen)\n        this.FixupOutPolygon(outRec);\n    }\n    if (this.StrictlySimple)\n      this.DoSimplePolygons();\n    return true;\n  }\n  finally\n  {\n    ClipperLib.Clear(this.m_Joins);\n    ClipperLib.Clear(this.m_GhostJoins);\n  }\n};\nClipperLib.Clipper.prototype.PopScanbeam = function ()\n{\n  var Y = this.m_Scanbeam.Y;\n  var sb2 = this.m_Scanbeam;\n  this.m_Scanbeam = this.m_Scanbeam.Next;\n  sb2 = null;\n  return Y;\n};\nClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n{\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n    this.DisposeOutRec(i);\n  ClipperLib.Clear(this.m_PolyOuts);\n};\nClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n{\n  var outRec = this.m_PolyOuts[index];\n  if (outRec.Pts !== null)\n    this.DisposeOutPts(outRec.Pts);\n  outRec = null;\n  this.m_PolyOuts[index] = null;\n};\nClipperLib.Clipper.prototype.DisposeOutPts = function (pp)\n{\n  if (pp === null)\n    return;\n  var tmpPp = null;\n  pp.Prev.Next = null;\n  while (pp !== null)\n  {\n    tmpPp = pp;\n    pp = pp.Next;\n    tmpPp = null;\n  }\n};\nClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n{\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op1;\n  j.OutPt2 = Op2;\n  //j.OffPt = OffPt;\n  j.OffPt.X = OffPt.X;\n  j.OffPt.Y = OffPt.Y;\n  this.m_Joins.push(j);\n};\nClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n{\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op;\n  //j.OffPt = OffPt;\n  j.OffPt.X = OffPt.X;\n  j.OffPt.Y = OffPt.Y;\n  this.m_GhostJoins.push(j);\n};\nif (use_xyz)\n{\n  ClipperLib.Clipper.prototype.SetZ = function (pt, e)\n  {\n    pt.Z = 0;\n    if (this.ZFillFunction !== null)\n    {\n      //put the 'preferred' point as first parameter ...\n      if (e.OutIdx < 0)\n        this.ZFillFunction(e.Bot, e.Top, pt); //outside a path so presume entering\n      else\n        this.ZFillFunction(e.Top, e.Bot, pt); //inside a path so presume exiting\n    }\n  };\n  //------------------------------------------------------------------------------\n}\nClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n{\n  while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n  {\n    var lb = this.m_CurrentLM.LeftBound;\n    var rb = this.m_CurrentLM.RightBound;\n    this.PopLocalMinima();\n    var Op1 = null;\n    if (lb === null)\n    {\n      this.InsertEdgeIntoAEL(rb, null);\n      this.SetWindingCount(rb);\n      if (this.IsContributing(rb))\n        Op1 = this.AddOutPt(rb, rb.Bot);\n    }\n    else if (rb == null)\n    {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.SetWindingCount(lb);\n      if (this.IsContributing(lb))\n        Op1 = this.AddOutPt(lb, lb.Bot);\n      this.InsertScanbeam(lb.Top.Y);\n    }\n    else\n    {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.InsertEdgeIntoAEL(rb, lb);\n      this.SetWindingCount(lb);\n      rb.WindCnt = lb.WindCnt;\n      rb.WindCnt2 = lb.WindCnt2;\n      if (this.IsContributing(lb))\n        Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n      this.InsertScanbeam(lb.Top.Y);\n    }\n    if (rb != null)\n    {\n      if (ClipperLib.ClipperBase.IsHorizontal(rb))\n        this.AddEdgeToSEL(rb);\n      else\n        this.InsertScanbeam(rb.Top.Y);\n    }\n    if (lb == null || rb == null) continue;\n    //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n    if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n    {\n      for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n      {\n        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n        //the 'ghost' join to a real join ready for later ...\n        var j = this.m_GhostJoins[i];\n        if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, rb.Bot, rb.Top))\n          this.AddJoin(j.OutPt1, Op1, j.OffPt);\n      }\n    }\n    if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n      lb.PrevInAEL.Curr.X == lb.Bot.X &&\n      lb.PrevInAEL.OutIdx >= 0 &&\n      ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n      lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n    {\n      var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n      this.AddJoin(Op1, Op2, lb.Top);\n    }\n    if (lb.NextInAEL != rb)\n    {\n      if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n        rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n        this.AddJoin(Op1, Op2, rb.Top);\n      }\n      var e = lb.NextInAEL;\n      if (e !== null)\n        while (e != rb)\n        {\n          //nb: For calculating winding counts etc, IntersectEdges() assumes\n          //that param1 will be to the right of param2 ABOVE the intersection ...\n          this.IntersectEdges(rb, e, lb.Curr, false);\n          //order important here\n          e = e.NextInAEL;\n        }\n    }\n  }\n};\nClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n{\n  if (this.m_ActiveEdges === null)\n  {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = null;\n    this.m_ActiveEdges = edge;\n  }\n  else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n  {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = this.m_ActiveEdges;\n    this.m_ActiveEdges.PrevInAEL = edge;\n    this.m_ActiveEdges = edge;\n  }\n  else\n  {\n    if (startEdge === null)\n      startEdge = this.m_ActiveEdges;\n    while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n      startEdge = startEdge.NextInAEL;\n    edge.NextInAEL = startEdge.NextInAEL;\n    if (startEdge.NextInAEL !== null)\n      startEdge.NextInAEL.PrevInAEL = edge;\n    edge.PrevInAEL = startEdge;\n    startEdge.NextInAEL = edge;\n  }\n};\nClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n{\n  if (e2.Curr.X == e1.Curr.X)\n  {\n    if (e2.Top.Y > e1.Top.Y)\n      return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n    else\n      return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n  }\n  else\n    return e2.Curr.X < e1.Curr.X;\n};\nClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n{\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n};\nClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n{\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  else\n    return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n};\nClipperLib.Clipper.prototype.IsContributing = function (edge)\n{\n  var pft, pft2;\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n  {\n    pft = this.m_SubjFillType;\n    pft2 = this.m_ClipFillType;\n  }\n  else\n  {\n    pft = this.m_ClipFillType;\n    pft2 = this.m_SubjFillType;\n  }\n  switch (pft)\n  {\n  case ClipperLib.PolyFillType.pftEvenOdd:\n    if (edge.WindDelta === 0 && edge.WindCnt != 1)\n      return false;\n    break;\n  case ClipperLib.PolyFillType.pftNonZero:\n    if (Math.abs(edge.WindCnt) != 1)\n      return false;\n    break;\n  case ClipperLib.PolyFillType.pftPositive:\n    if (edge.WindCnt != 1)\n      return false;\n    break;\n  default:\n    if (edge.WindCnt != -1)\n      return false;\n    break;\n  }\n  switch (this.m_ClipType)\n  {\n  case ClipperLib.ClipType.ctIntersection:\n    switch (pft2)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n    case ClipperLib.PolyFillType.pftNonZero:\n      return (edge.WindCnt2 !== 0);\n    case ClipperLib.PolyFillType.pftPositive:\n      return (edge.WindCnt2 > 0);\n    default:\n      return (edge.WindCnt2 < 0);\n    }\n  case ClipperLib.ClipType.ctUnion:\n    switch (pft2)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n    case ClipperLib.PolyFillType.pftNonZero:\n      return (edge.WindCnt2 === 0);\n    case ClipperLib.PolyFillType.pftPositive:\n      return (edge.WindCnt2 <= 0);\n    default:\n      return (edge.WindCnt2 >= 0);\n    }\n  case ClipperLib.ClipType.ctDifference:\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    else\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n  case ClipperLib.ClipType.ctXor:\n    if (edge.WindDelta === 0)\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    else\n      return true;\n  }\n  return true;\n};\nClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n{\n  var e = edge.PrevInAEL;\n  //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n  while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n    e = e.PrevInAEL;\n  if (e === null)\n  {\n    edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n    edge.WindCnt2 = 0;\n    e = this.m_ActiveEdges;\n    //ie get ready to calc WindCnt2\n  }\n  else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n  {\n    edge.WindCnt = 1;\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  else if (this.IsEvenOddFillType(edge))\n  {\n    //EvenOdd filling ...\n    if (edge.WindDelta === 0)\n    {\n      //are we inside a subj polygon ...\n      var Inside = true;\n      var e2 = e.PrevInAEL;\n      while (e2 !== null)\n      {\n        if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n          Inside = !Inside;\n        e2 = e2.PrevInAEL;\n      }\n      edge.WindCnt = (Inside ? 0 : 1);\n    }\n    else\n    {\n      edge.WindCnt = edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  else\n  {\n    //nonZero, Positive or Negative filling ...\n    if (e.WindCnt * e.WindDelta < 0)\n    {\n      //prev edge is 'decreasing' WindCount (WC) toward zero\n      //so we're outside the previous polygon ...\n      if (Math.abs(e.WindCnt) > 1)\n      {\n        //outside prev poly but still inside another.\n        //when reversing direction of prev poly use the same WC \n        if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      else\n        edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n    }\n    else\n    {\n      //prev edge is 'increasing' WindCount (WC) away from zero\n      //so we're inside the previous polygon ...\n      if (edge.WindDelta === 0)\n        edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n      else if (e.WindDelta * edge.WindDelta < 0)\n        edge.WindCnt = e.WindCnt;\n      else\n        edge.WindCnt = e.WindCnt + edge.WindDelta;\n    }\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL;\n    //ie get ready to calc WindCnt2\n  }\n  //update WindCnt2 ...\n  if (this.IsEvenOddAltFillType(edge))\n  {\n    //EvenOdd filling ...\n    while (e != edge)\n    {\n      if (e.WindDelta !== 0)\n        edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n      e = e.NextInAEL;\n    }\n  }\n  else\n  {\n    //nonZero, Positive or Negative filling ...\n    while (e != edge)\n    {\n      edge.WindCnt2 += e.WindDelta;\n      e = e.NextInAEL;\n    }\n  }\n};\nClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n{\n  //SEL pointers in PEdge are reused to build a list of horizontal edges.\n  //However, we don't need to worry about order with horizontal edge processing.\n  if (this.m_SortedEdges === null)\n  {\n    this.m_SortedEdges = edge;\n    edge.PrevInSEL = null;\n    edge.NextInSEL = null;\n  }\n  else\n  {\n    edge.NextInSEL = this.m_SortedEdges;\n    edge.PrevInSEL = null;\n    this.m_SortedEdges.PrevInSEL = edge;\n    this.m_SortedEdges = edge;\n  }\n};\nClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n{\n  var e = this.m_ActiveEdges;\n  this.m_SortedEdges = e;\n  while (e !== null)\n  {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e = e.NextInAEL;\n  }\n};\nClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n{\n  //check that one or other edge hasn't already been removed from AEL ...\n  if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n    return;\n  if (edge1.NextInAEL == edge2)\n  {\n    var next = edge2.NextInAEL;\n    if (next !== null)\n      next.PrevInAEL = edge1;\n    var prev = edge1.PrevInAEL;\n    if (prev !== null)\n      prev.NextInAEL = edge2;\n    edge2.PrevInAEL = prev;\n    edge2.NextInAEL = edge1;\n    edge1.PrevInAEL = edge2;\n    edge1.NextInAEL = next;\n  }\n  else if (edge2.NextInAEL == edge1)\n  {\n    var next = edge1.NextInAEL;\n    if (next !== null)\n      next.PrevInAEL = edge2;\n    var prev = edge2.PrevInAEL;\n    if (prev !== null)\n      prev.NextInAEL = edge1;\n    edge1.PrevInAEL = prev;\n    edge1.NextInAEL = edge2;\n    edge2.PrevInAEL = edge1;\n    edge2.NextInAEL = next;\n  }\n  else\n  {\n    var next = edge1.NextInAEL;\n    var prev = edge1.PrevInAEL;\n    edge1.NextInAEL = edge2.NextInAEL;\n    if (edge1.NextInAEL !== null)\n      edge1.NextInAEL.PrevInAEL = edge1;\n    edge1.PrevInAEL = edge2.PrevInAEL;\n    if (edge1.PrevInAEL !== null)\n      edge1.PrevInAEL.NextInAEL = edge1;\n    edge2.NextInAEL = next;\n    if (edge2.NextInAEL !== null)\n      edge2.NextInAEL.PrevInAEL = edge2;\n    edge2.PrevInAEL = prev;\n    if (edge2.PrevInAEL !== null)\n      edge2.PrevInAEL.NextInAEL = edge2;\n  }\n  if (edge1.PrevInAEL === null)\n    this.m_ActiveEdges = edge1;\n  else if (edge2.PrevInAEL === null)\n    this.m_ActiveEdges = edge2;\n};\nClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n{\n  if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n    return;\n  if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n    return;\n  if (edge1.NextInSEL == edge2)\n  {\n    var next = edge2.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge1;\n    var prev = edge1.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    edge2.NextInSEL = edge1;\n    edge1.PrevInSEL = edge2;\n    edge1.NextInSEL = next;\n  }\n  else if (edge2.NextInSEL == edge1)\n  {\n    var next = edge1.NextInSEL;\n    if (next !== null)\n      next.PrevInSEL = edge2;\n    var prev = edge2.PrevInSEL;\n    if (prev !== null)\n      prev.NextInSEL = edge1;\n    edge1.PrevInSEL = prev;\n    edge1.NextInSEL = edge2;\n    edge2.PrevInSEL = edge1;\n    edge2.NextInSEL = next;\n  }\n  else\n  {\n    var next = edge1.NextInSEL;\n    var prev = edge1.PrevInSEL;\n    edge1.NextInSEL = edge2.NextInSEL;\n    if (edge1.NextInSEL !== null)\n      edge1.NextInSEL.PrevInSEL = edge1;\n    edge1.PrevInSEL = edge2.PrevInSEL;\n    if (edge1.PrevInSEL !== null)\n      edge1.PrevInSEL.NextInSEL = edge1;\n    edge2.NextInSEL = next;\n    if (edge2.NextInSEL !== null)\n      edge2.NextInSEL.PrevInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    if (edge2.PrevInSEL !== null)\n      edge2.PrevInSEL.NextInSEL = edge2;\n  }\n  if (edge1.PrevInSEL === null)\n    this.m_SortedEdges = edge1;\n  else if (edge2.PrevInSEL === null)\n    this.m_SortedEdges = edge2;\n};\nClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n{\n  this.AddOutPt(e1, pt);\n  if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n  if (e1.OutIdx == e2.OutIdx)\n  {\n    e1.OutIdx = -1;\n    e2.OutIdx = -1;\n  }\n  else if (e1.OutIdx < e2.OutIdx)\n    this.AppendPolygon(e1, e2);\n  else\n    this.AppendPolygon(e2, e1);\n};\nClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n{\n  var result;\n  var e, prevE;\n  if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n  {\n    result = this.AddOutPt(e1, pt);\n    e2.OutIdx = e1.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esLeft;\n    e2.Side = ClipperLib.EdgeSide.esRight;\n    e = e1;\n    if (e.PrevInAEL == e2)\n      prevE = e2.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  }\n  else\n  {\n    result = this.AddOutPt(e2, pt);\n    e1.OutIdx = e2.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esRight;\n    e2.Side = ClipperLib.EdgeSide.esLeft;\n    e = e2;\n    if (e.PrevInAEL == e1)\n      prevE = e1.PrevInAEL;\n    else\n      prevE = e.PrevInAEL;\n  }\n  if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n  {\n    var outPt = this.AddOutPt(prevE, pt);\n    this.AddJoin(result, outPt, e.Top);\n  }\n  return result;\n};\nClipperLib.Clipper.prototype.CreateOutRec = function ()\n{\n  var result = new ClipperLib.OutRec();\n  result.Idx = -1;\n  result.IsHole = false;\n  result.IsOpen = false;\n  result.FirstLeft = null;\n  result.Pts = null;\n  result.BottomPt = null;\n  result.PolyNode = null;\n  this.m_PolyOuts.push(result);\n  result.Idx = this.m_PolyOuts.length - 1;\n  return result;\n};\nClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n{\n  var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n  if (e.OutIdx < 0)\n  {\n    var outRec = this.CreateOutRec();\n    outRec.IsOpen = (e.WindDelta === 0);\n    var newOp = new ClipperLib.OutPt();\n    outRec.Pts = newOp;\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt.X = pt.X;\n    newOp.Pt.Y = pt.Y;\n    newOp.Next = newOp;\n    newOp.Prev = newOp;\n    if (!outRec.IsOpen)\n      this.SetHoleState(e, outRec);\n    if (use_xyz)\n    {\n      if (ClipperLib.IntPoint.op_Equality(pt, e.Bot))\n      {\n        //newOp.Pt = e.Bot;\n        newOp.Pt.X = e.Bot.X;\n        newOp.Pt.Y = e.Bot.Y;\n        newOp.Pt.Z = e.Bot.Z;\n      }\n      else if (ClipperLib.IntPoint.op_Equality(pt, e.Top))\n      {\n        //newOp.Pt = e.Top;\n        newOp.Pt.X = e.Top.X;\n        newOp.Pt.Y = e.Top.Y;\n        newOp.Pt.Z = e.Top.Z;\n      }\n      else\n        this.SetZ(newOp.Pt, e);\n    }\n    e.OutIdx = outRec.Idx;\n    //nb: do this after SetZ !\n    return newOp;\n  }\n  else\n  {\n    var outRec = this.m_PolyOuts[e.OutIdx];\n    //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n    var op = outRec.Pts;\n    if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n      return op;\n    else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n      return op.Prev;\n    var newOp = new ClipperLib.OutPt();\n    newOp.Idx = outRec.Idx;\n    //newOp.Pt = pt;\n    newOp.Pt.X = pt.X;\n    newOp.Pt.Y = pt.Y;\n    newOp.Next = op;\n    newOp.Prev = op.Prev;\n    newOp.Prev.Next = newOp;\n    op.Prev = newOp;\n    if (ToFront)\n      outRec.Pts = newOp;\n    if (use_xyz)\n    {\n      if (ClipperLib.IntPoint.op_Equality(pt, e.Bot))\n      {\n        //newOp.Pt = e.Bot;\n        newOp.Pt.X = e.Bot.X;\n        newOp.Pt.Y = e.Bot.Y;\n        newOp.Pt.Z = e.Bot.Z;\n      }\n      else if (ClipperLib.IntPoint.op_Equality(pt, e.Top))\n      {\n        //newOp.Pt = e.Top;\n        newOp.Pt.X = e.Top.X;\n        newOp.Pt.Y = e.Top.Y;\n        newOp.Pt.Z = e.Top.Z;\n      }\n      else\n        this.SetZ(newOp.Pt, e);\n    }\n    return newOp;\n  }\n};\nClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n{\n  var tmp = new ClipperLib.IntPoint(pt1.Value);\n  //pt1.Value = pt2.Value;\n  pt1.Value.X = pt2.Value.X;\n  pt1.Value.Y = pt2.Value.Y;\n  //pt2.Value = tmp;\n  pt2.Value.X = tmp.X;\n  pt2.Value.Y = tmp.Y;\n};\nClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (Pt1a, Pt1b, Pt2a, Pt2b)\n{\n  //precondition: both segments are horizontal\n  if ((Pt1a.X > Pt2a.X) == (Pt1a.X < Pt2b.X))\n    return true;\n  else if ((Pt1b.X > Pt2a.X) == (Pt1b.X < Pt2b.X))\n    return true;\n  else if ((Pt2a.X > Pt1a.X) == (Pt2a.X < Pt1b.X))\n    return true;\n  else if ((Pt2b.X > Pt1a.X) == (Pt2b.X < Pt1b.X))\n    return true;\n  else if ((Pt1a.X == Pt2a.X) && (Pt1b.X == Pt2b.X))\n    return true;\n  else if ((Pt1a.X == Pt2b.X) && (Pt1b.X == Pt2a.X))\n    return true;\n  else\n    return false;\n};\nClipperLib.Clipper.prototype.InsertPolyPtBetween = function (p1, p2, pt)\n{\n  var result = new ClipperLib.OutPt();\n  //result.Pt = pt;\n  result.Pt.X = pt.X;\n  result.Pt.Y = pt.Y;\n  if (p2 == p1.Next)\n  {\n    p1.Next = result;\n    p2.Prev = result;\n    result.Next = p2;\n    result.Prev = p1;\n  }\n  else\n  {\n    p2.Next = result;\n    p1.Prev = result;\n    result.Next = p1;\n    result.Prev = p2;\n  }\n  return result;\n};\nClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n{\n  var isHole = false;\n  var e2 = e.PrevInAEL;\n  while (e2 !== null)\n  {\n    if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n    {\n      isHole = !isHole;\n      if (outRec.FirstLeft === null)\n        outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n    }\n    e2 = e2.PrevInAEL;\n  }\n  if (isHole)\n    outRec.IsHole = true;\n};\nClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n{\n  if (pt1.Y == pt2.Y)\n    return ClipperLib.ClipperBase.horizontal;\n  else\n    return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n};\nClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n{\n  var p = btmPt1.Prev;\n  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n    p = p.Prev;\n  var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt1.Next;\n  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n    p = p.Next;\n  var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt2.Prev;\n  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n    p = p.Prev;\n  var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  p = btmPt2.Next;\n  while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n    p = p.Next;\n  var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n};\nClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n{\n  var dups = null;\n  var p = pp.Next;\n  while (p != pp)\n  {\n    if (p.Pt.Y > pp.Pt.Y)\n    {\n      pp = p;\n      dups = null;\n    }\n    else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n    {\n      if (p.Pt.X < pp.Pt.X)\n      {\n        dups = null;\n        pp = p;\n      }\n      else\n      {\n        if (p.Next != pp && p.Prev != pp)\n          dups = p;\n      }\n    }\n    p = p.Next;\n  }\n  if (dups !== null)\n  {\n    //there appears to be at least 2 vertices at bottomPt so ...\n    while (dups != p)\n    {\n      if (!this.FirstIsBottomPt(p, dups))\n        pp = dups;\n      dups = dups.Next;\n      while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n        dups = dups.Next;\n    }\n  }\n  return pp;\n};\nClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n{\n  //work out which polygon fragment has the correct hole state ...\n  if (outRec1.BottomPt === null)\n    outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n  if (outRec2.BottomPt === null)\n    outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n  var bPt1 = outRec1.BottomPt;\n  var bPt2 = outRec2.BottomPt;\n  if (bPt1.Pt.Y > bPt2.Pt.Y)\n    return outRec1;\n  else if (bPt1.Pt.Y < bPt2.Pt.Y)\n    return outRec2;\n  else if (bPt1.Pt.X < bPt2.Pt.X)\n    return outRec1;\n  else if (bPt1.Pt.X > bPt2.Pt.X)\n    return outRec2;\n  else if (bPt1.Next == bPt1)\n    return outRec2;\n  else if (bPt2.Next == bPt2)\n    return outRec1;\n  else if (this.FirstIsBottomPt(bPt1, bPt2))\n    return outRec1;\n  else\n    return outRec2;\n};\nClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n{\n  do {\n    outRec1 = outRec1.FirstLeft;\n    if (outRec1 == outRec2)\n      return true;\n  }\n  while (outRec1 !== null)\n  return false;\n};\nClipperLib.Clipper.prototype.GetOutRec = function (idx)\n{\n  var outrec = this.m_PolyOuts[idx];\n  while (outrec != this.m_PolyOuts[outrec.Idx])\n    outrec = this.m_PolyOuts[outrec.Idx];\n  return outrec;\n};\nClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n{\n  //get the start and ends of both output polygons ...\n  var outRec1 = this.m_PolyOuts[e1.OutIdx];\n  var outRec2 = this.m_PolyOuts[e2.OutIdx];\n  var holeStateRec;\n  if (this.Param1RightOfParam2(outRec1, outRec2))\n    holeStateRec = outRec2;\n  else if (this.Param1RightOfParam2(outRec2, outRec1))\n    holeStateRec = outRec1;\n  else\n    holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n  var p1_lft = outRec1.Pts;\n  var p1_rt = p1_lft.Prev;\n  var p2_lft = outRec2.Pts;\n  var p2_rt = p2_lft.Prev;\n  var side;\n  //join e2 poly onto e1 poly and delete pointers to e2 ...\n  if (e1.Side == ClipperLib.EdgeSide.esLeft)\n  {\n    if (e2.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      //z y x a b c\n      this.ReversePolyPtLinks(p2_lft);\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      outRec1.Pts = p2_rt;\n    }\n    else\n    {\n      //x y z a b c\n      p2_rt.Next = p1_lft;\n      p1_lft.Prev = p2_rt;\n      p2_lft.Prev = p1_rt;\n      p1_rt.Next = p2_lft;\n      outRec1.Pts = p2_lft;\n    }\n    side = ClipperLib.EdgeSide.esLeft;\n  }\n  else\n  {\n    if (e2.Side == ClipperLib.EdgeSide.esRight)\n    {\n      //a b c z y x\n      this.ReversePolyPtLinks(p2_lft);\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n    }\n    else\n    {\n      //a b c x y z\n      p1_rt.Next = p2_lft;\n      p2_lft.Prev = p1_rt;\n      p1_lft.Prev = p2_rt;\n      p2_rt.Next = p1_lft;\n    }\n    side = ClipperLib.EdgeSide.esRight;\n  }\n  outRec1.BottomPt = null;\n  if (holeStateRec == outRec2)\n  {\n    if (outRec2.FirstLeft != outRec1)\n      outRec1.FirstLeft = outRec2.FirstLeft;\n    outRec1.IsHole = outRec2.IsHole;\n  }\n  outRec2.Pts = null;\n  outRec2.BottomPt = null;\n  outRec2.FirstLeft = outRec1;\n  var OKIdx = e1.OutIdx;\n  var ObsoleteIdx = e2.OutIdx;\n  e1.OutIdx = -1;\n  //nb: safe because we only get here via AddLocalMaxPoly\n  e2.OutIdx = -1;\n  var e = this.m_ActiveEdges;\n  while (e !== null)\n  {\n    if (e.OutIdx == ObsoleteIdx)\n    {\n      e.OutIdx = OKIdx;\n      e.Side = side;\n      break;\n    }\n    e = e.NextInAEL;\n  }\n  outRec2.Idx = outRec1.Idx;\n};\nClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n{\n  if (pp === null)\n    return;\n  var pp1;\n  var pp2;\n  pp1 = pp;\n  do {\n    pp2 = pp1.Next;\n    pp1.Next = pp1.Prev;\n    pp1.Prev = pp2;\n    pp1 = pp2;\n  }\n  while (pp1 != pp)\n};\nClipperLib.Clipper.SwapSides = function (edge1, edge2)\n{\n  var side = edge1.Side;\n  edge1.Side = edge2.Side;\n  edge2.Side = side;\n};\nClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n{\n  var outIdx = edge1.OutIdx;\n  edge1.OutIdx = edge2.OutIdx;\n  edge2.OutIdx = outIdx;\n};\nClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt, protect)\n{\n  //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n  //e2 in AEL except when e1 is being inserted at the intersection point ...\n  var e1stops = !protect && e1.NextInLML === null &&\n    e1.Top.X == pt.X && e1.Top.Y == pt.Y;\n  var e2stops = !protect && e2.NextInLML === null &&\n    e2.Top.X == pt.X && e2.Top.Y == pt.Y;\n  var e1Contributing = (e1.OutIdx >= 0);\n  var e2Contributing = (e2.OutIdx >= 0);\n  if (use_lines)\n  {\n    //if either edge is on an OPEN path ...\n    if (e1.WindDelta === 0 || e2.WindDelta === 0)\n    {\n      //ignore subject-subject open path intersections UNLESS they\n      //are both open paths, AND they are both 'contributing maximas' ...\n      if (e1.WindDelta === 0 && e2.WindDelta === 0)\n      {\n        if ((e1stops || e2stops) && e1Contributing && e2Contributing)\n          this.AddLocalMaxPoly(e1, e2, pt);\n      }\n      //if intersecting a subj line with a subj poly ...\n      else if (e1.PolyTyp == e2.PolyTyp &&\n        e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n      {\n        if (e1.WindDelta === 0)\n        {\n          if (e2Contributing)\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n        }\n        else\n        {\n          if (e1Contributing)\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n      }\n      else if (e1.PolyTyp != e2.PolyTyp)\n      {\n        if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n          (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n        {\n          this.AddOutPt(e1, pt);\n          if (e1Contributing)\n            e1.OutIdx = -1;\n        }\n        else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n          (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n        {\n          this.AddOutPt(e2, pt);\n          if (e2Contributing)\n            e2.OutIdx = -1;\n        }\n      }\n      if (e1stops)\n        if (e1.OutIdx < 0)\n          this.DeleteFromAEL(e1);\n        else\n          ClipperLib.Error(\"Error intersecting polylines\");\n      if (e2stops)\n        if (e2.OutIdx < 0)\n          this.DeleteFromAEL(e2);\n        else\n          ClipperLib.Error(\"Error intersecting polylines\");\n      return;\n    }\n  }\n  //update winding counts...\n  //assumes that e1 will be to the Right of e2 ABOVE the intersection\n  if (e1.PolyTyp == e2.PolyTyp)\n  {\n    if (this.IsEvenOddFillType(e1))\n    {\n      var oldE1WindCnt = e1.WindCnt;\n      e1.WindCnt = e2.WindCnt;\n      e2.WindCnt = oldE1WindCnt;\n    }\n    else\n    {\n      if (e1.WindCnt + e2.WindDelta === 0)\n        e1.WindCnt = -e1.WindCnt;\n      else\n        e1.WindCnt += e2.WindDelta;\n      if (e2.WindCnt - e1.WindDelta === 0)\n        e2.WindCnt = -e2.WindCnt;\n      else\n        e2.WindCnt -= e1.WindDelta;\n    }\n  }\n  else\n  {\n    if (!this.IsEvenOddFillType(e2))\n      e1.WindCnt2 += e2.WindDelta;\n    else\n      e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n    if (!this.IsEvenOddFillType(e1))\n      e2.WindCnt2 -= e1.WindDelta;\n    else\n      e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n  }\n  var e1FillType, e2FillType, e1FillType2, e2FillType2;\n  if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n  {\n    e1FillType = this.m_SubjFillType;\n    e1FillType2 = this.m_ClipFillType;\n  }\n  else\n  {\n    e1FillType = this.m_ClipFillType;\n    e1FillType2 = this.m_SubjFillType;\n  }\n  if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n  {\n    e2FillType = this.m_SubjFillType;\n    e2FillType2 = this.m_ClipFillType;\n  }\n  else\n  {\n    e2FillType = this.m_ClipFillType;\n    e2FillType2 = this.m_SubjFillType;\n  }\n  var e1Wc, e2Wc;\n  switch (e1FillType)\n  {\n  case ClipperLib.PolyFillType.pftPositive:\n    e1Wc = e1.WindCnt;\n    break;\n  case ClipperLib.PolyFillType.pftNegative:\n    e1Wc = -e1.WindCnt;\n    break;\n  default:\n    e1Wc = Math.abs(e1.WindCnt);\n    break;\n  }\n  switch (e2FillType)\n  {\n  case ClipperLib.PolyFillType.pftPositive:\n    e2Wc = e2.WindCnt;\n    break;\n  case ClipperLib.PolyFillType.pftNegative:\n    e2Wc = -e2.WindCnt;\n    break;\n  default:\n    e2Wc = Math.abs(e2.WindCnt);\n    break;\n  }\n  if (e1Contributing && e2Contributing)\n  {\n    if (e1stops || e2stops || (e1Wc !== 0 && e1Wc != 1) || (e2Wc !== 0 && e2Wc != 1) ||\n      (e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n      this.AddLocalMaxPoly(e1, e2, pt);\n    else\n    {\n      this.AddOutPt(e1, pt);\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if (e1Contributing)\n  {\n    if (e2Wc === 0 || e2Wc == 1)\n    {\n      this.AddOutPt(e1, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if (e2Contributing)\n  {\n    if (e1Wc === 0 || e1Wc == 1)\n    {\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  }\n  else if ((e1Wc === 0 || e1Wc == 1) &&\n    (e2Wc === 0 || e2Wc == 1) && !e1stops && !e2stops)\n  {\n    //neither edge is currently contributing ...\n    var e1Wc2, e2Wc2;\n    switch (e1FillType2)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc2 = e1.WindCnt2;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc2 = -e1.WindCnt2;\n      break;\n    default:\n      e1Wc2 = Math.abs(e1.WindCnt2);\n      break;\n    }\n    switch (e2FillType2)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc2 = e2.WindCnt2;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc2 = -e2.WindCnt2;\n      break;\n    default:\n      e2Wc2 = Math.abs(e2.WindCnt2);\n      break;\n    }\n    if (e1.PolyTyp != e2.PolyTyp)\n      this.AddLocalMinPoly(e1, e2, pt);\n    else if (e1Wc == 1 && e2Wc == 1)\n      switch (this.m_ClipType)\n      {\n      case ClipperLib.ClipType.ctIntersection:\n        if (e1Wc2 > 0 && e2Wc2 > 0)\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctUnion:\n        if (e1Wc2 <= 0 && e2Wc2 <= 0)\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctDifference:\n        if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n          ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n          this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      case ClipperLib.ClipType.ctXor:\n        this.AddLocalMinPoly(e1, e2, pt);\n        break;\n      }\n    else\n      ClipperLib.Clipper.SwapSides(e1, e2);\n  }\n  if ((e1stops != e2stops) &&\n    ((e1stops && (e1.OutIdx >= 0)) || (e2stops && (e2.OutIdx >= 0))))\n  {\n    ClipperLib.Clipper.SwapSides(e1, e2);\n    ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n  }\n  //finally, delete any non-contributing maxima edges  ...\n  if (e1stops)\n    this.DeleteFromAEL(e1);\n  if (e2stops)\n    this.DeleteFromAEL(e2);\n};\nClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n{\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n    return;\n  //already deleted\n  if (AelPrev !== null)\n    AelPrev.NextInAEL = AelNext;\n  else\n    this.m_ActiveEdges = AelNext;\n  if (AelNext !== null)\n    AelNext.PrevInAEL = AelPrev;\n  e.NextInAEL = null;\n  e.PrevInAEL = null;\n};\nClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n{\n  var SelPrev = e.PrevInSEL;\n  var SelNext = e.NextInSEL;\n  if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n    return;\n  //already deleted\n  if (SelPrev !== null)\n    SelPrev.NextInSEL = SelNext;\n  else\n    this.m_SortedEdges = SelNext;\n  if (SelNext !== null)\n    SelNext.PrevInSEL = SelPrev;\n  e.NextInSEL = null;\n  e.PrevInSEL = null;\n};\nClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n{\n  if (e.NextInLML === null)\n    ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  e.NextInLML.OutIdx = e.OutIdx;\n  if (AelPrev !== null)\n    AelPrev.NextInAEL = e.NextInLML;\n  else\n    this.m_ActiveEdges = e.NextInLML;\n  if (AelNext !== null)\n    AelNext.PrevInAEL = e.NextInLML;\n  e.NextInLML.Side = e.Side;\n  e.NextInLML.WindDelta = e.WindDelta;\n  e.NextInLML.WindCnt = e.WindCnt;\n  e.NextInLML.WindCnt2 = e.WindCnt2;\n  e = e.NextInLML;\n  //    e.Curr = e.Bot;\n  e.Curr.X = e.Bot.X;\n  e.Curr.Y = e.Bot.Y;\n  e.PrevInAEL = AelPrev;\n  e.NextInAEL = AelNext;\n  if (!ClipperLib.ClipperBase.IsHorizontal(e))\n    this.InsertScanbeam(e.Top.Y);\n  return e;\n};\nClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n{\n  var horzEdge = this.m_SortedEdges;\n  while (horzEdge !== null)\n  {\n    this.DeleteFromSEL(horzEdge);\n    this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n    horzEdge = this.m_SortedEdges;\n  }\n};\nClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n{\n  if (HorzEdge.Bot.X < HorzEdge.Top.X)\n  {\n      $var.Left = HorzEdge.Bot.X;\n      $var.Right = HorzEdge.Top.X;\n      $var.Dir = ClipperLib.Direction.dLeftToRight;\n  }\n  else\n  {\n      $var.Left = HorzEdge.Top.X;\n      $var.Right = HorzEdge.Bot.X;\n      $var.Dir = ClipperLib.Direction.dRightToLeft;\n  }\n};\nClipperLib.Clipper.prototype.PrepareHorzJoins = function (horzEdge, isTopOfScanbeam)\n{\n  //get the last Op for this horizontal edge\n  //the point may be anywhere along the horizontal ...\n  var outPt = this.m_PolyOuts[horzEdge.OutIdx].Pts;\n  if (horzEdge.Side != ClipperLib.EdgeSide.esLeft)\n    outPt = outPt.Prev;\n  //First, match up overlapping horizontal edges (eg when one polygon's\n  //intermediate horz edge overlaps an intermediate horz edge of another, or\n  //when one polygon sits on top of another) ...\n  //for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; ++i) {\n  //  var j = this.m_GhostJoins[i];\n  //  if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, horzEdge.Bot, horzEdge.Top))\n  //    this.AddJoin(j.OutPt1, outPt, j.OffPt);\n  //}\n\n  //Also, since horizontal edges at the top of one SB are often removed from\n  //the AEL before we process the horizontal edges at the bottom of the next,\n  //we need to create 'ghost' Join records of 'contrubuting' horizontals that\n  //we can compare with horizontals at the bottom of the next SB.\n  if (isTopOfScanbeam)\n    if (ClipperLib.IntPoint.op_Equality(outPt.Pt, horzEdge.Top))\n      this.AddGhostJoin(outPt, horzEdge.Bot);\n    else\n      this.AddGhostJoin(outPt, horzEdge.Top);\n};\nClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n{\n  var $var = {Dir: null, Left: null, Right: null};\n  this.GetHorzDirection(horzEdge, $var);\n  var dir = $var.Dir;\n  var horzLeft = $var.Left;\n  var horzRight = $var.Right;\n\n  var eLastHorz = horzEdge,\n    eMaxPair = null;\n  while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n    eLastHorz = eLastHorz.NextInLML;\n  if (eLastHorz.NextInLML === null)\n    eMaxPair = this.GetMaximaPair(eLastHorz);\n  for (;;)\n  {\n    var IsLastHorz = (horzEdge == eLastHorz);\n    var e = this.GetNextInAEL(horzEdge, dir);\n    while (e !== null)\n    {\n      //Break if we've got to the end of an intermediate horizontal edge ...\n      //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n      if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n        break;\n      var eNext = this.GetNextInAEL(e, dir);\n      //saves eNext for later\n      if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n      {\n\n        if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta != 0)\n          this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);\n\n        //so far we're still in range of the horizontal Edge  but make sure\n        //we're at the last of consec. horizontals when matching with eMaxPair\n        if (e == eMaxPair && IsLastHorz)\n        {\n          if (dir == ClipperLib.Direction.dLeftToRight)\n            this.IntersectEdges(horzEdge, e, e.Top, false);\n          else\n            this.IntersectEdges(e, horzEdge, e.Top, false);\n          if (eMaxPair.OutIdx >= 0)\n            ClipperLib.Error(\"ProcessHorizontal error\");\n          return;\n        }\n        else if (dir == ClipperLib.Direction.dLeftToRight)\n        {\n          var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n          this.IntersectEdges(horzEdge, e, Pt, true);\n        }\n        else\n        {\n          var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n          this.IntersectEdges(e, horzEdge, Pt, true);\n        }\n        this.SwapPositionsInAEL(horzEdge, e);\n      }\n      else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n        break;\n      e = eNext;\n    }\n    //end while\n    if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta !== 0)\n      this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);\n    if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n    {\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Bot);\n        \n        var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n        this.GetHorzDirection(horzEdge, $var);\n        dir = $var.Dir;\n        horzLeft = $var.Left;\n        horzRight = $var.Right;\n    }\n    else\n      break;\n  }\n  //end for (;;)\n  if (horzEdge.NextInLML !== null)\n  {\n    if (horzEdge.OutIdx >= 0)\n    {\n      var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.WindDelta === 0)\n        return;\n      //nb: HorzEdge is no longer horizontal here\n      var ePrev = horzEdge.PrevInAEL;\n      var eNext = horzEdge.NextInAEL;\n      if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n        ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n        (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n      {\n        var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n      else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n        eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n        eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n        ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n      {\n        var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n    }\n    else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n  }\n  else if (eMaxPair !== null)\n  {\n    if (eMaxPair.OutIdx >= 0)\n    {\n      if (dir == ClipperLib.Direction.dLeftToRight)\n        this.IntersectEdges(horzEdge, eMaxPair, horzEdge.Top, false);\n      else\n        this.IntersectEdges(eMaxPair, horzEdge, horzEdge.Top, false);\n      if (eMaxPair.OutIdx >= 0)\n        ClipperLib.Error(\"ProcessHorizontal error\");\n    }\n    else\n    {\n      this.DeleteFromAEL(horzEdge);\n      this.DeleteFromAEL(eMaxPair);\n    }\n  }\n  else\n  {\n    if (horzEdge.OutIdx >= 0)\n      this.AddOutPt(horzEdge, horzEdge.Top);\n    this.DeleteFromAEL(horzEdge);\n  }\n};\nClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n{\n  return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n};\nClipperLib.Clipper.prototype.IsMinima = function (e)\n{\n  return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n};\nClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n{\n  return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n};\nClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n{\n  return (e.Top.Y == Y && e.NextInLML !== null);\n};\nClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n{\n  var result = null;\n  if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n    result = e.Next;\n  else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n    result = e.Prev;\n  if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n    return null;\n  return result;\n};\nClipperLib.Clipper.prototype.ProcessIntersections = function (botY, topY)\n{\n  if (this.m_ActiveEdges == null)\n    return true;\n  try\n  {\n    this.BuildIntersectList(botY, topY);\n    if (this.m_IntersectList.length == 0)\n      return true;\n    if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n      this.ProcessIntersectList();\n    else\n      return false;\n  }\n  catch ($$e2)\n  {\n    this.m_SortedEdges = null;\n    this.m_IntersectList.length = 0;\n    ClipperLib.Error(\"ProcessIntersections error\");\n  }\n  this.m_SortedEdges = null;\n  return true;\n};\nClipperLib.Clipper.prototype.BuildIntersectList = function (botY, topY)\n{\n  if (this.m_ActiveEdges === null)\n    return;\n  //prepare for sorting ...\n  var e = this.m_ActiveEdges;\n  //console.log(JSON.stringify(JSON.decycle( e )));\n  this.m_SortedEdges = e;\n  while (e !== null)\n  {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n    e = e.NextInAEL;\n  }\n  //bubblesort ...\n  var isModified = true;\n  while (isModified && this.m_SortedEdges !== null)\n  {\n    isModified = false;\n    e = this.m_SortedEdges;\n    while (e.NextInSEL !== null)\n    {\n      var eNext = e.NextInSEL;\n      var pt = new ClipperLib.IntPoint();\n      //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n      if (e.Curr.X > eNext.Curr.X)\n      {\n        if (!this.IntersectPoint(e, eNext, pt) && e.Curr.X > eNext.Curr.X + 1)\n        {\n          //console.log(\"e.Curr.X: \"+JSON.stringify(JSON.decycle( e.Curr.X )));\n          //console.log(\"eNext.Curr.X+1: \"+JSON.stringify(JSON.decycle( eNext.Curr.X+1)));\n          ClipperLib.Error(\"Intersection error\");\n        }\n        if (pt.Y > botY)\n        {\n          pt.Y = botY;\n          if (Math.abs(e.Dx) > Math.abs(eNext.Dx))\n            pt.X = ClipperLib.Clipper.TopX(eNext, botY);\n          else\n            pt.X = ClipperLib.Clipper.TopX(e, botY);\n        }\n        var newNode = new ClipperLib.IntersectNode();\n        newNode.Edge1 = e;\n        newNode.Edge2 = eNext;\n        //newNode.Pt = pt;\n        newNode.Pt.X = pt.X;\n        newNode.Pt.Y = pt.Y;\n        this.m_IntersectList.push(newNode);\n        this.SwapPositionsInSEL(e, eNext);\n        isModified = true;\n      }\n      else\n        e = eNext;\n    }\n    if (e.PrevInSEL !== null)\n      e.PrevInSEL.NextInSEL = null;\n    else\n      break;\n  }\n  this.m_SortedEdges = null;\n};\nClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n{\n  return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n};\nClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n{\n  //the following typecast is safe because the differences in Pt.Y will\n  //be limited to the height of the scanbeam.\n  return (node2.Pt.Y - node1.Pt.Y);\n};\nClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n{\n  //pre-condition: intersections are sorted bottom-most first.\n  //Now it's crucial that intersections are made only between adjacent edges,\n  //so to ensure this the order of intersections may need adjusting ...\n  this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n  this.CopyAELToSEL();\n  var cnt = this.m_IntersectList.length;\n  for (var i = 0; i < cnt; i++)\n  {\n    if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n    {\n      var j = i + 1;\n      while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n        j++;\n      if (j == cnt)\n        return false;\n      var tmp = this.m_IntersectList[i];\n      this.m_IntersectList[i] = this.m_IntersectList[j];\n      this.m_IntersectList[j] = tmp;\n    }\n    this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n  }\n  return true;\n};\nClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n{\n  for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n  {\n    var iNode = this.m_IntersectList[i];\n    this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt, true);\n    this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n  }\n  this.m_IntersectList.length = 0;\n};\n/*\n--------------------------------\nRound speedtest: http://jsperf.com/fastest-round\n--------------------------------\n*/\nvar R1 = function (a)\n{\n  return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n};\nvar R2 = function (a)\n{\n  return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n};\nvar R3 = function (a)\n{\n  return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n};\nvar R4 = function (a)\n{\n  if (a < 0)\n  {\n    a -= 0.5;\n    return a < -2147483648 ? Math.ceil(a) : a | 0;\n  }\n  else\n  {\n    a += 0.5;\n    return a > 2147483647 ? Math.floor(a) : a | 0;\n  }\n};\nif (browser.msie) ClipperLib.Clipper.Round = R1;\nelse if (browser.chromium) ClipperLib.Clipper.Round = R3;\nelse if (browser.safari) ClipperLib.Clipper.Round = R4;\nelse ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\nClipperLib.Clipper.TopX = function (edge, currentY)\n{\n  //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n  //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n  if (currentY == edge.Top.Y)\n    return edge.Top.X;\n  return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n};\nClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n{\n  ip.X = 0;\n  ip.Y = 0;\n  var b1, b2;\n  //nb: with very large coordinate values, it's possible for SlopesEqual() to \n  //return false but for the edge.Dx value be equal due to double precision rounding.\n  if (ClipperLib.ClipperBase.SlopesEqual(edge1, edge2, this.m_UseFullRange) || edge1.Dx == edge2.Dx)\n  {\n    if (edge2.Bot.Y > edge1.Bot.Y)\n    {\n      ip.X = edge2.Bot.X;\n      ip.Y = edge2.Bot.Y;\n    }\n    else\n    {\n      ip.X = edge1.Bot.X;\n      ip.Y = edge1.Bot.Y;\n    }\n    return false;\n  }\n  else if (edge1.Delta.X === 0)\n  {\n    ip.X = edge1.Bot.X;\n    if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n    {\n      ip.Y = edge2.Bot.Y;\n    }\n    else\n    {\n      b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n    }\n  }\n  else if (edge2.Delta.X === 0)\n  {\n    ip.X = edge2.Bot.X;\n    if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n    {\n      ip.Y = edge1.Bot.Y;\n    }\n    else\n    {\n      b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n      ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n    }\n  }\n  else\n  {\n    b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n    b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n    var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n    ip.Y = ClipperLib.Clipper.Round(q);\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n    else\n      ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n  }\n  if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n  {\n    if (edge1.Top.Y > edge2.Top.Y)\n    {\n      ip.Y = edge1.Top.Y;\n      ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n      return ip.X < edge1.Top.X;\n    }\n    else\n      ip.Y = edge2.Top.Y;\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n      ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n    else\n      ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n  }\n  return true;\n};\nClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n{\n  var e = this.m_ActiveEdges;\n  while (e !== null)\n  {\n    //1. process maxima, treating them as if they're 'bent' horizontal edges,\n    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n    var IsMaximaEdge = this.IsMaxima(e, topY);\n    if (IsMaximaEdge)\n    {\n      var eMaxPair = this.GetMaximaPair(e);\n      IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n    }\n    if (IsMaximaEdge)\n    {\n      var ePrev = e.PrevInAEL;\n      this.DoMaxima(e);\n      if (ePrev === null)\n        e = this.m_ActiveEdges;\n      else\n        e = ePrev.NextInAEL;\n    }\n    else\n    {\n      //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n      if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n      {\n        e = this.UpdateEdgeIntoAEL(e);\n        if (e.OutIdx >= 0)\n          this.AddOutPt(e, e.Bot);\n        this.AddEdgeToSEL(e);\n      }\n      else\n      {\n        e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n        e.Curr.Y = topY;\n      }\n      if (this.StrictlySimple)\n      {\n        var ePrev = e.PrevInAEL;\n        if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n          (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n          (ePrev.WindDelta !== 0))\n        {\n          var op = this.AddOutPt(ePrev, e.Curr);\n          var op2 = this.AddOutPt(e, e.Curr);\n          this.AddJoin(op, op2, e.Curr);\n          //StrictlySimple (type-3) join\n        }\n      }\n      e = e.NextInAEL;\n    }\n  }\n  //3. Process horizontals at the Top of the scanbeam ...\n  this.ProcessHorizontals(true);\n  //4. Promote intermediate vertices ...\n  e = this.m_ActiveEdges;\n  while (e !== null)\n  {\n    if (this.IsIntermediate(e, topY))\n    {\n      var op = null;\n      if (e.OutIdx >= 0)\n        op = this.AddOutPt(e, e.Top);\n      e = this.UpdateEdgeIntoAEL(e);\n      //if output polygons share an edge, they'll need joining later ...\n      var ePrev = e.PrevInAEL;\n      var eNext = e.NextInAEL;\n      if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n        ePrev.Curr.Y == e.Bot.Y && op !== null &&\n        ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n        ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n        (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n      {\n        var op2 = this.AddOutPt(ePrev, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n      else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n        eNext.Curr.Y == e.Bot.Y && op !== null &&\n        eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n        ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n        (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n      {\n        var op2 = this.AddOutPt(eNext, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n    }\n    e = e.NextInAEL;\n  }\n};\nClipperLib.Clipper.prototype.DoMaxima = function (e)\n{\n  var eMaxPair = this.GetMaximaPair(e);\n  if (eMaxPair === null)\n  {\n    if (e.OutIdx >= 0)\n      this.AddOutPt(e, e.Top);\n    this.DeleteFromAEL(e);\n    return;\n  }\n  var eNext = e.NextInAEL;\n  var use_lines = true;\n  while (eNext !== null && eNext != eMaxPair)\n  {\n    this.IntersectEdges(e, eNext, e.Top, true);\n    this.SwapPositionsInAEL(e, eNext);\n    eNext = e.NextInAEL;\n  }\n  if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n  {\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  }\n  else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n  {\n    this.IntersectEdges(e, eMaxPair, e.Top, false);\n  }\n  else if (use_lines && e.WindDelta === 0)\n  {\n    if (e.OutIdx >= 0)\n    {\n      this.AddOutPt(e, e.Top);\n      e.OutIdx = -1;\n    }\n    this.DeleteFromAEL(e);\n    if (eMaxPair.OutIdx >= 0)\n    {\n      this.AddOutPt(eMaxPair, e.Top);\n      eMaxPair.OutIdx = -1;\n    }\n    this.DeleteFromAEL(eMaxPair);\n  }\n  else\n    ClipperLib.Error(\"DoMaxima error\");\n};\nClipperLib.Clipper.ReversePaths = function (polys)\n{\n  for (var i = 0, len = polys.length; i < len; i++)\n    polys[i].reverse();\n};\nClipperLib.Clipper.Orientation = function (poly)\n{\n  return ClipperLib.Clipper.Area(poly) >= 0;\n};\nClipperLib.Clipper.prototype.PointCount = function (pts)\n{\n  if (pts === null)\n    return 0;\n  var result = 0;\n  var p = pts;\n  do {\n    result++;\n    p = p.Next;\n  }\n  while (p != pts)\n  return result;\n};\nClipperLib.Clipper.prototype.BuildResult = function (polyg)\n{\n  ClipperLib.Clear(polyg);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null)\n      continue;\n    var p = outRec.Pts.Prev;\n    var cnt = this.PointCount(p);\n    if (cnt < 2)\n      continue;\n    var pg = new Array(cnt);\n    for (var j = 0; j < cnt; j++)\n    {\n      pg[j] = p.Pt;\n      p = p.Prev;\n    }\n    polyg.push(pg);\n  }\n};\nClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n{\n  polytree.Clear();\n  //add each output polygon/contour to polytree ...\n  //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    var cnt = this.PointCount(outRec.Pts);\n    if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n      continue;\n    this.FixHoleLinkage(outRec);\n    var pn = new ClipperLib.PolyNode();\n    polytree.m_AllPolys.push(pn);\n    outRec.PolyNode = pn;\n    pn.m_polygon.length = cnt;\n    var op = outRec.Pts.Prev;\n    for (var j = 0; j < cnt; j++)\n    {\n      pn.m_polygon[j] = op.Pt;\n      op = op.Prev;\n    }\n  }\n  //fixup PolyNode links etc ...\n  //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.PolyNode === null)\n      continue;\n    else if (outRec.IsOpen)\n    {\n      outRec.PolyNode.IsOpen = true;\n      polytree.AddChild(outRec.PolyNode);\n    }\n    else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n      outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n    else\n      polytree.AddChild(outRec.PolyNode);\n  }\n};\nClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n{\n  //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n  //parallel edges by removing the middle vertex.\n  var lastOK = null;\n  outRec.BottomPt = null;\n  var pp = outRec.Pts;\n  for (;;)\n  {\n    if (pp.Prev == pp || pp.Prev == pp.Next)\n    {\n      this.DisposeOutPts(pp);\n      outRec.Pts = null;\n      return;\n    }\n    //test for duplicate points and collinear edges ...\n    if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n      (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n        (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n    {\n      lastOK = null;\n      var tmp = pp;\n      pp.Prev.Next = pp.Next;\n      pp.Next.Prev = pp.Prev;\n      pp = pp.Prev;\n      tmp = null;\n    }\n    else if (pp == lastOK)\n      break;\n    else\n    {\n      if (lastOK === null)\n        lastOK = pp;\n      pp = pp.Next;\n    }\n  }\n  outRec.Pts = pp;\n};\nClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n{\n  var result = new ClipperLib.OutPt();\n  //result.Pt = outPt.Pt;\n  result.Pt.X = outPt.Pt.X;\n  result.Pt.Y = outPt.Pt.Y;\n  result.Idx = outPt.Idx;\n  if (InsertAfter)\n  {\n    result.Next = outPt.Next;\n    result.Prev = outPt;\n    outPt.Next.Prev = result;\n    outPt.Next = result;\n  }\n  else\n  {\n    result.Prev = outPt.Prev;\n    result.Next = outPt;\n    outPt.Prev.Next = result;\n    outPt.Prev = result;\n  }\n  return result;\n};\nClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n{\n  if (a1 < a2)\n  {\n    if (b1 < b2)\n    {\n      $val.Left = Math.max(a1, b1);\n      $val.Right = Math.min(a2, b2);\n    }\n    else\n    {\n      $val.Left = Math.max(a1, b2);\n      $val.Right = Math.min(a2, b1);\n    }\n  }\n  else\n  {\n    if (b1 < b2)\n    {\n      $val.Left = Math.max(a2, b1);\n      $val.Right = Math.min(a1, b2);\n    }\n    else\n    {\n      $val.Left = Math.max(a2, b2);\n      $val.Right = Math.min(a1, b1);\n    }\n  }\n  return $val.Left < $val.Right;\n};\nClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n{\n  var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n  if (Dir1 == Dir2)\n    return false;\n  //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n  //So, to facilitate this while inserting Op1b and Op2b ...\n  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n  if (Dir1 == ClipperLib.Direction.dLeftToRight)\n  {\n    while (op1.Next.Pt.X <= Pt.X &&\n      op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n      op1 = op1.Next;\n    if (DiscardLeft && (op1.Pt.X != Pt.X))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, !DiscardLeft);\n    if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n    {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt.X = Pt.X;\n      op1.Pt.Y = Pt.Y;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n    }\n  }\n  else\n  {\n    while (op1.Next.Pt.X >= Pt.X &&\n      op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n      op1 = op1.Next;\n    if (!DiscardLeft && (op1.Pt.X != Pt.X))\n      op1 = op1.Next;\n    op1b = this.DupOutPt(op1, DiscardLeft);\n    if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n    {\n      op1 = op1b;\n      //op1.Pt = Pt;\n      op1.Pt.X = Pt.X;\n      op1.Pt.Y = Pt.Y;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n    }\n  }\n  if (Dir2 == ClipperLib.Direction.dLeftToRight)\n  {\n    while (op2.Next.Pt.X <= Pt.X &&\n      op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n      op2 = op2.Next;\n    if (DiscardLeft && (op2.Pt.X != Pt.X))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, !DiscardLeft);\n    if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n    {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt.X = Pt.X;\n      op2.Pt.Y = Pt.Y;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n    }\n  }\n  else\n  {\n    while (op2.Next.Pt.X >= Pt.X &&\n      op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n      op2 = op2.Next;\n    if (!DiscardLeft && (op2.Pt.X != Pt.X))\n      op2 = op2.Next;\n    op2b = this.DupOutPt(op2, DiscardLeft);\n    if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n    {\n      op2 = op2b;\n      //op2.Pt = Pt;\n      op2.Pt.X = Pt.X;\n      op2.Pt.Y = Pt.Y;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n    }\n  }\n  if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n  {\n    op1.Prev = op2;\n    op2.Next = op1;\n    op1b.Next = op2b;\n    op2b.Prev = op1b;\n  }\n  else\n  {\n    op1.Next = op2;\n    op2.Prev = op1;\n    op1b.Prev = op2b;\n    op2b.Next = op1b;\n  }\n  return true;\n};\nClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n{\n  var op1 = j.OutPt1,\n    op1b = new ClipperLib.OutPt();\n  var op2 = j.OutPt2,\n    op2b = new ClipperLib.OutPt();\n  //There are 3 kinds of joins for output polygons ...\n  //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n  //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n  //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n  //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n  //3. StrictlySimple joins where edges touch but are not collinear and where\n  //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n  var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n  if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n  {\n    //Strictly Simple join ...\n    op1b = j.OutPt1.Next;\n    while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n      op1b = op1b.Next;\n    var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n    op2b = j.OutPt2.Next;\n    while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n      op2b = op2b.Next;\n    var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n    if (reverse1 == reverse2)\n      return false;\n    if (reverse1)\n    {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n    else\n    {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n  else if (isHorizontal)\n  {\n    //treat horizontal joins differently to non-horizontal joins since with\n    //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n    //may be anywhere along the horizontal edge.\n    op1b = op1;\n    while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n      op1 = op1.Prev;\n    while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n      op1b = op1b.Next;\n    if (op1b.Next == op1 || op1b.Next == op2)\n      return false;\n    //a flat 'polygon'\n    op2b = op2;\n    while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n      op2 = op2.Prev;\n    while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n      op2b = op2b.Next;\n    if (op2b.Next == op2 || op2b.Next == op1)\n      return false;\n    //a flat 'polygon'\n    //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n    var $val = {Left: null, Right: null};\n    if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n      return false;\n    var Left = $val.Left;\n    var Right = $val.Right;\n\n    //DiscardLeftSide: when overlapping edges are joined, a spike will created\n    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n    //on the discard Side as either may still be needed for other joins ...\n    var Pt = new ClipperLib.IntPoint();\n    var DiscardLeftSide;\n    if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n    {\n      //Pt = op1.Pt;\n      Pt.X = op1.Pt.X;\n      Pt.Y = op1.Pt.Y;\n      DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n    }\n    else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n    {\n      //Pt = op2.Pt;\n      Pt.X = op2.Pt.X;\n      Pt.Y = op2.Pt.Y;\n      DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n    }\n    else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n    {\n      //Pt = op1b.Pt;\n      Pt.X = op1b.Pt.X;\n      Pt.Y = op1b.Pt.Y;\n      DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n    }\n    else\n    {\n      //Pt = op2b.Pt;\n      Pt.X = op2b.Pt.X;\n      Pt.Y = op2b.Pt.Y;\n      DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n    }\n    j.OutPt1 = op1;\n    j.OutPt2 = op2;\n    return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n  }\n  else\n  {\n    //nb: For non-horizontal joins ...\n    //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n    //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n    //make sure the polygons are correctly oriented ...\n    op1b = op1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n      op1b = op1b.Next;\n    var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n    if (Reverse1)\n    {\n      op1b = op1.Prev;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Prev;\n      if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n        return false;\n    }\n    op2b = op2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n      op2b = op2b.Next;\n    var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n    if (Reverse2)\n    {\n      op2b = op2.Prev;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Prev;\n      if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n        return false;\n    }\n    if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n      ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n      return false;\n    if (Reverse1)\n    {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n    else\n    {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n};\nClipperLib.Clipper.GetBounds = function (paths)\n{\n  var i = 0,\n    cnt = paths.length;\n  while (i < cnt && paths[i].length == 0) i++;\n  if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n  var result = new ClipperLib.IntRect();\n  result.left = paths[i][0].X;\n  result.right = result.left;\n  result.top = paths[i][0].Y;\n  result.bottom = result.top;\n  for (; i < cnt; i++)\n    for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n    {\n      if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n      else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n      if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n      else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n    }\n  return result;\n}\nClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n{\n  var opStart = ops;\n  var result = new ClipperLib.IntRect();\n  result.left = ops.Pt.X;\n  result.right = ops.Pt.X;\n  result.top = ops.Pt.Y;\n  result.bottom = ops.Pt.Y;\n  ops = ops.Next;\n  while (ops != opStart)\n  {\n    if (ops.Pt.X < result.left)\n      result.left = ops.Pt.X;\n    if (ops.Pt.X > result.right)\n      result.right = ops.Pt.X;\n    if (ops.Pt.Y < result.top)\n      result.top = ops.Pt.Y;\n    if (ops.Pt.Y > result.bottom)\n      result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n  }\n  return result;\n};\n\nClipperLib.Clipper.PointInPolygon = function (pt, path)\n{\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0,\n    cnt = path.length;\n  if (cnt < 3)\n    return 0;\n  var ip = path[0];\n  for (var i = 1; i <= cnt; ++i)\n  {\n    var ipNext = (i == cnt ? path[0] : path[i]);\n    if (ipNext.Y == pt.Y)\n    {\n      if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n        return -1;\n    }\n    if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n    {\n      if (ip.X >= pt.X)\n      {\n        if (ipNext.X > pt.X)\n          result = 1 - result;\n        else\n        {\n          var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n          if (d == 0)\n            return -1;\n          else if ((d > 0) == (ipNext.Y > ip.Y))\n            result = 1 - result;\n        }\n      }\n      else\n      {\n        if (ipNext.X > pt.X)\n        {\n          var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n          if (d == 0)\n            return -1;\n          else if ((d > 0) == (ipNext.Y > ip.Y))\n            result = 1 - result;\n        }\n      }\n    }\n    ip = ipNext;\n  }\n  return result;\n};\n    \nClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n{\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0;\n  var startOp = op;\n  for (;;)\n  {\n    var poly0x = op.Pt.X,\n      poly0y = op.Pt.Y;\n    var poly1x = op.Next.Pt.X,\n      poly1y = op.Next.Pt.Y;\n    if (poly1y == pt.Y)\n    {\n      if ((poly1x == pt.X) || (poly0y == pt.Y && ((poly1x > pt.X) == (poly0x < pt.X))))\n        return -1;\n    }\n    if ((poly0y < pt.Y) != (poly1y < pt.Y))\n    {\n      if (poly0x >= pt.X)\n      {\n        if (poly1x > pt.X)\n          result = 1 - result;\n        else\n        {\n          var d = (poly0x - pt.X) * (poly1y - pt.Y) - (poly1x - pt.X) * (poly0y - pt.Y);\n          if (d == 0)\n            return -1;\n          if ((d > 0) == (poly1y > poly0y))\n            result = 1 - result;\n        }\n      }\n      else\n      {\n        if (poly1x > pt.X)\n        {\n          var d = (poly0x - pt.X) * (poly1y - pt.Y) - (poly1x - pt.X) * (poly0y - pt.Y);\n          if (d == 0)\n            return -1;\n          if ((d > 0) == (poly1y > poly0y))\n            result = 1 - result;\n        }\n      }\n    }\n    op = op.Next;\n    if (startOp == op)\n      break;\n  }\n  return result;\n};\n\nClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n{\n  var op = outPt1;\n  do {\n    var res = this.PointInPolygon(op.Pt, outPt2);\n    if (res >= 0)\n      return res != 0;\n    op = op.Next;\n  }\n  while (op != outPt1)\n  return true;\n};\nClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n{\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n  {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.Pts !== null && outRec.FirstLeft == OldOutRec)\n    {\n      if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n        outRec.FirstLeft = NewOutRec;\n    }\n  }\n};\nClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n{\n  for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n    if (outRec.FirstLeft == OldOutRec)\n      outRec.FirstLeft = NewOutRec;\n};\nClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n{\n  while (FirstLeft != null && FirstLeft.Pts == null)\n    FirstLeft = FirstLeft.FirstLeft;\n  return FirstLeft;\n};\nClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n{\n  for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n  {\n    var join = this.m_Joins[i];\n    var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n    var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n    if (outRec1.Pts == null || outRec2.Pts == null)\n      continue;\n    //get the polygon fragment with the correct hole state (FirstLeft)\n    //before calling JoinPoints() ...\n    var holeStateRec;\n    if (outRec1 == outRec2)\n      holeStateRec = outRec1;\n    else if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n    if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n    if (outRec1 == outRec2)\n    {\n      //instead of joining two polygons, we've just created a new one by\n      //splitting one polygon into two.\n      outRec1.Pts = join.OutPt1;\n      outRec1.BottomPt = null;\n      outRec2 = this.CreateOutRec();\n      outRec2.Pts = join.OutPt2;\n      //update all OutRec2.Pts Idx's ...\n      this.UpdateOutPtIdxs(outRec2);\n      //We now need to check every OutRec.FirstLeft pointer. If it points\n      //to OutRec1 it may need to point to OutRec2 instead ...\n      if (this.m_UsingPolyTree)\n        for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n        {\n          var oRec = this.m_PolyOuts[j];\n          if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n            continue;\n          if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n            oRec.FirstLeft = outRec2;\n        }\n      if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n      {\n        //outRec2 is contained by outRec1 ...\n        outRec2.IsHole = !outRec1.IsHole;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n        if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n          this.ReversePolyPtLinks(outRec2.Pts);\n      }\n      else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n      {\n        //outRec1 is contained by outRec2 ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec1.IsHole = !outRec2.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        outRec1.FirstLeft = outRec2;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec1, outRec2);\n        if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n          this.ReversePolyPtLinks(outRec1.Pts);\n      }\n      else\n      {\n        //the 2 polygons are completely separate ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        //fixup FirstLeft pointers that may need reassigning to OutRec2\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts1(outRec1, outRec2);\n      }\n    }\n    else\n    {\n      //joined 2 polygons together ...\n      outRec2.Pts = null;\n      outRec2.BottomPt = null;\n      outRec2.Idx = outRec1.Idx;\n      outRec1.IsHole = holeStateRec.IsHole;\n      if (holeStateRec == outRec2)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec2.FirstLeft = outRec1;\n      //fixup FirstLeft pointers that may need reassigning to OutRec1\n      if (this.m_UsingPolyTree)\n        this.FixupFirstLefts2(outRec2, outRec1);\n    }\n  }\n};\nClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n{\n  var op = outrec.Pts;\n  do {\n    op.Idx = outrec.Idx;\n    op = op.Prev;\n  }\n  while (op != outrec.Pts)\n};\nClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n{\n  var i = 0;\n  while (i < this.m_PolyOuts.length)\n  {\n    var outrec = this.m_PolyOuts[i++];\n    var op = outrec.Pts;\n    if (op === null)\n      continue;\n    do //for each Pt in Polygon until duplicate found do ...\n    {\n      var op2 = op.Next;\n      while (op2 != outrec.Pts)\n      {\n        if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n        {\n          //split the polygon into two ...\n          var op3 = op.Prev;\n          var op4 = op2.Prev;\n          op.Prev = op4;\n          op4.Next = op;\n          op2.Prev = op3;\n          op3.Next = op2;\n          outrec.Pts = op;\n          var outrec2 = this.CreateOutRec();\n          outrec2.Pts = op2;\n          this.UpdateOutPtIdxs(outrec2);\n          if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n          {\n            //OutRec2 is contained by OutRec1 ...\n            outrec2.IsHole = !outrec.IsHole;\n            outrec2.FirstLeft = outrec;\n          }\n          else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n          {\n            //OutRec1 is contained by OutRec2 ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec.IsHole = !outrec2.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            outrec.FirstLeft = outrec2;\n          }\n          else\n          {\n            //the 2 polygons are separate ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n          }\n          op2 = op;\n          //ie get ready for the next iteration\n        }\n        op2 = op2.Next;\n      }\n      op = op.Next;\n    }\n    while (op != outrec.Pts)\n  }\n};\nClipperLib.Clipper.Area = function (poly)\n{\n  var cnt = poly.length;\n  if (cnt < 3)\n    return 0;\n  var a = 0;\n  for (var i = 0, j = cnt - 1; i < cnt; ++i)\n  {\n    a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n    j = i;\n  }\n  return -a * 0.5;\n};\nClipperLib.Clipper.prototype.Area = function (outRec)\n{\n  var op = outRec.Pts;\n  if (op == null)\n    return 0;\n  var a = 0;\n  do {\n    a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n    op = op.Next;\n  }\n  while (op != outRec.Pts)\n  return a * 0.5;\n};\nif (use_deprecated)\n{\n  ClipperLib.Clipper.OffsetPaths = function (polys, delta, jointype, endtype, MiterLimit)\n  {\n    var result = new ClipperLib.Paths();\n    var co = new ClipperLib.ClipperOffset(MiterLimit, MiterLimit);\n    co.AddPaths(polys, jointype, endtype);\n    co.Execute(result, delta);\n    return result;\n  };\n}\nClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n{\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\nClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n{\n  if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\nClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n{\n  var dx = (pt1.X - pt2.X);\n  var dy = (pt1.Y - pt2.Y);\n  return (dx * dx + dy * dy);\n};\nClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n{\n  //The equation of a line in general form (Ax + By + C = 0)\n  //given 2 points (x,y) & (x,y) is ...\n  //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n  //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n  //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n  //see http://en.wikipedia.org/wiki/Perpendicular_distance\n  var A = ln1.Y - ln2.Y;\n  var B = ln2.X - ln1.X;\n  var C = A * ln1.X + B * ln1.Y;\n  C = A * pt.X + B * pt.Y - C;\n  return (C * C) / (A * A + B * B);\n};\nClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd)\n{\n  return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n};\nClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n{\n  var dx = pt1.X - pt2.X;\n  var dy = pt1.Y - pt2.Y;\n  return ((dx * dx) + (dy * dy) <= distSqrd);\n};\n//------------------------------------------------------------------------------\nClipperLib.Clipper.ExcludeOp = function (op)\n{\n  var result = op.Prev;\n  result.Next = op.Next;\n  op.Next.Prev = result;\n  result.Idx = 0;\n  return result;\n};\nClipperLib.Clipper.CleanPolygon = function (path, distance)\n{\n  if (typeof (distance) == \"undefined\") distance = 1.415;\n  //distance = proximity in units/pixels below which vertices will be stripped. \n  //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have \n  //both x & y coords within 1 unit, then the second vertex will be stripped.\n  var cnt = path.length;\n  if (cnt == 0)\n    return new Array();\n  var outPts = new Array(cnt);\n  for (var i = 0; i < cnt; ++i)\n    outPts[i] = new ClipperLib.OutPt();\n  for (var i = 0; i < cnt; ++i)\n  {\n    outPts[i].Pt = path[i];\n    outPts[i].Next = outPts[(i + 1) % cnt];\n    outPts[i].Next.Prev = outPts[i];\n    outPts[i].Idx = 0;\n  }\n  var distSqrd = distance * distance;\n  var op = outPts[0];\n  while (op.Idx == 0 && op.Next != op.Prev)\n  {\n    if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n    {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    }\n    else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n    {\n      ClipperLib.Clipper.ExcludeOp(op.Next);\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt -= 2;\n    }\n    else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n    {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    }\n    else\n    {\n      op.Idx = 1;\n      op = op.Next;\n    }\n  }\n  if (cnt < 3)\n    cnt = 0;\n  var result = new Array(cnt);\n  for (var i = 0; i < cnt; ++i)\n  {\n    result[i] = new ClipperLib.IntPoint(op.Pt);\n    op = op.Next;\n  }\n  outPts = null;\n  return result;\n};\nClipperLib.Clipper.CleanPolygons = function (polys, distance)\n{\n  var result = new Array(polys.length);\n  for (var i = 0, ilen = polys.length; i < ilen; i++)\n    result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n  return result;\n};\nClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n{\n  var delta = (IsClosed ? 1 : 0);\n  var polyCnt = pattern.length;\n  var pathCnt = path.length;\n  var result = new Array();\n  if (IsSum)\n    for (var i = 0; i < pathCnt; i++)\n    {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n      result.push(p);\n    }\n  else\n    for (var i = 0; i < pathCnt; i++)\n    {\n      var p = new Array(polyCnt);\n      for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n        p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n      result.push(p);\n    }\n  var quads = new Array();\n  for (var i = 0; i < pathCnt - 1 + delta; i++)\n    for (var j = 0; j < polyCnt; j++)\n    {\n      var quad = new Array();\n      quad.push(result[i % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n      quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n      if (!ClipperLib.Clipper.Orientation(quad))\n        quad.reverse();\n      quads.push(quad);\n    }\n  var c = new ClipperLib.Clipper(0);\n  c.AddPaths(quads, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n  return result;\n};\n\nClipperLib.Clipper.MinkowskiSum = function ()\n{\n  var a = arguments,\n    alen = a.length;\n  if (alen == 3) // MinkowskiSum(Path pattern, path, pathIsClosed)\n  {\n    var pattern = a[0],\n      path = a[1],\n      pathIsClosed = a[2];\n    return ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n  }\n  else if (alen == 4) // MinkowskiSum(pattern, paths, pathFillType, pathIsClosed)\n  {\n    var pattern = a[0],\n      paths = a[1],\n      pathFillType = a[2],\n      pathIsClosed = a[3];\n    var c = new ClipperLib.Clipper(),\n      tmp;\n    for (var i = 0, ilen = paths.length; i < ilen; ++i)\n    {\n      var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n      c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n    }\n    if (pathIsClosed) c.AddPaths(paths, ClipperLib.PolyType.ptClip, true);\n    var solution = new ClipperLib.Paths();\n    c.Execute(ClipperLib.ClipType.ctUnion, solution, pathFillType, pathFillType);\n    return solution;\n  }\n};\n\nClipperLib.Clipper.MinkowskiDiff = function (pattern, path, pathIsClosed)\n{\n  return ClipperLib.Clipper.Minkowski(pattern, path, false, pathIsClosed);\n};\n\nClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n{\n  var result = new Array();\n  //result.set_Capacity(polytree.get_Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n  return result;\n};\nClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n{\n  var match = true;\n  switch (nt)\n  {\n  case ClipperLib.Clipper.NodeType.ntOpen:\n    return;\n  case ClipperLib.Clipper.NodeType.ntClosed:\n    match = !polynode.IsOpen;\n    break;\n  default:\n    break;\n  }\n  if (polynode.m_polygon.length > 0 && match)\n    paths.push(polynode.m_polygon);\n  for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n    ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n};\nClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n{\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.ChildCount());\n  for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n    if (polytree.Childs()[i].IsOpen)\n      result.push(polytree.Childs()[i].m_polygon);\n  return result;\n};\nClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n{\n  var result = new ClipperLib.Paths();\n  //result.set_Capacity(polytree.Total());\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n  return result;\n};\nInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\nClipperLib.Clipper.NodeType = {\n  ntAny: 0,\n  ntOpen: 1,\n  ntClosed: 2\n};\nClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n{\n  if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n  if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n  this.m_destPolys = new ClipperLib.Paths();\n  this.m_srcPoly = new ClipperLib.Path();\n  this.m_destPoly = new ClipperLib.Path();\n  this.m_normals = new Array();\n  this.m_delta = 0;\n  this.m_sinA = 0;\n  this.m_sin = 0;\n  this.m_cos = 0;\n  this.m_miterLim = 0;\n  this.m_StepsPerRad = 0;\n  this.m_lowest = new ClipperLib.IntPoint();\n  this.m_polyNodes = new ClipperLib.PolyNode();\n  this.MiterLimit = miterLimit;\n  this.ArcTolerance = arcTolerance;\n  this.m_lowest.X = -1;\n};\nClipperLib.ClipperOffset.two_pi = 6.28318530717959;\nClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\nClipperLib.ClipperOffset.prototype.Clear = function ()\n{\n  ClipperLib.Clear(this.m_polyNodes.Childs());\n  this.m_lowest.X = -1;\n};\nClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\nClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n{\n  var highI = path.length - 1;\n  if (highI < 0)\n    return;\n  var newNode = new ClipperLib.PolyNode();\n  newNode.m_jointype = joinType;\n  newNode.m_endtype = endType;\n  //strip duplicate points from path and also get index to the lowest point ...\n  if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n    while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n      highI--;\n  //newNode.m_polygon.set_Capacity(highI + 1);\n  newNode.m_polygon.push(path[0]);\n  var j = 0,\n    k = 0;\n  for (var i = 1; i <= highI; i++)\n    if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n    {\n      j++;\n      newNode.m_polygon.push(path[i]);\n      if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n        k = j;\n    }\n  if ((endType == ClipperLib.EndType.etClosedPolygon && j < 2) || (endType != ClipperLib.EndType.etClosedPolygon && j < 0))\n    return;\n  this.m_polyNodes.AddChild(newNode);\n  //if this path's lowest pt is lower than all the others then update m_lowest\n  if (endType != ClipperLib.EndType.etClosedPolygon)\n    return;\n  if (this.m_lowest.X < 0)\n    this.m_lowest = new ClipperLib.IntPoint(0, k);\n  else\n  {\n    var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n    if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n  }\n};\nClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n{\n  for (var i = 0, ilen = paths.length; i < ilen; i++)\n    this.AddPath(paths[i], joinType, endType);\n};\nClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n{\n  //fixup orientations of all closed paths if the orientation of the\n  //closed path with the lowermost vertex is wrong ...\n  if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n  {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n        node.m_polygon.reverse();\n    }\n  }\n  else\n  {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n        node.m_polygon.reverse();\n    }\n  }\n};\nClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n{\n  var dx = (pt2.X - pt1.X);\n  var dy = (pt2.Y - pt1.Y);\n  if ((dx == 0) && (dy == 0))\n    return new ClipperLib.DoublePoint(0, 0);\n  var f = 1 / Math.sqrt(dx * dx + dy * dy);\n  dx *= f;\n  dy *= f;\n  return new ClipperLib.DoublePoint(dy, -dx);\n};\nClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n{\n  this.m_destPolys = new Array();\n  this.m_delta = delta;\n  //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n  if (ClipperLib.ClipperBase.near_zero(delta))\n  {\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_destPolys.push(node.m_polygon);\n    }\n    return;\n  }\n  //see offset_triginometry3.svg in the documentation folder ...\n  if (this.MiterLimit > 2)\n    this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n  else\n    this.m_miterLim = 0.5;\n  var y;\n  if (this.ArcTolerance <= 0)\n    y = ClipperLib.ClipperOffset.def_arc_tolerance;\n  else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n    y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n  else\n    y = this.ArcTolerance;\n  //see offset_triginometry2.svg in the documentation folder ...\n  var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n  this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n  if (delta < 0)\n    this.m_sin = -this.m_sin;\n  //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n  for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n  {\n    var node = this.m_polyNodes.Childs()[i];\n    this.m_srcPoly = node.m_polygon;\n    var len = this.m_srcPoly.length;\n    if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n      continue;\n    this.m_destPoly = new Array();\n    if (len == 1)\n    {\n      if (node.m_jointype == ClipperLib.JoinType.jtRound)\n      {\n        var X = 1,\n          Y = 0;\n        for (var j = 1; j <= steps; j++)\n        {\n          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n          var X2 = X;\n          X = X * this.m_cos - this.m_sin * Y;\n          Y = X2 * this.m_sin + Y * this.m_cos;\n        }\n      }\n      else\n      {\n        var X = -1,\n          Y = -1;\n        for (var j = 0; j < 4; ++j)\n        {\n          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n          if (X < 0)\n            X = 1;\n          else if (Y < 0)\n            Y = 1;\n          else\n            X = -1;\n        }\n      }\n      this.m_destPolys.push(this.m_destPoly);\n      continue;\n    }\n    //build m_normals ...\n    this.m_normals.length = 0;\n    //this.m_normals.set_Capacity(len);\n    for (var j = 0; j < len - 1; j++)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n    if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n    else\n      this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n    if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n    {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    }\n    else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n    {\n      var k = len - 1;\n      for (var j = 0; j < len; j++)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n      this.m_destPoly = new Array();\n      //re-build m_normals ...\n      var n = this.m_normals[len - 1];\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n      this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n      k = 0;\n      for (var j = len - 1; j >= 0; j--)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      this.m_destPolys.push(this.m_destPoly);\n    }\n    else\n    {\n      var k = 0;\n      for (var j = 1; j < len - 1; ++j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      var pt1;\n      if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n      {\n        var j = len - 1;\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n        this.m_destPoly.push(pt1);\n      }\n      else\n      {\n        var j = len - 1;\n        k = len - 2;\n        this.m_sinA = 0;\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n        if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(j, k);\n        else\n          this.DoRound(j, k);\n      }\n      //re-build m_normals ...\n      for (var j = len - 1; j > 0; j--)\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n      this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n      k = len - 1;\n      for (var j = k - 1; j > 0; --j)\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n      {\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n        this.m_destPoly.push(pt1);\n      }\n      else\n      {\n        k = 1;\n        this.m_sinA = 0;\n        if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n          this.DoSquare(0, 1);\n        else\n          this.DoRound(0, 1);\n      }\n      this.m_destPolys.push(this.m_destPoly);\n    }\n  }\n};\nClipperLib.ClipperOffset.prototype.Execute = function ()\n{\n  var a = arguments,\n    ispolytree = a[0] instanceof ClipperLib.PolyTree;\n  if (!ispolytree) // function (solution, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    ClipperLib.Clear(solution);\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0)\n    {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    }\n    else\n    {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n      outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n      outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n      outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      if (solution.length > 0)\n        solution.splice(0, 1);\n    }\n    //console.log(JSON.stringify(solution));\n  }\n  else // function (polytree, delta)\n  {\n    var solution = a[0],\n      delta = a[1];\n    solution.Clear();\n    this.FixOrientations();\n    this.DoOffset(delta);\n    //now clean up 'corners' ...\n    var clpr = new ClipperLib.Clipper(0);\n    clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n    if (delta > 0)\n    {\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n    }\n    else\n    {\n      var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n      var outer = new ClipperLib.Path();\n      outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n      outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n      outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n      outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n      clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n      clpr.ReverseSolution = true;\n      clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n      //remove the outer PolyNode rectangle ...\n      if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n      {\n        var outerNode = solution.Childs()[0];\n        //solution.Childs.set_Capacity(outerNode.ChildCount);\n        solution.Childs()[0] = outerNode.Childs()[0];\n        for (var i = 1; i < outerNode.ChildCount(); i++)\n          solution.AddChild(outerNode.Childs()[i]);\n      }\n      else\n        solution.Clear();\n    }\n  }\n};\nClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n{\n  this.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n  if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005)\n    return k;\n  else if (this.m_sinA > 1)\n    this.m_sinA = 1.0;\n  else if (this.m_sinA < -1)\n    this.m_sinA = -1.0;\n  if (this.m_sinA * this.m_delta < 0)\n  {\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n    this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  }\n  else\n    switch (jointype)\n    {\n    case ClipperLib.JoinType.jtMiter:\n      {\n        var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n        if (r >= this.m_miterLim)\n          this.DoMiter(j, k, r);\n        else\n          this.DoSquare(j, k);\n        break;\n      }\n    case ClipperLib.JoinType.jtSquare:\n      this.DoSquare(j, k);\n      break;\n    case ClipperLib.JoinType.jtRound:\n      this.DoRound(j, k);\n      break;\n    }\n  k = j;\n  return k;\n};\nClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n{\n  var dx = Math.tan(Math.atan2(this.m_sinA,\n    this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n  this.m_destPoly.push(new ClipperLib.IntPoint(\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n  this.m_destPoly.push(new ClipperLib.IntPoint(\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n};\nClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n{\n  var q = this.m_delta / r;\n  this.m_destPoly.push(new ClipperLib.IntPoint(\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n};\nClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n{\n  var a = Math.atan2(this.m_sinA,\n    this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n  var steps = ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a)));\n  var X = this.m_normals[k].X,\n    Y = this.m_normals[k].Y,\n    X2;\n  for (var i = 0; i < steps; ++i)\n  {\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n    X2 = X;\n    X = X * this.m_cos - this.m_sin * Y;\n    Y = X2 * this.m_sin + Y * this.m_cos;\n  }\n  this.m_destPoly.push(new ClipperLib.IntPoint(\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n    ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n};\nClipperLib.Error = function (message)\n{\n  try\n  {\n    throw new Error(message);\n  }\n  catch (err)\n  {\n    alert(err.message);\n  }\n};\n// ---------------------------------\n// JS extension by Timo 2013\nClipperLib.JS = {};\nClipperLib.JS.AreaOfPolygon = function (poly, scale)\n{\n  if (!scale) scale = 1;\n  return ClipperLib.Clipper.Area(poly) / (scale * scale);\n};\nClipperLib.JS.AreaOfPolygons = function (poly, scale)\n{\n  if (!scale) scale = 1;\n  var area = 0;\n  for (var i = 0; i < poly.length; i++)\n  {\n    area += ClipperLib.Clipper.Area(poly[i]);\n  }\n  return area / (scale * scale);\n};\nClipperLib.JS.BoundsOfPath = function (path, scale)\n{\n  return ClipperLib.JS.BoundsOfPaths([path], scale);\n};\nClipperLib.JS.BoundsOfPaths = function (paths, scale)\n{\n  if (!scale) scale = 1;\n  var bounds = ClipperLib.Clipper.GetBounds(paths);\n  bounds.left /= scale;\n  bounds.bottom /= scale;\n  bounds.right /= scale;\n  bounds.top /= scale;\n  return bounds;\n};\n// Clean() joins vertices that are too near each other\n// and causes distortion to offsetted polygons without cleaning\nClipperLib.JS.Clean = function (polygon, delta)\n{\n  if (!(polygon instanceof Array)) return [];\n  var isPolygons = polygon[0] instanceof Array;\n  var polygon = ClipperLib.JS.Clone(polygon);\n  if (typeof delta != \"number\" || delta === null)\n  {\n    ClipperLib.Error(\"Delta is not a number in Clean().\");\n    return polygon;\n  }\n  if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n  if (!isPolygons) polygon = [polygon];\n  var k_length = polygon.length;\n  var len, poly, result, d, p, j, i;\n  var results = [];\n  for (var k = 0; k < k_length; k++)\n  {\n    poly = polygon[k];\n    len = poly.length;\n    if (len === 0) continue;\n    else if (len < 3)\n    {\n      result = poly;\n      results.push(result);\n      continue;\n    }\n    result = poly;\n    d = delta * delta;\n    //d = Math.floor(c_delta * c_delta);\n    p = poly[0];\n    j = 1;\n    for (i = 1; i < len; i++)\n    {\n      if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n        (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n        continue;\n      result[j] = poly[i];\n      p = poly[i];\n      j++;\n    }\n    p = poly[j - 1];\n    if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n      (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n      j--;\n    if (j < len)\n      result.splice(j, len - j);\n    if (result.length) results.push(result);\n  }\n  if (!isPolygons && results.length) results = results[0];\n  else if (!isPolygons && results.length === 0) results = [];\n  else if (isPolygons && results.length === 0) results = [\n    []\n  ];\n  return results;\n}\n// Make deep copy of Polygons or Polygon\n// so that also IntPoint objects are cloned and not only referenced\n// This should be the fastest way\nClipperLib.JS.Clone = function (polygon)\n{\n  if (!(polygon instanceof Array)) return [];\n  if (polygon.length === 0) return [];\n  else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var len = polygon.length,\n    plen, i, j, result;\n  var results = new Array(len);\n  for (i = 0; i < len; i++)\n  {\n    plen = polygon[i].length;\n    result = new Array(plen);\n    for (j = 0; j < plen; j++)\n    {\n      result[j] = {\n        X: polygon[i][j].X,\n        Y: polygon[i][j].Y\n      };\n    }\n    results[i] = result;\n  }\n  if (!isPolygons) results = results[0];\n  return results;\n};\n// Removes points that doesn't affect much to the visual appearance.\n// If middle point is at or under certain distance (tolerance) of the line segment between \n// start and end point, the middle point is removed.\nClipperLib.JS.Lighten = function (polygon, tolerance)\n{\n  if (!(polygon instanceof Array)) return [];\n  if (typeof tolerance != \"number\" || tolerance === null)\n  {\n    ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n    return ClipperLib.JS.Clone(polygon);\n  }\n  if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n  {\n    return ClipperLib.JS.Clone(polygon);\n  }\n  if (!(polygon[0] instanceof Array)) polygon = [polygon];\n  var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n  var bxax, byay, l, ax, ay;\n  var len = polygon.length;\n  var toleranceSq = tolerance * tolerance;\n  var results = [];\n  for (i = 0; i < len; i++)\n  {\n    poly = polygon[i];\n    plen = poly.length;\n    if (plen == 0) continue;\n    for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n    {\n      poly2 = [];\n      plen = poly.length;\n      // the first have to added to the end, if first and last are not the same\n      // this way we ensure that also the actual last point can be removed if needed\n      if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n      {\n        addlast = 1;\n        poly.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        plen = poly.length;\n      }\n      else addlast = 0;\n      rem = []; // Indexes of removed points\n      for (j = 0; j < plen - 2; j++)\n      {\n        A = poly[j]; // Start point of line segment\n        P = poly[j + 1]; // Middle point. This is the one to be removed.\n        B = poly[j + 2]; // End point of line segment\n        ax = A.X;\n        ay = A.Y;\n        bxax = B.X - ax;\n        byay = B.Y - ay;\n        if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n        {\n          l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n          if (l > 1)\n          {\n            ax = B.X;\n            ay = B.Y;\n          }\n          else if (l > 0)\n          {\n            ax += bxax * l;\n            ay += byay * l;\n          }\n        }\n        bxax = P.X - ax;\n        byay = P.Y - ay;\n        d = bxax * bxax + byay * byay;\n        if (d <= toleranceSq)\n        {\n          rem[j + 1] = 1;\n          j++; // when removed, transfer the pointer to the next one\n        }\n      }\n      // add all unremoved points to poly2\n      poly2.push(\n      {\n        X: poly[0].X,\n        Y: poly[0].Y\n      });\n      for (j = 1; j < plen - 1; j++)\n        if (!rem[j]) poly2.push(\n        {\n          X: poly[j].X,\n          Y: poly[j].Y\n        });\n      poly2.push(\n      {\n        X: poly[plen - 1].X,\n        Y: poly[plen - 1].Y\n      });\n      // if the first point was added to the end, remove it\n      if (addlast) poly.pop();\n      // break, if there was not anymore removed points\n      if (!rem.length) break;\n      // else continue looping using poly2, to check if there are points to remove\n      else poly = poly2;\n    }\n    plen = poly2.length;\n    // remove duplicate from end, if needed\n    if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n    {\n      poly2.pop();\n    }\n    if (poly2.length > 2) // to avoid two-point-polygons\n      results.push(poly2);\n  }\n  if (!polygon[0] instanceof Array) results = results[0];\n  if (typeof (results) == \"undefined\") results = [\n    []\n  ];\n  return results;\n}\nClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n{\n  if (typeof (path) == \"undefined\") return 0;\n  var sqrt = Math.sqrt;\n  var perimeter = 0.0;\n  var p1, p2, p1x = 0.0,\n    p1y = 0.0,\n    p2x = 0.0,\n    p2y = 0.0;\n  var j = path.length;\n  if (j < 2) return 0;\n  if (closed)\n  {\n    path[j] = path[0];\n    j++;\n  }\n  while (--j)\n  {\n    p1 = path[j];\n    p1x = p1.X;\n    p1y = p1.Y;\n    p2 = path[j - 1];\n    p2x = p2.X;\n    p2y = p2.Y;\n    perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n  }\n  if (closed) path.pop();\n  return perimeter / scale;\n};\nClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n{\n  if (!scale) scale = 1;\n  var perimeter = 0;\n  for (var i = 0; i < paths.length; i++)\n  {\n    perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n  }\n  return perimeter;\n};\nClipperLib.JS.ScaleDownPath = function (path, scale)\n{\n  var i, p;\n  if (!scale) scale = 1;\n  i = path.length;\n  while (i--)\n  {\n    p = path[i];\n    p.X = p.X / scale;\n    p.Y = p.Y / scale;\n  }\n};\nClipperLib.JS.ScaleDownPaths = function (paths, scale)\n{\n  var i, j, p, round = Math.round;\n  if (!scale) scale = 1;\n  i = paths.length;\n  while (i--)\n  {\n    j = paths[i].length;\n    while (j--)\n    {\n      p = paths[i][j];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  }\n};\nClipperLib.JS.ScaleUpPath = function (path, scale)\n{\n  var i, p, round = Math.round;\n  if (!scale) scale = 1;\n  i = path.length;\n  while (i--)\n  {\n    p = path[i];\n    p.X = round(p.X * scale);\n    p.Y = round(p.Y * scale);\n  }\n};\nClipperLib.JS.ScaleUpPaths = function (paths, scale)\n{\n  var i, j, p, round = Math.round;\n  if (!scale) scale = 1;\n  i = paths.length;\n  while (i--)\n  {\n    j = paths[i].length;\n    while (j--)\n    {\n      p = paths[i][j];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  }\n};\nClipperLib.ExPolygons = function ()\n{\n  return [];\n}\nClipperLib.ExPolygon = function ()\n{\n  this.outer = null;\n  this.holes = null;\n};\nClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n{\n  var ep = new ClipperLib.ExPolygon();\n  ep.outer = polynode.Contour();\n  var childs = polynode.Childs();\n  var ilen = childs.length;\n  ep.holes = new Array(ilen);\n  var node, n, i, j, childs2, jlen;\n  for (i = 0; i < ilen; i++)\n  {\n    node = childs[i];\n    ep.holes[i] = node.Contour();\n    //Add outer polygons contained by (nested within) holes ...\n    for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n    {\n      n = childs2[j];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n    }\n  }\n  expolygons.push(ep);\n};\nClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n{\n  var a, i, alen, ilen;\n  var paths = new ClipperLib.Paths();\n  for (a = 0, alen = expolygons.length; a < alen; a++)\n  {\n    paths.push(expolygons[a].outer);\n    for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n    {\n      paths.push(expolygons[a].holes[i]);\n    }\n  }\n  return paths;\n}\nClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n{\n  var expolygons = new ClipperLib.ExPolygons();\n  var node, i, childs, ilen;\n  for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n  {\n    node = childs[i];\n    ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n  }\n  return expolygons;\n};\n\n\nmodule.exports = ClipperLib;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/js-clipper/clipper.js\n// module id = 2\n// module chunks = 0","\nvar L = require('leaflet');\n\nvar MinZoomIndicator = L.Control.extend({\n\n    options: {\n\n    },\n\n    _layers: {},\n\n    initialize: function (options) {\n\n        L.Util.setOptions(this, options);\n\n        this._layers = {};\n    },\n\n    _addLayer: function(layer) {\n\n        var minZoom = 15;\n\n        if (layer.options.minZoom) {\n\n            minZoom = layer.options.minZoom;\n        }\n\n        this._layers[layer._leaflet_id] = minZoom;\n\n        this._updateBox(null);\n    },\n\n    _removeLayer: function(layer) {\n\n        this._layers[layer._leaflet_id] = null;\n\n        this._updateBox(null);\n    },\n\n    _getMinZoomLevel: function() {\n\n        var key,\n        minZoomLevel =- 1;\n\n        for(key in this._layers) {\n\n            if ( this._layers[key] !== null && this._layers[key] > minZoomLevel ) {\n\n                minZoomLevel = this._layers[key];\n            }\n        }\n\n        return minZoomLevel;\n    },\n\n\n    _updateBox: function (event) {\n\n        var minZoomLevel = this._getMinZoomLevel();\n\n        if (event !== null) {\n\n            L.DomEvent.preventDefault(event);\n        }\n\n        if (minZoomLevel == -1) {\n\n            this._container.innerHTML = this.options.minZoomMessageNoLayer;\n        } else {\n\n            this._container.innerHTML = this.options.minZoomMessage\n                    .replace(/CURRENTZOOM/, this._map.getZoom())\n                    .replace(/MINZOOMLEVEL/, minZoomLevel);\n        }\n\n        if (this._map.getZoom() >= minZoomLevel) {\n\n            this._container.style.display = 'none';\n        } else {\n\n            this._container.style.display = 'block';\n        }\n    },\n\n    onAdd: function (map) {\n\n        this._map = map;\n\n        this._map.zoomIndicator = this;\n\n        this._container = L.DomUtil.create('div', 'leaflet-control-minZoomIndicator');\n\n        this._map.on('moveend', this._updateBox, this);\n\n        this._updateBox(null);\n\n        return this._container;\n    },\n\n    onRemove: function(map) {\n\n        L.Control.prototype.onRemove.call(this, map);\n\n        map.off({\n\n            'moveend': this._updateBox\n        }, this);\n\n        this._map = null;\n    },\n});\n\n\nL.Control.MinZoomIndicator = MinZoomIndicator;\nmodule.exports = MinZoomIndicator;\n\n\n\n// WEBPACK FOOTER //\n// ./MinZoomIndicator.js"],"sourceRoot":""}